
<!DOCTYPE html>




<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>16.5. Shortest-Paths Problems &mdash; COMP232: Data Structures and Algorithms</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/normalize.css" type="text/css" />
    <link rel="stylesheet" href="../../../JSAV/css/JSAV.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/odsaMOD-min.css" type="text/css" />
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.11.4/themes/smoothness/jquery-ui.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/odsaStyle-min.css" type="text/css" />
    
  <script type="text/javascript">
    var DOCUMENTATION_OPTIONS = {
      URL_ROOT:    './',
      VERSION:     '0.4.1',
      COLLAPSE_INDEX: false,
      FILE_SUFFIX: '.html',
      HAS_SOURCE:  true
    };
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
      },
      "HTML-CSS": {
        scale: "80"
      }
    });
  </script>
    <link rel="index" title="COMP232: Data Structures and Algorithms" href="index.html" />
    <link rel="next" title="6. Minimal Cost Spanning Trees" href="MCST.html" />
    <link rel="prev" title="4. Topological Sort" href="GraphTopsort.html" />

  </head>

  <body>


      <div class="header">
        
  
      <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
      <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="https://code.jquery.com/ui/1.11.4/jquery-ui.min.js"></script>
    <script type="text/javascript" src="../../../JSAV/lib/jquery.transit.js"></script>
    <script type="text/javascript" src="../../../JSAV/lib/raphael.js"></script>
    <script type="text/javascript" src="../../../JSAV/build/JSAV-min.js"></script>
    <script type="text/javascript" src="_static/config.js"></script>
    <script type="text/javascript" src="../../../lib/odsaUtils-min.js"></script>
    <script type="text/javascript" src="../../../lib/odsaMOD-min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js"></script>
    <script type="text/javascript" src="../../../lib/dataStructures.js"></script>
    <script type="text/javascript" src="../../../lib/conceptMap.js"></script>

        
<a id="username-link" style="float:right;color:red;margin:10px 20px auto; display: none" class="username-link" href="Gradebook.html"></a>
<a id="login-link" style="float:right;color:red;margin:10px 20px auto" class="login-link" href="#"><Macro 'login'></a>
<div id="login-box" class="login-popup">
  <a href="#" class="close"><img src="_static/Images/close_pop.png" class="btn_close" title="Close Window" alt="Close" /></a>
  <form method="post" class="signin" action="https://#">
    <fieldset class="textbox">
      <label class="username">
        <span>Username</span>
        <input id="username" value="" type="text" autocomplete="on" placeholder="Username" tabindex="1">
      </label>
      <label class="password">
        <span>Password</span>
        <input id="password" value="" type="password" placeholder="Password" tabindex="2">
        <span><a id="forgot" href="#">Forgot your password?</a></span>
      </label>

      <p>
        <input type="submit" id="login-submit-button" value="Sign in" tabindex="3" />
      </p>
      <p>
        <input type="button" id="register-button" value="Register" tabindex="4" />
      </p>
    </fieldset>
  </form>
</div>

        
<a id="registration-link" style="float:right;color:red;margin:10px 20px auto" class="registration-link" href="#">Register</a>
<div id="registration-box" class="registration-popup ">
  <a href="#" class="close"><img src="_static/Images/close_pop.png" class="btn_close" title="Close Window" alt="Close Window" /></a>
  <form method="post" class="signin" action="https://#">
    <fieldset class="textbox">
      <div id="register_error" class="error"></div>
      <label class="username">
        <span>Username:</span>
        <input type="text" id="user" placeholder="Username" />
      </label>

      <label class="password">
        <span>Password</span>
        <input id="pass" type="password" placeholder="Password" />
      </label>

      <label class="password">
        <span>Confirm Password</span>
        <input id="rpass" type="password" placeholder="Confirm Password" />
      </label>

      <label class="email">
        <span>Email:</span>
        <input type="text" id="email" placeholder="Email">
      </label>

      <p>
        <input type="submit" id="register-submit-button" value="Register &rarr;"/>
      </p>
    </fieldset>
  </form>
</div>
<img class="leftlogo" src="_static/OpenDSALogoT64.png" alt="Logo"/><div class="title-wrapper">
          <div class="title-inbetween" style="display: table-cell; vertical-align: middle;">
            <div class="title-content">
              <h1 class="heading" ><a href="index.html">
                <span>COMP232: Data Structures and Algorithms</span></a></h1>
              <h2 class="heading" ><span>Chapter 16 Graphs</span></h2>
            </div>
          </div>
        </div>
      </div>
      <div class="topnav">
        <p>
            <a style="float:left;color:blue;" href="../source/GraphShortest.rst"
              target="_blank" rel="nofollow">Show Source | </a>&#160;&#160;
            <a class="abt" style="float:left;color:blue;" href="#" rel="nofollow">| About</a>&#160;&#160;

          
        «&#160;&#160;<a id="prevmod" href="GraphTopsort.html">16.4. Topological Sort</a>
        &#160;&#160;::&#160;&#160;
        <a  class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a  id="nextmod" href="MCST.html">16.6. Minimal Cost Spanning Trees</a>&#160;&#160;»


        </p>
      </div>
       
      <div class="content">
        
  <script>ODSA.SETTINGS.DISP_MOD_COMP = true;ODSA.SETTINGS.MODULE_NAME = "GraphShortest";ODSA.SETTINGS.MODULE_LONG_NAME = "Shortest-Paths Problems";ODSA.SETTINGS.MODULE_CHAPTER = "Graphs"; ODSA.SETTINGS.BUILD_DATE = "2017-11-27 23:03:58"; ODSA.SETTINGS.BUILD_CMAP = false;JSAV_OPTIONS['lang']='en';JSAV_EXERCISE_OPTIONS['code']='java_generic';</script><div class="section" id="shortest-paths-problems">
<h1>16.5. Shortest-Paths Problems<a class="headerlink" href="#shortest-paths-problems" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2>16.5.1. Shortest-Paths Problems<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>On a road map, a road connecting two towns is typically
labeled with its distance.
We can model a road network as a directed graph whose edges are
labeled with real numbers.
These numbers represent the distance (or other cost metric, such as
travel time) between two vertices.
These labels may be called <a class="reference internal" href="Glossary.html#term-weight"><em class="xref std std-term ODSAterm">weights</em></a>,
<a class="reference internal" href="Glossary.html#term-cost"><em class="xref std std-term ODSAterm">costs</em></a>, or <a class="reference internal" href="Glossary.html#term-distance"><em class="xref std std-term ODSAterm">distances</em></a>,
depending on the application.
Given such a graph, a typical problem is to find the total
length of the shortest path between two specified vertices.
This is not a trivial problem, because the shortest path may not be
along the edge (if any) connecting two vertices, but rather may be
along a path involving one or more intermediate vertices.</p>
<p>For example, in Figure <a href="GraphShortest.html#distexamp">16.5.1</a>,
the cost of the path from <span class="math">\(A\)</span> to <span class="math">\(B\)</span> to <span class="math">\(D\)</span> is 15.
The cost of the edge directly from <span class="math">\(A\)</span> to <span class="math">\(D\)</span> is 20.
The cost of the path from <span class="math">\(A\)</span> to <span class="math">\(C\)</span> to <span class="math">\(B\)</span> to
<span class="math">\(D\)</span> is 10.
Thus, the shortest path from <span class="math">\(A\)</span> to <span class="math">\(D\)</span> is 10
(rather than along the edge connecting <span class="math">\(A\)</span> to <span class="math">\(D\)</span>).
We use the notation <span class="math">\(\mathbf{d}(A, D) = 10\)</span> to indicate that the
shortest distance from <span class="math">\(A\)</span> to <span class="math">\(D\)</span> is 10.
In Figure <a href="GraphShortest.html#distexamp">16.5.1</a>, there is no path from <span class="math">\(E\)</span> to
<span class="math">\(B\)</span>, so we set <span class="math">\(\mathbf{d}(E, B) = \infty\)</span>.
We define <span class="math">\(\mathbf{w}(A, D) = 20\)</span> to be the weight of edge
<span class="math">\((A, D)\)</span>, that is, the weight of the direct connection
from <span class="math">\(A\)</span> to <span class="math">\(D\)</span>.
Because there is no edge from <span class="math">\(E\)</span> to <span class="math">\(B\)</span>,
<span class="math">\(\mathbf{w}(E, B) = \infty\)</span>.
Note that <span class="math">\(\mathbf{w}(D, A) = \infty\)</span> because the graph of
Figure <a href="GraphShortest.html#distexamp">16.5.1</a> is directed.
We assume that all weights are positive.</p>
<div class="divdgm" id="distexamp">
<div id="dijkstraCON">
</div>
<p class="caption" style="text-align: center"> Figure 16.5.1: Example graph for shortest-path definitions.</p>
</div>
<div class="section" id="single-source-shortest-paths">
<h3>16.5.1.1. Single-Source Shortest Paths<a class="headerlink" href="#single-source-shortest-paths" title="Permalink to this headline">¶</a></h3>
<p>We will now present an algorithm to solve the
<a class="reference internal" href="Glossary.html#term-single-source-shortest-paths-problem"><em class="xref std std-term ODSAterm">single-source shortest paths problem</em></a>.
Given Vertex <span class="math">\(S\)</span> in Graph <span class="math">\(\mathbf{G}\)</span>,
find a shortest path from <span class="math">\(S\)</span> to every other vertex in
<span class="math">\(\mathbf{G}\)</span>.
We might want only the shortest path between two vertices,
<span class="math">\(S\)</span> and <span class="math">\(T\)</span>.
However in the worst case, finding the shortest path from
<span class="math">\(S\)</span> to <span class="math">\(T\)</span> requires us to find the shortest paths from
<span class="math">\(S\)</span> to every other vertex as well.
So there is no better algorithm (in the worst case) for
finding the shortest path to a single vertex than to find shortest
paths to all vertices.
The algorithm described here will only compute the distance to every
such vertex, rather than recording the actual path.
Recording the path requires only simple modifications to the algorithm.</p>
<p>Computer networks provide an application for the single-source
shortest-paths problem.
The goal is to find the cheapest way for one computer to broadcast
a message to all other computers on the network.
The network can be modeled by a graph with edge weights indicating
time or
cost to send a message to a neighboring computer.</p>
<p>For unweighted graphs (or whenever all edges have the same cost), the
single-source shortest paths can be found using a simple breadth-first
search.
When weights are added, BFS will not give the correct answer.</p>
<p>One approach to solving this problem when the edges have
differing weights might be to process the
vertices in a fixed order.
Label the vertices <span class="math">\(v_0\)</span> to <span class="math">\(v_{n-1}\)</span>, with
<span class="math">\(S = v_0\)</span>.
When processing Vertex <span class="math">\(v_1\)</span>, we take the edge connecting
<span class="math">\(v_0\)</span> and <span class="math">\(v_1\)</span>.
When processing <span class="math">\(v_2\)</span>, we consider the shortest distance from
<span class="math">\(v_0\)</span> to <span class="math">\(v_2\)</span> and compare that to the shortest
distance from <span class="math">\(v_0\)</span> to <span class="math">\(v_1\)</span> to <span class="math">\(v_2\)</span>.
When processing Vertex <span class="math">\(v_i\)</span>, we consider the shortest
path for Vertices <span class="math">\(v_0\)</span> through <span class="math">\(v_{i-1}\)</span> that have
already been processed.
Unfortunately, the true shortest path to <span class="math">\(v_i\)</span> might go
through Vertex <cite>v_j</cite> for <span class="math">\(j &gt; i\)</span>.
Such a path will not be considered by this algorithm.
However, the problem would not occur if we process the vertices in
order of distance from <span class="math">\(S\)</span>.
Assume that we have processed in order of distance from <span class="math">\(S\)</span> to
the first <span class="math">\(i-1\)</span> vertices that are closest to <span class="math">\(S\)</span>;
call this set of vertices <span class="math">\(\mathbf{S}\)</span>.
We are now about to process the <span class="math">\(i\)</span> th closest vertex; call
it <span class="math">\(X\)</span>.</p>
<p>A shortest path from <span class="math">\(S\)</span> to <span class="math">\(X\)</span> must have its next-to-last
vertex in <span class="math">\(S\)</span>.
Thus,</p>
<div class="math">
\[\mathbf{d}(S, X) =
\min_{U \in \mathbf{S}}(\mathbf{d}(S, U) + \mathbf{w}(U, X)).\]</div>
<p>In other words, the shortest path from <span class="math">\(S\)</span> to <span class="math">\(X\)</span> is the
minimum over all paths that go from <span class="math">\(S\)</span> to <span class="math">\(U\)</span>, then have an
edge from <span class="math">\(U\)</span> to <span class="math">\(X\)</span>, where <span class="math">\(U\)</span> is some vertex
in <span class="math">\(\mathbf{S}\)</span>.</p>
<p>This solution is usually referred to as Dijkstra's algorithm.
It works by maintaining a distance estimate
<span class="math">\(\mathbf{D}(X)\)</span> for all vertices <span class="math">\(X\)</span> in <span class="math">\(\mathbf{V}\)</span>.
The elements of <span class="math">\(\mathbf{D}\)</span> are initialized to the value
<code class="docutils literal"><span class="pre">INFINITE</span></code>.
Vertices are processed in order of distance from <span class="math">\(S\)</span>.
Whenever a vertex <span class="math">\(v\)</span> is processed, <span class="math">\(\mathbf{D}(X)\)</span> is
updated for every neighbor <span class="math">\(X\)</span> of <span class="math">\(V\)</span>.
Here is an implementation for Dijkstra's
algorithm.
At the end, array <code class="docutils literal"><span class="pre">D</span></code> will contain the shortest distance values.</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="c1">// Compute shortest path distances from s, store them in D</span>
<span class="kt">void</span> <span class="nf">Dijkstra</span><span class="o">(</span><span class="n">Graph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">D</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="o">.</span><span class="na">nodeCount</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span>    <span class="c1">// Initialize</span>
    <span class="n">D</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="o">;</span>
  <span class="n">D</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="o">.</span><span class="na">nodeCount</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>  <span class="c1">// Process the vertices</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">minVertex</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">D</span><span class="o">);</span>     <span class="c1">// Find next-closest vertex</span>
    <span class="n">G</span><span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">VISITED</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">D</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">==</span> <span class="n">INFINITY</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span> <span class="c1">// Unreachable</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nList</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="na">neighbors</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">nList</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
      <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">nList</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">D</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">&gt;</span> <span class="o">(</span><span class="n">D</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">G</span><span class="o">.</span><span class="na">weight</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">)))</span>
        <span class="n">D</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">D</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">G</span><span class="o">.</span><span class="na">weight</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<div
    id="DijkstraAV"
    class="embedContainer"
    data-exer-name="DijkstraAV"
    data-long-name="Dijkstra's Algorithm Visualization"
    data-frame-src="../../../AV/Graph/DijkstraAV.html?selfLoggingEnabled=false&amp;localMode=true&amp;module=GraphShortest&amp;JOP-lang=en&amp;JXOP-code=java_generic"
    data-frame-width="950"
    data-frame-height="650"
    data-external="false"
    data-points="0"
    data-required="False"
    data-showhide="none"
    data-threshold="1.0"
    data-type="ss">
  
  <div class="center">
    <div id="DijkstraAV_iframe"></div>
  </div>
</div>
<p>There are two reasonable solutions to the key issue of finding the
unvisited vertex with minimum distance value during each pass through
the main <code class="docutils literal"><span class="pre">for</span></code> loop.
The first method is simply to scan through the list of
<span class="math">\(|\mathbf{V}|\)</span> vertices searching for the minimum value, as
follows:</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="c1">// Find the unvisited vertex with the smalled distance</span>
<span class="kt">int</span> <span class="nf">minVertex</span><span class="o">(</span><span class="n">Graph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">D</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  <span class="c1">// Initialize v to any unvisited vertex;</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="o">.</span><span class="na">nodeCount</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">G</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">VISITED</span><span class="o">)</span> <span class="o">{</span> <span class="n">v</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="k">break</span><span class="o">;</span> <span class="o">}</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="o">.</span><span class="na">nodeCount</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span>  <span class="c1">// Now find smallest value</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">G</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">VISITED</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">D</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">D</span><span class="o">[</span><span class="n">v</span><span class="o">]))</span>
      <span class="n">v</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
  <span class="k">return</span> <span class="n">v</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Because this scan is done <span class="math">\(|\mathbf{V}|\)</span> times,
and because each edge requires a constant-time update to <code class="docutils literal"><span class="pre">D</span></code>,
the total cost for this approach
is <span class="math">\(\Theta(|\mathbf{V}|^2 + |\mathbf{E}|) =
\Theta(|\mathbf{V}|^2)\)</span>,
because <span class="math">\(|\mathbf{E}|\)</span> is in <span class="math">\(O(|\mathbf{V}|^2)\)</span>.</p>
<p>An alternative approach is to store unprocessed vertices in a
min-heap ordered by their distance from the processed vertices.
The next-closest vertex can be found in the heap in
<span class="math">\(\Theta(\log |\mathbf{V}|)\)</span> time.
Every time we modify <span class="math">\(\mathbf{D}(X)\)</span>,
we could reorder <span class="math">\(X\)</span> in
the heap by deleting and reinserting it.
This is an example of a <a class="reference internal" href="Heaps.html#heaps"><em>priority queue</em></a>
with priority update.
To implement true priority updating, we would need to store with each
vertex its position within the heap so that we can remove its old
distances whenever it is updated by processing new edges.
A simpler approach is to add the new (always smaller) distance value
for a given vertex as a new record in the heap.
The smallest value for a given vertex currently in the heap will be
found first, and greater distance values found later will be ignored
because the vertex will already be marked as <code class="docutils literal"><span class="pre">VISITED</span></code>.
The only disadvantage to repeatedly inserting distance values in this
way is that it will raise the number of elements in the heap from
<span class="math">\(\Theta(|\mathbf{V}|)\)</span> to <span class="math">\(\Theta(|\mathbf{E}|)\)</span>
in the worst case.
But in practice this only adds a slight increase to the depth of the
heap.
The time complexity is
<span class="math">\(\Theta((|\mathbf{V}| + |\mathbf{E}|) \log |\mathbf{E}|)\)</span>,
because for each edge that we process we must reorder the heap.
We use the <code class="docutils literal"><span class="pre">KVPair</span></code> class to store key-value pairs in the heap, with
the edge weight as the key and the target vertex as the value.
here is the implementation for Dijkstra's algorithm using a heap.</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="c1">// Dijkstra&#39;s shortest-paths: priority queue version</span>
<span class="kt">void</span> <span class="nf">DijkstraPQ</span><span class="o">(</span><span class="n">Graph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">D</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">v</span><span class="o">;</span>                                 <span class="c1">// The current vertex</span>
  <span class="n">KVPair</span><span class="o">[]</span> <span class="n">E</span> <span class="o">=</span> <span class="k">new</span> <span class="n">KVPair</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">edgeCount</span><span class="o">()];</span>        <span class="c1">// Heap for edges</span>
  <span class="n">E</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">KVPair</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>               <span class="c1">// Initial vertex</span>
  <span class="n">MinHeap</span> <span class="n">H</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MinHeap</span><span class="o">(</span><span class="n">E</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">G</span><span class="o">.</span><span class="na">edgeCount</span><span class="o">());</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="o">.</span><span class="na">nodeCount</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span>            <span class="c1">// Initialize distance</span>
    <span class="n">D</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="o">;</span>
  <span class="n">D</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="o">.</span><span class="na">nodeCount</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>          <span class="c1">// For each vertex</span>
    <span class="k">do</span> <span class="o">{</span> <span class="n">KVPair</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="na">removemin</span><span class="o">();</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">temp</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>       <span class="c1">// Unreachable nodes exist</span>
         <span class="n">v</span> <span class="o">=</span> <span class="o">(</span><span class="n">Integer</span><span class="o">)</span><span class="n">temp</span><span class="o">.</span><span class="na">value</span><span class="o">();</span> <span class="o">}</span> <span class="c1">// Get position</span>
      <span class="k">while</span> <span class="o">(</span><span class="n">G</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="o">==</span> <span class="n">VISITED</span><span class="o">);</span>
    <span class="n">G</span><span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">VISITED</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">D</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">==</span> <span class="n">INFINITY</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>        <span class="c1">// Unreachable</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nList</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="na">neighbors</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">nList</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
      <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">nList</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">D</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">&gt;</span> <span class="o">(</span><span class="n">D</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">G</span><span class="o">.</span><span class="na">weight</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">)))</span> <span class="o">{</span> <span class="c1">// Update D</span>
        <span class="n">D</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">D</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">+</span> <span class="n">G</span><span class="o">.</span><span class="na">weight</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>
        <span class="n">H</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">D</span><span class="o">[</span><span class="n">w</span><span class="o">],</span> <span class="n">w</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Using <code class="docutils literal"><span class="pre">MinVertex</span></code> to scan the vertex list for the minimum value
is more efficient when the graph is dense, that is, when
<span class="math">\(|\mathbf{E}|\)</span> approaches <span class="math">\(|\mathbf{V}|^2\)</span>.
Using a heap is more efficient when the graph is sparse
because its cost is
<span class="math">\(\Theta((|\mathbf{V}| + |\mathbf{E}|) \log |\mathbf{E}|)\)</span>.
However, when the graph is dense, this cost can become as great as
<span class="math">\(\Theta(|\mathbf{V}|^2 \log |\mathbf{E}|) = \Theta(|V|^2 \log |V|)\)</span>.</p>
<p>Now you can practice using Dijkstra's algorithm.</p>
<div
    id="DijkstraPE"
    class="embedContainer"
    data-exer-name="DijkstraPE"
    data-long-name="Dijkstra's Algorithm Proficiency Exercise"
    data-frame-src="../../../AV/Graph/DijkstraPE.html?selfLoggingEnabled=false&amp;localMode=true&amp;module=GraphShortest&amp;JOP-lang=en&amp;JXOP-code=java_generic"
    data-frame-width="950"
    data-frame-height="650"
    data-external="false"
    data-points="2.0"
    data-required="True"
    data-showhide="show"
    data-threshold="0.9"
    data-type="pe">
  
  <div class="center">
    <div id="DijkstraPE_iframe"></div>
  </div>
</div>
<script type="text/javascript" src="../../../AV/Graph/dijkstraCON.js"></script>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      <p><span class="email_div" style="display:inline;"><a id="contact_us" class="contact" style="float:left;color:blue;" rel="nofollow" href="mailto:">Contact Us |</a><a style="float:left;color:blue;" rel="nofollow" href="../../../lib/Privacy.html" target="_blank">| Privacy |</a> <a style="float:left;color:blue;" rel="nofollow" href="../../../lib/license.html" target="_blank">| License</a></span>&#160;&#160;
      
        «&#160;&#160;<a id="prevmod1" href="GraphTopsort.html">16.4. Topological Sort</a>
        &#160;&#160;::&#160;&#160;
        <a  class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a  id="nextmod1" href="MCST.html">16.6. Minimal Cost Spanning Trees</a>&#160;&#160;»

</p>
      </div>
      <img style="float:right;" src="_static/nsf1.gif" height="62" width="62" alt="nsf"/>


    <div class="footer">
      <p>
        <span class="email_div" style="display:inline;">
          <a id="contact_us" class="contact" style="float:left;color:blue;" rel="nofollow" href="mailto:">Contact Us |</a>
          <a id="bugreport-link" style="float:left;color:blue;" class="bugreport-link" href="#">| Report a bug</a>
        </span>
      </p>
        &copy; Copyright 2016 by OpenDSA Project Contributors and distributed under an MIT license.
      Last updated on Nov 27, 2017.
      Created using <a target="_blank" href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.
    </div>
    
<div id="bugreport-box" class="bugreport-popup ">
  <a href="#" class="close"><img src="_static/Images/close_pop.png" class="btn_close" title="Close Window" alt="Close Window" /></a>
  <form method="post" class="report" action="https://#">
    <fieldset class="textbox">
      <div id="bug_error" class="error"></div>
      <label>
        <span>Summary*:</span>
        <input type="text" id="b_title" placeholder="Summary" />
      </label>

      <label class="os">
        <span>Operating system*:</span>
        <select id="b_os">
          <option value="windows">Windows</option>
          <option value="macos">Mac OS</option>
          <option value="linux">Linux</option>
          <option value="ios">iOS</option>
          <option value="android">Android</option>
          <option value="other">Other</option>
        </select>
      </label>

      <label class="browser">
        <span>Browser*:</span>
        <select id="b_browser">
          <option value="chrome">Chrome</option>
          <option value="safari">Safari</option>
          <option value="internetexplorer">Internet Explorer</option>
          <option value="opera">Opera</option>
          <option value="other">Other</option>
        </select>
      </label>

      <label class="description">
        <span>Description*:</span><br>
        <textarea id="b_description" rows="5" cols="25" placeholder="***BUG** Please enter: (1) a consice description of the problem. (2) steps to reproduce bug. (3) the version of your browser and operating system."></textarea>
      </label>

      <label class="screenshot">
        <span>Attach a screenshot (optional):</span>
        <input type="file" id="b_screenshot" accept="image/*" placeholder="Attach a screenshot (optional)">
      </label>

      <p>
        <input type="submit" id="bug-submit-button" value="Submit &rarr;"/>
      </p>
    </fieldset>
  </form>
</div>

  </body>
</html>