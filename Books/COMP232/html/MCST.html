
<!DOCTYPE html>




<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>16.6. Minimal Cost Spanning Trees &mdash; COMP232: Data Structures and Algorithms</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/normalize.css" type="text/css" />
    <link rel="stylesheet" href="../../../JSAV/css/JSAV.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/odsaMOD-min.css" type="text/css" />
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.11.4/themes/smoothness/jquery-ui.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/odsaStyle-min.css" type="text/css" />
    
  <script type="text/javascript">
    var DOCUMENTATION_OPTIONS = {
      URL_ROOT:    './',
      VERSION:     '0.4.1',
      COLLAPSE_INDEX: false,
      FILE_SUFFIX: '.html',
      HAS_SOURCE:  true
    };
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
      },
      "HTML-CSS": {
        scale: "80"
      }
    });
  </script>
    <link rel="index" title="COMP232: Data Structures and Algorithms" href="index.html" />
    <link rel="next" title="7. Kruskal&#39;s Algorithm" href="Kruskal.html" />
    <link rel="prev" title="5. Shortest-Paths Problems" href="GraphShortest.html" />

  </head>

  <body>


      <div class="header">
        
  
      <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
      <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="https://code.jquery.com/ui/1.11.4/jquery-ui.min.js"></script>
    <script type="text/javascript" src="../../../JSAV/lib/jquery.transit.js"></script>
    <script type="text/javascript" src="../../../JSAV/lib/raphael.js"></script>
    <script type="text/javascript" src="../../../JSAV/build/JSAV-min.js"></script>
    <script type="text/javascript" src="_static/config.js"></script>
    <script type="text/javascript" src="../../../lib/odsaUtils-min.js"></script>
    <script type="text/javascript" src="../../../lib/odsaMOD-min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js"></script>
    <script type="text/javascript" src="../../../lib/dataStructures.js"></script>
    <script type="text/javascript" src="../../../lib/conceptMap.js"></script>

        
<a id="username-link" style="float:right;color:red;margin:10px 20px auto; display: none" class="username-link" href="Gradebook.html"></a>
<a id="login-link" style="float:right;color:red;margin:10px 20px auto" class="login-link" href="#"><Macro 'login'></a>
<div id="login-box" class="login-popup">
  <a href="#" class="close"><img src="_static/Images/close_pop.png" class="btn_close" title="Close Window" alt="Close" /></a>
  <form method="post" class="signin" action="https://#">
    <fieldset class="textbox">
      <label class="username">
        <span>Username</span>
        <input id="username" value="" type="text" autocomplete="on" placeholder="Username" tabindex="1">
      </label>
      <label class="password">
        <span>Password</span>
        <input id="password" value="" type="password" placeholder="Password" tabindex="2">
        <span><a id="forgot" href="#">Forgot your password?</a></span>
      </label>

      <p>
        <input type="submit" id="login-submit-button" value="Sign in" tabindex="3" />
      </p>
      <p>
        <input type="button" id="register-button" value="Register" tabindex="4" />
      </p>
    </fieldset>
  </form>
</div>

        
<a id="registration-link" style="float:right;color:red;margin:10px 20px auto" class="registration-link" href="#">Register</a>
<div id="registration-box" class="registration-popup ">
  <a href="#" class="close"><img src="_static/Images/close_pop.png" class="btn_close" title="Close Window" alt="Close Window" /></a>
  <form method="post" class="signin" action="https://#">
    <fieldset class="textbox">
      <div id="register_error" class="error"></div>
      <label class="username">
        <span>Username:</span>
        <input type="text" id="user" placeholder="Username" />
      </label>

      <label class="password">
        <span>Password</span>
        <input id="pass" type="password" placeholder="Password" />
      </label>

      <label class="password">
        <span>Confirm Password</span>
        <input id="rpass" type="password" placeholder="Confirm Password" />
      </label>

      <label class="email">
        <span>Email:</span>
        <input type="text" id="email" placeholder="Email">
      </label>

      <p>
        <input type="submit" id="register-submit-button" value="Register &rarr;"/>
      </p>
    </fieldset>
  </form>
</div>
<img class="leftlogo" src="_static/OpenDSALogoT64.png" alt="Logo"/><div class="title-wrapper">
          <div class="title-inbetween" style="display: table-cell; vertical-align: middle;">
            <div class="title-content">
              <h1 class="heading" ><a href="index.html">
                <span>COMP232: Data Structures and Algorithms</span></a></h1>
              <h2 class="heading" ><span>Chapter 16 Graphs</span></h2>
            </div>
          </div>
        </div>
      </div>
      <div class="topnav">
        <p>
            <a style="float:left;color:blue;" href="../source/MCST.rst"
              target="_blank" rel="nofollow">Show Source | </a>&#160;&#160;
            <a class="abt" style="float:left;color:blue;" href="#" rel="nofollow">| About</a>&#160;&#160;

          
        «&#160;&#160;<a id="prevmod" href="GraphShortest.html">16.5. Shortest-Paths Problems</a>
        &#160;&#160;::&#160;&#160;
        <a  class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a  id="nextmod" href="Kruskal.html">16.7. Kruskal's Algorithm</a>&#160;&#160;»


        </p>
      </div>
       
      <div class="content">
        
  <script>ODSA.SETTINGS.DISP_MOD_COMP = true;ODSA.SETTINGS.MODULE_NAME = "MCST";ODSA.SETTINGS.MODULE_LONG_NAME = "Minimal Cost Spanning Trees";ODSA.SETTINGS.MODULE_CHAPTER = "Graphs"; ODSA.SETTINGS.BUILD_DATE = "2017-11-27 23:03:58"; ODSA.SETTINGS.BUILD_CMAP = false;JSAV_OPTIONS['lang']='en';JSAV_EXERCISE_OPTIONS['code']='java_generic';</script><div class="section" id="minimal-cost-spanning-trees">
<h1>16.6. Minimal Cost Spanning Trees<a class="headerlink" href="#minimal-cost-spanning-trees" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2>16.6.1. Minimal Cost Spanning Trees<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="Glossary.html#term-minimal-cost-spanning-tree"><em class="xref std std-term ODSAterm">minimal-cost spanning tree</em></a> (MCST)
problem takes as input a connected, undirected graph
<span class="math">\(\mathbf{G}\)</span>, where each edge has a distance or weight measure
attached.
The MCST is the graph containing the vertices of <span class="math">\(\mathbf{G}\)</span>
along with the subset of <span class="math">\(\mathbf{G}\)</span> 's edges that
(1) has minimum total cost as measured by summing the values for all
of the edges in the subset, and
(2) keeps the vertices connected.
Applications where a solution to this problem is
useful include soldering the shortest set of wires needed to connect a
set of terminals on a circuit board, and connecting a set of cities by
telephone lines in such a way as to require the least amount of cable.</p>
<p>The MCST contains no cycles.
If a proposed MCST did have a cycle, a cheaper MCST could be
had by removing any one of the edges in the cycle.
Thus, the MCST is a free tree with <span class="math">\(|\mathbf{V}| - 1\)</span> edges.
The name &quot;minimum-cost spanning tree&quot; comes from the fact that the
required set of edges forms a tree, it spans the vertices (i.e., it
connects them together), and it has minimum cost.
Figure <a href="MCST.html#mcstdgm">16.6.1</a> shows the MCST for an example graph.</p>
<div class="divdgm" id="mcstdgm">
<div id="MCSTCON">
</div>
<p class="caption" style="text-align: justify"> Figure 16.6.1: A graph and its MCST.
All edges appear in the original graph.
Those edges drawn with heavy lines indicate
the subset making up the MCST.
Note that edge <span class="math">\((C, F)\)</span> could be replaced with edge
<span class="math">\((D, F)\)</span> to form a different MCST with equal cost.</p>
</div>
<div class="section" id="prim-s-algorithm">
<h3>16.6.1.1. Prim's Algorithm<a class="headerlink" href="#prim-s-algorithm" title="Permalink to this headline">¶</a></h3>
<p>The first of our two algorithms for finding MCSTs is commonly
referred to as <a class="reference internal" href="Glossary.html#term-prim-s-algorithm"><em class="xref std std-term ODSAterm">Prim's algorithm</em></a>.
Prim's algorithm is very simple.
Start with any Vertex <span class="math">\(N\)</span> in the graph, setting the MCST
to be <span class="math">\(N\)</span> initially.
Pick the least-cost edge connected to <span class="math">\(N\)</span>.
This edge connects <span class="math">\(N\)</span> to another vertex; call this <span class="math">\(M\)</span>.
Add Vertex <span class="math">\(M\)</span> and Edge <span class="math">\((N, M)\)</span> to the MCST.
Next, pick the least-cost edge coming from either <span class="math">\(N\)</span> or
<span class="math">\(M\)</span> to any other vertex in the graph.
Add this edge and the new vertex it reaches to the MCST.
This process continues, at each step expanding the MCST by selecting
the least-cost edge from a vertex currently in the MCST to a vertex
not currently in the MCST.</p>
<p>Prim's algorithm is quite similar to Dijkstra's algorithm for finding
the single-source shortest
paths.
The primary difference is that we are seeking not the next closest
vertex to the start vertex, but rather the next closest vertex to any
vertex currently in the MCST.
Thus we replace the lines:</p>
<div class="highlight-guess"><div class="highlight"><pre><span></span>if (D[w] &gt; (D[v] + G.weight(v, w)))
  D[w] = D[v] + G.weight(v, w);
</pre></div>
</div>
<p>in Djikstra's algorithm with the lines:</p>
<div class="highlight-guess"><div class="highlight"><pre><span></span>if (D[w] &gt; G.weight(v, w))
  D[w] = G.weight(v, w);
</pre></div>
</div>
<p>in Prim's algorithm.</p>
<p>The following code shows an implementation for Prim's algorithm
that searches the distance matrix for the next closest vertex.</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="c1">// Compute shortest distances to the MCST, store them in D.</span>
<span class="c1">// V[i] will hold the index for the vertex that is i&#39;s parent in the MCST</span>
<span class="kt">void</span> <span class="nf">Prim</span><span class="o">(</span><span class="n">Graph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">D</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">V</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="o">.</span><span class="na">nodeCount</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span>    <span class="c1">// Initialize</span>
    <span class="n">D</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="o">;</span>
  <span class="n">D</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="o">.</span><span class="na">nodeCount</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>  <span class="c1">// Process the vertices</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">minVertex</span><span class="o">(</span><span class="n">G</span><span class="o">,</span> <span class="n">D</span><span class="o">);</span>     <span class="c1">// Find next-closest vertex</span>
    <span class="n">G</span><span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">VISITED</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">D</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">==</span> <span class="n">INFINITY</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span> <span class="c1">// Unreachable</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">!=</span> <span class="n">s</span><span class="o">)</span> <span class="n">AddEdgetoMST</span><span class="o">(</span><span class="n">V</span><span class="o">[</span><span class="n">v</span><span class="o">],</span> <span class="n">v</span><span class="o">);</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nList</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="na">neighbors</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">nList</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
      <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">nList</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">D</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">G</span><span class="o">.</span><span class="na">weight</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">D</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="na">weight</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>
        <span class="n">V</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>For each vertex <span class="math">\(I\)</span>, when <span class="math">\(I\)</span> is processed by Prim's
algorithm, an edge going to <span class="math">\(I\)</span> is added to the MCST that we are
building.
Array <code class="docutils literal"><span class="pre">V[I]</span></code> stores the previously visited vertex that is
closest to Vertex <cite>I</cite>.
This information lets us know which edge goes into the MCST when
Vertex <span class="math">\(I\)</span> is processed.
The implementation above also contains calls to
<code class="docutils literal"><span class="pre">AddEdgetoMST</span></code> to indicate which edges are actually added to the
MCST.</p>
<div
    id="PrimAV"
    class="embedContainer"
    data-exer-name="PrimAV"
    data-long-name="Prim's Algorithm Visualization"
    data-frame-src="../../../AV/Graph/PrimAV.html?selfLoggingEnabled=false&amp;localMode=true&amp;module=MCST&amp;JOP-lang=en&amp;JXOP-code=java_generic"
    data-frame-width="950"
    data-frame-height="650"
    data-external="false"
    data-points="0"
    data-required="False"
    data-showhide="none"
    data-threshold="1.0"
    data-type="ss">
  
  <div class="center">
    <div id="PrimAV_iframe"></div>
  </div>
</div>
</div>
<div class="section" id="prim-s-algorithm-alternative-implementation">
<h3>16.6.1.2. Prim's Algorithm Alternative Implementation<a class="headerlink" href="#prim-s-algorithm-alternative-implementation" title="Permalink to this headline">¶</a></h3>
<p>Alternatively, we can implement Prim's algorithm using a
<a class="reference internal" href="Glossary.html#term-priority-queue"><em class="xref std std-term ODSAterm">priority queue</em></a> to find the next closest vertex, as
shown next.
As with the priority queue version of Dijkstra's algorithm,
the <a class="reference internal" href="Glossary.html#term-heap"><em class="xref std std-term ODSAterm">heap</em></a> stores <code class="docutils literal"><span class="pre">DijkElem</span></code> objects.</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="c1">// Prims MCST algorithm: priority queue version</span>
<span class="kt">void</span> <span class="nf">PrimPQ</span><span class="o">(</span><span class="n">Graph</span> <span class="n">G</span><span class="o">,</span> <span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">D</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">V</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">v</span><span class="o">;</span>                                 <span class="c1">// The current vertex</span>
  <span class="n">KVPair</span><span class="o">[]</span> <span class="n">E</span> <span class="o">=</span> <span class="k">new</span> <span class="n">KVPair</span><span class="o">[</span><span class="n">G</span><span class="o">.</span><span class="na">edgeCount</span><span class="o">()];</span>        <span class="c1">// Heap for edges</span>
  <span class="n">E</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">KVPair</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">s</span><span class="o">);</span>               <span class="c1">// Initial vertex</span>
  <span class="n">MinHeap</span> <span class="n">H</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MinHeap</span><span class="o">(</span><span class="n">E</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">G</span><span class="o">.</span><span class="na">edgeCount</span><span class="o">());</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="o">.</span><span class="na">nodeCount</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span>            <span class="c1">// Initialize distance</span>
    <span class="n">D</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">INFINITY</span><span class="o">;</span>
  <span class="n">D</span><span class="o">[</span><span class="n">s</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">G</span><span class="o">.</span><span class="na">nodeCount</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>          <span class="c1">// For each vertex</span>
    <span class="k">do</span> <span class="o">{</span> <span class="n">KVPair</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="na">removemin</span><span class="o">();</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">temp</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>       <span class="c1">// Unreachable nodes exist</span>
         <span class="n">v</span> <span class="o">=</span> <span class="o">(</span><span class="n">Integer</span><span class="o">)</span><span class="n">temp</span><span class="o">.</span><span class="na">value</span><span class="o">();</span> <span class="o">}</span> <span class="c1">// Get position</span>
      <span class="k">while</span> <span class="o">(</span><span class="n">G</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="o">==</span> <span class="n">VISITED</span><span class="o">);</span>
    <span class="n">G</span><span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">VISITED</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">D</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">==</span> <span class="n">INFINITY</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>  <span class="c1">// Unreachable</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">!=</span> <span class="n">s</span><span class="o">)</span> <span class="n">AddEdgetoMST</span><span class="o">(</span><span class="n">V</span><span class="o">[</span><span class="n">v</span><span class="o">],</span> <span class="n">v</span><span class="o">);</span> <span class="c1">// Add edge to MST</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">nList</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="na">neighbors</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">nList</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
      <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">nList</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">D</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">G</span><span class="o">.</span><span class="na">weight</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// Update D</span>
        <span class="n">D</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="na">weight</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">w</span><span class="o">);</span>
        <span class="n">V</span><span class="o">[</span><span class="n">w</span><span class="o">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">;</span>                  <span class="c1">// Where it came from</span>
        <span class="n">H</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">D</span><span class="o">[</span><span class="n">w</span><span class="o">],</span> <span class="n">w</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Here is an AV that lets you try Prim's algorithm on other graphs.</p>
<div
    id="PrimAVPQ"
    class="embedContainer"
    data-exer-name="PrimAVPQ"
    data-long-name="Prim's with Priority Queue Algorithm Visualization"
    data-frame-src="../../../AV/Graph/PrimAVPQ.html?selfLoggingEnabled=false&amp;localMode=true&amp;module=MCST&amp;JOP-lang=en&amp;JXOP-code=java_generic"
    data-frame-width="950"
    data-frame-height="650"
    data-external="false"
    data-points="0"
    data-required="False"
    data-showhide="none"
    data-threshold="1.0"
    data-type="ss">
  
  <div class="center">
    <div id="PrimAVPQ_iframe"></div>
  </div>
</div>
<p>Prim's algorithm is an example of a greedy
algorithm.
At each step in the <code class="docutils literal"><span class="pre">for</span></code> loop, we select the least-cost edge that
connects some marked vertex to some unmarked vertex.
The algorithm does not otherwise check that the MCST really should
include this least-cost edge.
This leads to an important question:
Does Prim's algorithm work correctly?
Clearly it generates a spanning tree (because each pass through the
<code class="docutils literal"><span class="pre">for</span></code> loop adds one edge and one unmarked vertex to the spanning tree
until all vertices have been added), but does this tree have minimum
cost?</p>
<blockquote>
<div><p><strong>Theorem:</strong> Prim's algorithm produces a minimum-cost spanning tree.</p>
<p><strong>Proof:</strong> We will use a proof by contradiction.
Let <span class="math">\(\mathbf{G} = (\mathbf{V}, \mathbf{E})\)</span> be a graph for which
Prim's algorithm does <em>not</em> generate an MCST.
Define an ordering on the vertices according to the order in which
they were added by Prim's algorithm to the MCST:
<span class="math">\(v_0, v_1, ..., v_{n-1}\)</span>.
Let edge <span class="math">\(e_i\)</span> connect <span class="math">\((v_x, v_i)\)</span> for
some <span class="math">\(x &lt; i\)</span> and <span class="math">\(i \leq 1\)</span>.
Let <span class="math">\(e_j\)</span> be the lowest numbered (first) edge added
by Prim's algorithm such that the set of edges selected so
far <em>cannot</em> be extended to form an MCST for <span class="math">\(\mathbf{G}\)</span>.
In other words, <span class="math">\(e_j\)</span> is the first edge where Prim's algorithm
&quot;went wrong.&quot;
Let <span class="math">\(\mathbf{T}\)</span> be the &quot;true&quot; MCST.
Call <span class="math">\(\v_p (p&lt;j)\)</span> the vertex connected by edge
<span class="math">\(e_j\)</span>, that is, <span class="math">\(e_j = (v_p, v_j)\)</span>.</p>
<p>Because <span class="math">\(\mathbf{T}\)</span> is a tree, there exists some path in
<span class="math">\(\mathbf{T}\)</span> connecting <span class="math">\(v_p\)</span> and <span class="math">\(v_j\)</span>.
There must be some edge <span class="math">\(e'\)</span> in this path connecting vertices
<span class="math">\(v_u\)</span> and <span class="math">\(v_w\)</span>, with <span class="math">\(u &lt; j\)</span> and <span class="math">\(w \geq j\)</span>.
Because <span class="math">\(e_j\)</span> is not part of <span class="math">\(\mathbf{T}\)</span>, adding edge
<span class="math">\(e_j\)</span> to <span class="math">\(\mathbf{T}\)</span> forms a cycle.
Edge <span class="math">\(e'\)</span> must be of lower cost than
edge <span class="math">\(e_j\)</span>, because Prim's algorithm did not generate an MCST.
This situation is illustrated in Figure <a href="MCST.html#primproof">16.6.2</a>.
However, Prim's algorithm would have selected the least-cost edge
available.
It would have selected <span class="math">\(e'\)</span>, not <span class="math">\(e_j\)</span>.
Thus, it is a contradiction that Prim's algorithm would have selected
the wrong edge, and thus, Prim's algorithm must be correct. BOX HERE</p>
</div></blockquote>
<div class="figure align-center" id="primproof" style="width: 90%">
<a class="reference internal image-reference" href="_images/PrimMST.png"><img alt="Prim's MCST algorithm proof" src="_images/PrimMST.png" style="width: 400px;" /></a>
<p class="caption" style="text-align: justify"> Figure 16.6.2: Prim's MCST algorithm proof.
The left oval contains that portion of the graph where Prim's MCST
and the &quot;true&quot; MCST <span class="math">\(\mathbf{T}\)</span> agree.
The right oval contains the rest of the graph.
The two portions of the graph are connected by (at least) edges
<span class="math">\(e_j\)</span> (selected by Prim's algorithm to be in the MCST) and
<span class="math">\(e'\)</span> (the &quot;correct&quot; edge to be placed in the MCST).
Note that the path from <span class="math">\(v_w\)</span> to <span class="math">\(v_j\)</span> cannot
include any marked vertex <span class="math">\(v_i, i \leq j\)</span>, because to do so
would form a cycle.</p>
</div>
<div
    id="PrimAVPE"
    class="embedContainer"
    data-exer-name="PrimAVPE"
    data-long-name="Prim's Algorithm Proficiency Exercise"
    data-frame-src="../../../AV/Graph/PrimAVPE.html?selfLoggingEnabled=false&amp;localMode=true&amp;module=MCST&amp;JOP-lang=en&amp;JXOP-code=java_generic"
    data-frame-width="950"
    data-frame-height="650"
    data-external="false"
    data-points="2.0"
    data-required="True"
    data-showhide="show"
    data-threshold="0.9"
    data-type="pe">
  
  <div class="center">
    <div id="PrimAVPE_iframe"></div>
  </div>
</div>
<script type="text/javascript" src="../../../AV/Graph/MCSTCON.js"></script>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      <p><span class="email_div" style="display:inline;"><a id="contact_us" class="contact" style="float:left;color:blue;" rel="nofollow" href="mailto:">Contact Us |</a><a style="float:left;color:blue;" rel="nofollow" href="../../../lib/Privacy.html" target="_blank">| Privacy |</a> <a style="float:left;color:blue;" rel="nofollow" href="../../../lib/license.html" target="_blank">| License</a></span>&#160;&#160;
      
        «&#160;&#160;<a id="prevmod1" href="GraphShortest.html">16.5. Shortest-Paths Problems</a>
        &#160;&#160;::&#160;&#160;
        <a  class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a  id="nextmod1" href="Kruskal.html">16.7. Kruskal's Algorithm</a>&#160;&#160;»

</p>
      </div>
      <img style="float:right;" src="_static/nsf1.gif" height="62" width="62" alt="nsf"/>


    <div class="footer">
      <p>
        <span class="email_div" style="display:inline;">
          <a id="contact_us" class="contact" style="float:left;color:blue;" rel="nofollow" href="mailto:">Contact Us |</a>
          <a id="bugreport-link" style="float:left;color:blue;" class="bugreport-link" href="#">| Report a bug</a>
        </span>
      </p>
        &copy; Copyright 2016 by OpenDSA Project Contributors and distributed under an MIT license.
      Last updated on Nov 27, 2017.
      Created using <a target="_blank" href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.
    </div>
    
<div id="bugreport-box" class="bugreport-popup ">
  <a href="#" class="close"><img src="_static/Images/close_pop.png" class="btn_close" title="Close Window" alt="Close Window" /></a>
  <form method="post" class="report" action="https://#">
    <fieldset class="textbox">
      <div id="bug_error" class="error"></div>
      <label>
        <span>Summary*:</span>
        <input type="text" id="b_title" placeholder="Summary" />
      </label>

      <label class="os">
        <span>Operating system*:</span>
        <select id="b_os">
          <option value="windows">Windows</option>
          <option value="macos">Mac OS</option>
          <option value="linux">Linux</option>
          <option value="ios">iOS</option>
          <option value="android">Android</option>
          <option value="other">Other</option>
        </select>
      </label>

      <label class="browser">
        <span>Browser*:</span>
        <select id="b_browser">
          <option value="chrome">Chrome</option>
          <option value="safari">Safari</option>
          <option value="internetexplorer">Internet Explorer</option>
          <option value="opera">Opera</option>
          <option value="other">Other</option>
        </select>
      </label>

      <label class="description">
        <span>Description*:</span><br>
        <textarea id="b_description" rows="5" cols="25" placeholder="***BUG** Please enter: (1) a consice description of the problem. (2) steps to reproduce bug. (3) the version of your browser and operating system."></textarea>
      </label>

      <label class="screenshot">
        <span>Attach a screenshot (optional):</span>
        <input type="file" id="b_screenshot" accept="image/*" placeholder="Attach a screenshot (optional)">
      </label>

      <p>
        <input type="submit" id="bug-submit-button" value="Submit &rarr;"/>
      </p>
    </fieldset>
  </form>
</div>

  </body>
</html>