{"connections": {"con-106": {"to": "k-path", "from": "uses"}, "con-101": {"to": "example", "from": "dynamic allocation"}, "con-100": {"to": "digraph", "from": "abbreviation"}, "con-263": {"to": "example", "from": "trie"}, "con-29": {"to": "operations", "from": "AVL Tree"}, "con-28": {"to": "double rotation", "from": "operations"}, "con-25": {"to": "solvedby", "from": "all-pairs shortest paths problem"}, "con-24": {"to": "lower bound", "from": "keyconcept"}, "con-27": {"to": "operations", "from": "AVL Tree"}, "con-26": {"to": "Floyd's algorithm", "from": "solvedby"}, "con-21": {"to": "keyconcept", "from": "algorithm analysis"}, "con-20": {"to": "growth rate", "from": "keyconcept"}, "con-23": {"to": "keyconcept", "from": "algorithm analysis"}, "con-22": {"to": "upper bound", "from": "keyconcept"}, "con-123": {"to": "types", "from": "graph"}, "con-122": {"to": "shortest paths", "from": "problems"}, "con-121": {"to": "problems", "from": "graph"}, "con-120": {"to": "topological sort", "from": "problems"}, "con-127": {"to": "types", "from": "graph"}, "con-126": {"to": "sparse graph", "from": "types"}, "con-125": {"to": "types", "from": "graph"}, "con-124": {"to": "dense", "from": "types"}, "con-242": {"to": "transpose", "from": "heuristic"}, "con-243": {"to": "reversedby", "from": "serialization"}, "con-129": {"to": "types", "from": "graph"}, "con-128": {"to": "directed graph", "from": "types"}, "con-246": {"to": "sequential tree representation", "from": "example"}, "con-247": {"to": "synonym", "from": "singly linked list"}, "con-244": {"to": "deserialization", "from": "reversedby"}, "con-245": {"to": "example", "from": "serialization"}, "con-228": {"to": "Binary Search Tree", "from": "example"}, "con-229": {"to": "example", "from": "search tree"}, "con-130": {"to": "acyclic graph", "from": "types"}, "con-131": {"to": "types", "from": "graph"}, "con-132": {"to": "labeled graph", "from": "types"}, "con-18": {"to": "program", "from": "implementedby"}, "con-19": {"to": "keyconcept", "from": "algorithm analysis"}, "con-133": {"to": "types", "from": "graph"}, "con-10": {"to": "cycles <cycle>", "from": "hasno"}, "con-11": {"to": "synonym", "from": "aggregate type"}, "con-12": {"to": "composite type", "from": "synonym"}, "con-13": {"to": "member", "from": "aggregate type"}, "con-14": {"to": "has", "from": "member"}, "con-15": {"to": "solves", "from": "algorithm"}, "con-16": {"to": "problem", "from": "solves"}, "con-17": {"to": "implementedby", "from": "algorithm"}, "con-90": {"to": "flyweight", "from": "example"}, "con-91": {"to": "example", "from": "design pattern"}, "con-92": {"to": "strategy", "from": "example"}, "con-93": {"to": "example", "from": "design pattern"}, "con-94": {"to": "visitor", "from": "example"}, "con-95": {"to": "abbreviation", "from": "directed acyclic graph"}, "con-96": {"to": "DAG", "from": "abbreviation"}, "con-97": {"to": "types", "from": "directed graph"}, "con-98": {"to": "directed acyclic graph", "from": "types"}, "con-99": {"to": "abbreviation", "from": "directed graph"}, "con-137": {"to": "types", "from": "graph"}, "con-135": {"to": "types", "from": "graph"}, "con-138": {"to": "unweighted graph", "from": "types"}, "con-239": {"to": "heuristic", "from": "self-organizing list"}, "con-139": {"to": "type", "from": "growth rate"}, "con-237": {"to": "example", "from": "search trie"}, "con-104": {"to": "Floyd's algorithm", "from": "example"}, "con-134": {"to": "undirected graph", "from": "types"}, "con-234": {"to": "search trie", "from": "example"}, "con-233": {"to": "example", "from": "search tree"}, "con-232": {"to": "B-tree", "from": "example"}, "con-231": {"to": "example", "from": "search tree"}, "con-230": {"to": "2-3 tree", "from": "example"}, "con-238": {"to": "binary trie", "from": "example"}, "con-136": {"to": "weighted graph", "from": "types"}, "con-240": {"to": "move-to-front", "from": "heuristic"}, "con-107": {"to": "contains", "from": "graph"}, "con-109": {"to": "contains", "from": "graph"}, "con-108": {"to": "edges <edge>", "from": "contains"}, "con-89": {"to": "example", "from": "design pattern"}, "con-88": {"to": "Composite design pattern", "from": "example"}, "con-87": {"to": "example", "from": "design pattern"}, "con-86": {"to": "depth-first search tree", "from": "generates"}, "con-85": {"to": "generates", "from": "depth-first search"}, "con-84": {"to": "DFS", "from": "abbreviation"}, "con-83": {"to": "abbreviation", "from": "depth-first search"}, "con-82": {"to": "simple type", "from": "type"}, "con-81": {"to": "type", "from": "data type"}, "con-80": {"to": "aggregate type", "from": "type"}, "con-185": {"to": "uses", "from": "multi-dimensional search structure"}, "con-184": {"to": "mod", "from": "abbreviation"}, "con-187": {"to": "synonym", "from": "multilist"}, "con-186": {"to": "multi-dimensional search key", "from": "uses"}, "con-181": {"to": "algorithms", "from": "minimal-cost spanning tree"}, "con-180": {"to": "Kruskal's algorithm", "from": "algorithms"}, "con-183": {"to": "abbreviation", "from": "modulus"}, "con-182": {"to": "Prim's algorithm", "from": "algorithms"}, "con-224": {"to": "enqueue", "from": "operations"}, "con-225": {"to": "composedof", "from": "runtime stack"}, "con-226": {"to": "activation record", "from": "composedof"}, "con-227": {"to": "example", "from": "search tree"}, "con-189": {"to": "is", "from": "neighbor"}, "con-188": {"to": "bag", "from": "synonym"}, "con-222": {"to": "dequeue", "from": "operations"}, "con-223": {"to": "operations", "from": "queue"}, "con-72": {"to": "open addressing", "from": "synonym"}, "con-73": {"to": "performs", "from": "collision resolution policy"}, "con-70": {"to": "buffering", "from": "synonym"}, "con-71": {"to": "synonym", "from": "closed hash system"}, "con-76": {"to": "serialization", "from": "concept"}, "con-77": {"to": "implementedby", "from": "data type"}, "con-74": {"to": "collision resolution", "from": "performs"}, "con-75": {"to": "concept", "from": "data structure"}, "con-78": {"to": "abstract data type", "from": "implementedby"}, "con-79": {"to": "type", "from": "data type"}, "con-248": {"to": "one-way list", "from": "synonym"}, "con-249": {"to": "example", "from": "spatial data structure"}, "con-236": {"to": "alphabet trie", "from": "example"}, "con-235": {"to": "example", "from": "search trie"}, "con-118": {"to": "traversal", "from": "problems"}, "con-119": {"to": "problems", "from": "graph"}, "con-112": {"to": "adjacency matrix", "from": "implementedby"}, "con-113": {"to": "implementedby", "from": "graph"}, "con-110": {"to": "vertices <vertex>", "from": "contains"}, "con-111": {"to": "implementedby", "from": "graph"}, "con-116": {"to": "minimal-cost spanning tree", "from": "problems"}, "con-117": {"to": "problems", "from": "graph"}, "con-114": {"to": "adjacency list", "from": "implementedby"}, "con-115": {"to": "problems", "from": "graph"}, "con-192": {"to": "graph", "from": "context"}, "con-193": {"to": "linkedto", "from": "node"}, "con-190": {"to": "adjacent", "from": "is"}, "con-191": {"to": "context", "from": "neighbor"}, "con-196": {"to": "dynamic allocation", "from": "createdby"}, "con-197": {"to": "property", "from": "node"}, "con-194": {"to": "neighbor", "from": "linkedto"}, "con-195": {"to": "createdby", "from": "node"}, "con-211": {"to": "isa", "from": "Prim's algorithm"}, "con-210": {"to": "cohesion", "from": "keyconcept"}, "con-198": {"to": "depth", "from": "property"}, "con-199": {"to": "is", "from": "NP-Complete"}, "con-215": {"to": "example", "from": "proof"}, "con-214": {"to": "lower bounds proof", "from": "example"}, "con-217": {"to": "type", "from": "proof"}, "con-216": {"to": "NP-Completeness proof", "from": "example"}, "con-61": {"to": "uses", "from": "bucket hashing"}, "con-60": {"to": "algorithm", "from": "typeof"}, "con-63": {"to": "uses", "from": "buffer"}, "con-62": {"to": "bucket", "from": "uses"}, "con-65": {"to": "composedof", "from": "buffer pool"}, "con-64": {"to": "dirty bit", "from": "uses"}, "con-67": {"to": "operation", "from": "buffer pool"}, "con-66": {"to": "buffer", "from": "composedof"}, "con-69": {"to": "synonym", "from": "caching"}, "con-68": {"to": "flush", "from": "operation"}, "con-103": {"to": "example", "from": "dynamic programming"}, "con-241": {"to": "heuristic", "from": "self-organizing list"}, "con-212": {"to": "greedy algorithm", "from": "isa"}, "con-206": {"to": "NP", "from": "abbreviation"}, "con-207": {"to": "operation", "from": "non-deterministic polynomial time algorithm"}, "con-204": {"to": "clique", "from": "exampleproblem"}, "con-205": {"to": "abbreviation", "from": "non-deterministic polynomial time algorithm"}, "con-202": {"to": "NP-hard", "from": "is"}, "con-203": {"to": "exampleproblem", "from": "NP-Complete"}, "con-200": {"to": "NP", "from": "is"}, "con-201": {"to": "is", "from": "NP-Complete"}, "con-102": {"to": "node", "from": "example"}, "con-208": {"to": "non-deterministic choice", "from": "operation"}, "con-209": {"to": "keyconcept", "from": "object-oriented programming paradigm"}, "con-169": {"to": "exampleuse", "from": "locality of reference"}, "con-168": {"to": "UNION/FIND", "from": "uses"}, "con-167": {"to": "uses", "from": "Kruskal's algorithm"}, "con-166": {"to": "image space decomposition", "from": "type"}, "con-165": {"to": "type", "from": "key space decomposition"}, "con-164": {"to": "object space decomposition", "from": "type"}, "con-163": {"to": "type", "from": "key space decomposition"}, "con-162": {"to": "key", "from": "uses"}, "con-161": {"to": "uses", "from": "key sort"}, "con-160": {"to": "key space", "from": "has"}, "con-58": {"to": "BFS", "from": "abbreviation"}, "con-59": {"to": "typeof", "from": "bubble sort"}, "con-54": {"to": "bintree", "from": "example"}, "con-55": {"to": "uses", "from": "bintree"}, "con-56": {"to": "flyweight", "from": "uses"}, "con-57": {"to": "abbreviation", "from": "breadth-first search"}, "con-50": {"to": "binary trie", "from": "example"}, "con-51": {"to": "example", "from": "binary tree"}, "con-52": {"to": "complete binary tree", "from": "example"}, "con-53": {"to": "example", "from": "binary tree"}, "con-259": {"to": "operations", "from": "stack"}, "con-258": {"to": "push", "from": "operations"}, "con-273": {"to": "synonym", "from": "vector"}, "con-272": {"to": "fixed-length coding", "from": "contrastto"}, "con-271": {"to": "contrastto", "from": "variable-length coding"}, "con-270": {"to": "Huffman codes", "from": "example"}, "con-277": {"to": "synonym", "from": "vertex"}, "con-276": {"to": "dynamic array", "from": "synonym"}, "con-275": {"to": "synonym", "from": "vector"}, "con-274": {"to": "sequence", "from": "synonym"}, "con-278": {"to": "node", "from": "synonym"}, "con-178": {"to": "buddy method", "from": "example"}, "con-179": {"to": "algorithms", "from": "minimal-cost spanning tree"}, "con-174": {"to": "sorting lower bound", "from": "example"}, "con-175": {"to": "example", "from": "lower bounds proof"}, "con-176": {"to": "search lower bound", "from": "example"}, "con-177": {"to": "example", "from": "memory manager"}, "con-170": {"to": "80/20 rule", "from": "exampleuse"}, "con-171": {"to": "example", "from": "lower bounds proof"}, "con-172": {"to": "adversary argument", "from": "example"}, "con-173": {"to": "example", "from": "lower bounds proof"}, "con-49": {"to": "example", "from": "binary tree"}, "con-48": {"to": "binary search tree", "from": "example"}, "con-43": {"to": "abbreviated", "from": "binary search tree"}, "con-42": {"to": "binary search tree property", "from": "has"}, "con-41": {"to": "has", "from": "binary search tree"}, "con-40": {"to": "AVL tree", "from": "example"}, "con-47": {"to": "example", "from": "binary tree"}, "con-46": {"to": "splay tree", "from": "example"}, "con-45": {"to": "example", "from": "binary search tree"}, "con-44": {"to": "BST", "from": "abbreviated"}, "con-253": {"to": "example", "from": "spatial data structure"}, "con-213": {"to": "example", "from": "proof"}, "con-260": {"to": "pop", "from": "operations"}, "con-219": {"to": "type", "from": "proof"}, "con-262": {"to": "clique", "from": "example"}, "con-220": {"to": "proof by induction", "from": "type"}, "con-264": {"to": "alphebet trie", "from": "example"}, "con-265": {"to": "example", "from": "trie"}, "con-266": {"to": "binary trie", "from": "example"}, "con-218": {"to": "proof by contradiction", "from": "type"}, "con-268": {"to": "search trie", "from": "example"}, "con-269": {"to": "example", "from": "variable-length coding"}, "con-149": {"to": "type", "from": "hash system"}, "con-148": {"to": "closed hash system", "from": "type"}, "con-141": {"to": "type", "from": "growth rate"}, "con-140": {"to": "lower bound", "from": "type"}, "con-143": {"to": "uses", "from": "hash system"}, "con-142": {"to": "upper bound", "from": "type"}, "con-145": {"to": "type", "from": "hash system"}, "con-144": {"to": "hash function", "from": "uses"}, "con-147": {"to": "type", "from": "hash system"}, "con-146": {"to": "bucket hashing", "from": "type"}, "con-221": {"to": "operations", "from": "queue"}, "con-261": {"to": "example", "from": "subgraph"}, "con-267": {"to": "example", "from": "trie"}, "con-252": {"to": "kd tree", "from": "example"}, "con-38": {"to": "multilist", "from": "synonym"}, "con-39": {"to": "example", "from": "binary search tree"}, "con-36": {"to": "B$^*$-tree", "from": "variant"}, "con-37": {"to": "synonym", "from": "bag"}, "con-34": {"to": "B$^+$-tree", "from": "variant"}, "con-35": {"to": "variant", "from": "B-tree"}, "con-32": {"to": "2-3 tree graph", "from": "variant"}, "con-33": {"to": "variant", "from": "B-tree"}, "con-30": {"to": "single rotation", "from": "operations"}, "con-31": {"to": "variant", "from": "B-tree"}, "con-156": {"to": "collision resolution policy", "from": "has"}, "con-157": {"to": "uses", "from": "kd tree"}, "con-154": {"to": "hash function", "from": "has"}, "con-155": {"to": "has", "from": "hashing"}, "con-152": {"to": "hash table", "from": "has"}, "con-153": {"to": "has", "from": "hashing"}, "con-150": {"to": "open hash system", "from": "type"}, "con-151": {"to": "has", "from": "hashing"}, "con-255": {"to": "operation", "from": "Splay Tree"}, "con-254": {"to": "PR quadtree", "from": "example"}, "con-257": {"to": "operations", "from": "stack"}, "con-256": {"to": "splaying", "from": "operation"}, "con-251": {"to": "example", "from": "spatial data structure"}, "con-250": {"to": "bintree", "from": "example"}, "con-158": {"to": "discriminator", "from": "uses"}, "con-159": {"to": "has", "from": "key"}, "con-105": {"to": "uses", "from": "Floyd's algorithm"}, "con-8": {"to": "directed acyclic graph", "from": "types"}, "con-9": {"to": "hasno", "from": "acyclic graph"}, "con-6": {"to": "local variable", "from": "stores"}, "con-7": {"to": "types", "from": "acyclic graph"}, "con-4": {"to": "ADT", "from": "abbreviation"}, "con-5": {"to": "stores", "from": "activation record"}, "con-2": {"to": "binary search tree property", "from": "has"}, "con-3": {"to": "abbreviation", "from": "abstract data type"}, "con-1": {"to": "has", "from": "2-3 tree"}}, "linking_phrase": {"operations": " operations\n", "implementedby": " implemented by\n", "concept": " concept", "stores": " stores", "linkedto": " linked to", "is": " is\n", "abbreviated": " abbreviated\n", "createdby": " created by\n", "abbreviation": " abbreviation\n", "operation": " operation\n", "reversedby": " reversed by", "heuristic": " heuristic\n", "exampleproblem": " example problem\n", "contains": " contains\n", "problems": " problems\n", "member": " member\n", "performs": " performs", "exampleuse": " example use", "hasno": " has no\n", "keyconcept": " key concept\n", "has": " has\n", "type": " type\n", "generates": " generates\n", "composedof": " composed of", "variant": " variant\n", "uses": " uses", "solvedby": " solved by", "types": " types\n", "synonym": " synonym\n", "solves": " solves", "contrastto": " contrast to\n", "algorithms": " algorithms\n", "typeof": " type of", "context": " context\n", "isa": " is a", "property": " property\n", "example": " example\n"}, "concepts": {"shortest paths": "", "hash system": "<dd>The implementation for search based on hash lookup in a\n<a class=\"reference internal\" href=\"#term-hash-table\"><em class=\"xref std std-term ODSAterm\">hash table</em></a>.\nThe <a class=\"reference internal\" href=\"#term-search-key\"><em class=\"xref std std-term ODSAterm\">search key</em></a> is processed by a\n<a class=\"reference internal\" href=\"#term-hash-function\"><em class=\"xref std std-term ODSAterm\">hash function</em></a>, which returns a position in a\n<a class=\"reference internal\" href=\"#term-hash-table\"><em class=\"xref std std-term ODSAterm\">hash table</em></a>, which hopefully is the correct position in\nwhich to find the record corresponding to the search key.</dd>", "lower bound": "<dd>In <a class=\"reference internal\" href=\"#term-algorithm-analysis\"><em class=\"xref std std-term ODSAterm\">algorithm analysis</em></a>, a <a class=\"reference internal\" href=\"#term-growth-rate\"><em class=\"xref std std-term ODSAterm\">growth rate</em></a> that is\nalways less than or equal to the that of the\n<a class=\"reference internal\" href=\"#term-algorithm\"><em class=\"xref std std-term ODSAterm\">algorithm</em></a> in question.\nIn practice, this is the fastest-growing function that we know\ngrows no faster than all but a constant number of inputs.\nIt could be a gross under-estimate of the truth.\nSince the lower bound for the algorithm can be very different\nfor different situations (such as the <a class=\"reference internal\" href=\"#term-best-case\"><em class=\"xref std std-term ODSAterm\">best case</em></a> or\n<a class=\"reference internal\" href=\"#term-worst-case\"><em class=\"xref std std-term ODSAterm\">worst case</em></a>), we typically have to specify which\nsituation we are referring to.</dd>", "Prim's algorithm": "<dd>A <a class=\"reference internal\" href=\"#term-greedy-algorithm\"><em class=\"xref std std-term ODSAterm\">greedy algorithm</em></a> for computing the <a class=\"reference internal\" href=\"#term-mcst\"><em class=\"xref std std-term ODSAterm\">MCST</em></a> of a\n<a class=\"reference internal\" href=\"#term-graph\"><em class=\"xref std std-term ODSAterm\">graph</em></a>.\nIt is nearly identical to <a class=\"reference internal\" href=\"#term-dijkstra-s-algorithm\"><em class=\"xref std std-term ODSAterm\">Dijkstra's algorithm</em></a> for\nsolving the <a class=\"reference internal\" href=\"#term-single-source-shortest-paths-problem\"><em class=\"xref std std-term ODSAterm\">single-source shortest paths problem</em></a>,\nwith the only difference being the calculation done to update\nthe best-known distance.</dd>", "adversary argument": "<dd>A type of <a class=\"reference internal\" href=\"#term-lower-bounds-proof\"><em class=\"xref std std-term ODSAterm\">lower bounds proof</em></a> for a problem where a\n(fictional) &quot;adversary&quot; is assumed to control access to an\nalgorithm's input, and which yields information about that input\nin such a way\nthat will drive the cost for any proposed algorithm to solve the\nproblem as high as possible.\nSo long as the adversary never gives an answer that conflicts\nwith any previous answer, it is permitted to do whatever\nnecessary to make the algorithm require as much cost as\npossible.</dd>", "visitor": "<dd>A <a class=\"reference internal\" href=\"#term-design-pattern\"><em class=\"xref std std-term ODSAterm\">design pattern</em></a> where a <a class=\"reference internal\" href=\"#term-traversal\"><em class=\"xref std std-term ODSAterm\">traversal</em></a> process is\ngiven a function (known as the visitor) that is applied to every\nobject in the collection being traversed.\nFor example, a generic tree or graph traversal might be\ndesigned such that it takes a function parameter,\nwhere that function is applied to each node.</dd>", "directed graph": "<dd>A <a class=\"reference internal\" href=\"#term-graph\"><em class=\"xref std std-term ODSAterm\">graph</em></a> whose <a class=\"reference internal\" href=\"#term-edge\"><em class=\"xref std std-term ODSAterm\">edges</em></a> each are directed\nfrom one of its defining <a class=\"reference internal\" href=\"#term-vertex\"><em class=\"xref std std-term ODSAterm\">vertices</em></a> to the\nother.</dd>", "proof by induction": "<dd>A mathematical proof technique similar to <a class=\"reference internal\" href=\"#term-recursion\"><em class=\"xref std std-term ODSAterm\">recursion</em></a>.\nIt is used to prove a parameterized theorem $S(n)$, that is,\na theorem where there is a <a class=\"reference internal\" href=\"#term-induction-variable\"><em class=\"xref std std-term ODSAterm\">induction variable</em></a> involved\n(such as the sum of the numbers from 1 to $n$).\nOne first proves that the theorem holds true for a\n<a class=\"reference internal\" href=\"#term-base-case\"><em class=\"xref std std-term ODSAterm\">base case</em></a>, then one proves the implication that\nwhenever $S(n)$ is true then $S(n+1)$ is also true.\nAnother variation is <a class=\"reference internal\" href=\"#term-strong-induction\"><em class=\"xref std std-term ODSAterm\">strong induction</em></a>.</dd>", "object-oriented programming paradigm": "<dd>An approach to problem-solving where all computations are\ncarried out using <a class=\"reference internal\" href=\"#term-object\"><em class=\"xref std std-term ODSAterm\">objects</em></a>.</dd>", "proof by contradiction": "<dd>A mathematical proof technique that proves a theorem by first\nassuming that the theorem is false, and then uses a chain of\nreasoning to reach a logical contradiction.\nSince when the theorem is false a logical contradiction arises,\nthe conclusion is that the theorem must be true.</dd>", "collision resolution": "<dd>The outcome of a <a class=\"reference internal\" href=\"#term-collision-resolution-policy\"><em class=\"xref std std-term ODSAterm\">collision resolution policy</em></a>.</dd>", "breadth-first search": "<dd>A <a class=\"reference internal\" href=\"#term-graph\"><em class=\"xref std std-term ODSAterm\">graph</em></a> <a class=\"reference internal\" href=\"#term-traversal\"><em class=\"xref std std-term ODSAterm\">traversal</em></a> algorithm.\nAs the name implies, all immediate <a class=\"reference internal\" href=\"#term-neighbor\"><em class=\"xref std std-term ODSAterm\">neighbors</em></a>\nfor a <a class=\"reference internal\" href=\"#term-node\"><em class=\"xref std std-term ODSAterm\">node</em></a> are <a class=\"reference internal\" href=\"#term-visit\"><em class=\"xref std std-term ODSAterm\">visited</em></a> before any\nmore-distant nodes are visited.\nBFS is driven by a <a class=\"reference internal\" href=\"#term-queue\"><em class=\"xref std std-term ODSAterm\">queue</em></a>.\nA start vertex is placed on the queue.\nThen, until the queue is empty, a node is taken off the\nqueue, visited, and and then any <a class=\"reference internal\" href=\"#term-unvisited\"><em class=\"xref std std-term ODSAterm\">unvisited</em></a> neighbors are\nplaced onto the queue.</dd>", "runtime stack": "<dd>The place where an <a class=\"reference internal\" href=\"#term-activation-record\"><em class=\"xref std std-term ODSAterm\">activation record</em></a> is stored when a\nsubroutine is called during a program's runtime.</dd>", "graph": "<dd>A <a class=\"reference internal\" href=\"#term-graph\"><em class=\"xref std std-term ODSAterm\">graph</em></a> <span class=\"math\">\\(\\mathbf{G} = (\\mathbf{V}, \\mathbf{E})\\)</span>\nconsists of a set of <a class=\"reference internal\" href=\"#term-vertex\"><em class=\"xref std std-term ODSAterm\">vertices</em></a>\n<span class=\"math\">\\(\\mathbf{V}\\)</span> and a set of <a class=\"reference internal\" href=\"#term-edge\"><em class=\"xref std std-term ODSAterm\">edges</em></a>\n<span class=\"math\">\\(\\mathbf{E}\\)</span>, such that each edge in <span class=\"math\">\\(\\mathbf{E}\\)</span> is\na connection between a pair of vertices in <span class=\"math\">\\(\\mathbf{V}\\)</span>.</dd>", "search tree": "<dd>A <a class=\"reference internal\" href=\"#term-577\"><em class=\"xref std std-term ODSAterm\">tree</em></a> data structure that makes search by <a class=\"reference internal\" href=\"#term-key\"><em class=\"xref std std-term ODSAterm\">key</em></a>\nvalue more efficient.\nA type of <a class=\"reference internal\" href=\"#term-container\"><em class=\"xref std std-term ODSAterm\">container</em></a>, it is common to implement an\n<a class=\"reference internal\" href=\"#term-indexing\"><em class=\"xref std std-term ODSAterm\">index</em></a> using a search tree.\nA good search tree implementation will guarentee that insertion,\ndeletion, and search operations are all <span class=\"math\">\\(\\Theta(\\log n)\\)</span>.</dd>", "NP-Completeness proof": "<dd>A type of <a class=\"reference internal\" href=\"#term-reduction\"><em class=\"xref std std-term ODSAterm\">reduction</em></a> used to demonstrate that a\nparticular <a class=\"reference internal\" href=\"#term-problem\"><em class=\"xref std std-term ODSAterm\">problem</em></a> is <a class=\"reference internal\" href=\"#term-np-complete\"><em class=\"xref std std-term ODSAterm\">NP-complete</em></a>.\nSpecifically, an NP-Completeness proof must first show that the\nproblem is in class <a class=\"reference internal\" href=\"#term-np\"><em class=\"xref std std-term ODSAterm\">NP</em></a>, and then show (by using a\nreduction to another NP-Complete problem) that the problem is\n<a class=\"reference internal\" href=\"#term-np-hard\"><em class=\"xref std std-term ODSAterm\">NP-hard</em></a>.</dd>", "deserialization": "<dd>The process of returning a <a class=\"reference internal\" href=\"#term-serialization\"><em class=\"xref std std-term ODSAterm\">serialized</em></a>\nrepresentation for a data structure back to its original\nin-memory form.</dd>", "program": "<dd>An instance, or concrete representation, of an algorithm in some\nprogramming language.</dd>", "dequeue": "<dd>A specialized term used to indicate removing an element from a queue.</dd>", "one-way list": "<dd>A synonym for a <a class=\"reference internal\" href=\"#term-singly-linked-list\"><em class=\"xref std std-term ODSAterm\">singly linked list</em></a>.</dd>", "has": "", "data structure": "<dd>The implementation for an <a class=\"reference internal\" href=\"#term-adt\"><em class=\"xref std std-term ODSAterm\">ADT</em></a>.</dd>", "Floyd's algorithm": "<dd>An algorithm to solve the\n<a class=\"reference internal\" href=\"#term-all-pairs-shortest-paths-problem\"><em class=\"xref std std-term ODSAterm\">all-pairs shortest paths problem</em></a>.\nIt uses the <a class=\"reference internal\" href=\"#term-dynamic-programming\"><em class=\"xref std std-term ODSAterm\">dynamic programming</em></a> algorithmic technique,\nand runs in <span class=\"math\">\\(\\Theta(n^3)\\)</span> time.\nAs with any <a class=\"reference internal\" href=\"#term-dynamic-programming\"><em class=\"xref std std-term ODSAterm\">dynamic programming</em></a> algorithm,\nthe key issue is to avoid duplicating work by using proper\nbookkeeping on the algorithm's progress through the solution space.\nThe basic idea is to first find all the direct edge costs, then\nimproving those costs by allowing paths through <a class=\"reference internal\" href=\"#term-vertex\"><em class=\"xref std std-term ODSAterm\">vertex</em></a>\n0, then the cheapest paths involving paths going through\nvertices 0 and 1, and so on.</dd>", "complete binary tree": "<dd>A binary tree where the nodes are filled in row by row, with the\nbottom row filled in left to right.\nDue to this requirement, there is only one tree of <span class=\"math\">\\(n\\)</span>\nnodes for any value of <span class=\"math\">\\(n\\)</span>.\nSince storing the records in an array in row order leads to a\nsimple mapping from a node's position in the array to its\n<a class=\"reference internal\" href=\"#term-parent\"><em class=\"xref std std-term ODSAterm\">parent</em></a>, <a class=\"reference internal\" href=\"#term-sibling\"><em class=\"xref std std-term ODSAterm\">siblings</em></a>, and\n<a class=\"reference internal\" href=\"#term-child\"><em class=\"xref std std-term ODSAterm\">children</em></a>, the array representation is most\ncommonly used to implement the complete binary tree.\nThe <a class=\"reference internal\" href=\"#term-heap\"><em class=\"xref std std-term ODSAterm\">heap</em></a> data structure is a complete binary tree with\npartial ordering constraints on the node values.</dd>", "Binary Search Tree": "", "BFS": "<dd>Abbreviation for <a class=\"reference internal\" href=\"#term-breadth-first-search\"><em class=\"xref std std-term ODSAterm\">breadth-first search</em></a>.</dd>", "enqueue": "<dd>A specialized term used to indicate inserting an element onto a queue.</dd>", "buffering": "<dd>A synonym for <a class=\"reference internal\" href=\"#term-caching\"><em class=\"xref std std-term ODSAterm\">caching</em></a>.\nMore specifically, it refers to an arrangement where all\naccesses to data (such as on a\n<a class=\"reference internal\" href=\"#term-peripheral-storage\"><em class=\"xref std std-term ODSAterm\">peripheral storage</em></a> device) must\nbe done in multiples of some minimum unit of storage.\nOn a <a class=\"reference internal\" href=\"#term-disk-drive\"><em class=\"xref std std-term ODSAterm\">disk drive</em></a>, this basic or smallest unit of I/O is a\n<a class=\"reference internal\" href=\"#term-sector\"><em class=\"xref std std-term ODSAterm\">sector</em></a>.\nIt is called &quot;buffering&quot; because the block of data returned by\nsuch an access is stored in a <a class=\"reference internal\" href=\"#term-buffer\"><em class=\"xref std std-term ODSAterm\">buffer</em></a>.</dd>", "mod": "<dd>Abbreviation for the <a class=\"reference internal\" href=\"#term-modulus\"><em class=\"xref std std-term ODSAterm\">modulus</em></a> function.</dd>", "closed hash system": "<dd>A <a class=\"reference internal\" href=\"#term-hash-system\"><em class=\"xref std std-term ODSAterm\">hash system</em></a> where all records are stored in slots of\nthe <a class=\"reference internal\" href=\"#term-hash-table\"><em class=\"xref std std-term ODSAterm\">hash table</em></a>.\nThis is in contrast to an <a class=\"reference internal\" href=\"#term-open-hash-system\"><em class=\"xref std std-term ODSAterm\">open hash system</em></a>.</dd>", "collision resolution policy": "<dd>In <a class=\"reference internal\" href=\"#term-hashing\"><em class=\"xref std std-term ODSAterm\">hashing</em></a>, the process of resolving a\n<a class=\"reference internal\" href=\"#term-collision\"><em class=\"xref std std-term ODSAterm\">collision</em></a>.\nSpecifically in a <a class=\"reference internal\" href=\"#term-closed-hash-system\"><em class=\"xref std std-term ODSAterm\">closed hash system</em></a>, this is the\nprocess of finding the proper position in a <a class=\"reference internal\" href=\"#term-hash-table\"><em class=\"xref std std-term ODSAterm\">hash table</em></a>\nthat contains the\ndesired record if the <a class=\"reference internal\" href=\"#term-hash-function\"><em class=\"xref std std-term ODSAterm\">hash function</em></a> did not return the\ncorrect position for that record due to a <a class=\"reference internal\" href=\"#term-collision\"><em class=\"xref std std-term ODSAterm\">collision</em></a> with\nanother record.</dd>", "sparse graph": "<dd>A <a class=\"reference internal\" href=\"#term-graph\"><em class=\"xref std std-term ODSAterm\">graph</em></a> where the actual number of <a class=\"reference internal\" href=\"#term-edge\"><em class=\"xref std std-term ODSAterm\">edges</em></a>\nis much less than the possible number of edges.\nGenerally, this is interpreted to mean that the <a class=\"reference internal\" href=\"#term-degree\"><em class=\"xref std std-term ODSAterm\">degree</em></a>\nfor any <a class=\"reference internal\" href=\"#term-vertex\"><em class=\"xref std std-term ODSAterm\">vertex</em></a> in the graph is relatively low.</dd>", "bag": "<dd>In set notation, a bag is a collection of elements with no order\n(like a set), but which allows for duplicate-valued elements\n(unlike a set).</dd>", "vector": "<dd>In set notation, another term for a <a class=\"reference internal\" href=\"#term-sequence\"><em class=\"xref std std-term ODSAterm\">sequence</em></a>.\nAs a data structure, the term vector usually used as a snyonym\nfor a <a class=\"reference internal\" href=\"#term-dynamic-array\"><em class=\"xref std std-term ODSAterm\">dynamic array</em></a>.</dd>", "memory manager": "<dd>Functionality for managing a <a class=\"reference internal\" href=\"#term-memory-pool\"><em class=\"xref std std-term ODSAterm\">memory pool</em></a>.\nTypically, the memory pool is viewed as an array of bytes by the\nmemory manager.\nThe <a class=\"reference internal\" href=\"#term-client\"><em class=\"xref std std-term ODSAterm\">client</em></a> of the memory manager will request a\ncollection of (adjacent) bytes of some size, and release the\nbytes for reuse when the space is no longer needed.\nThe memory manager should not know anything about the\ninterpretation of the data that is being stored by the client\ninto the memory pool.\nDepending on the precise implementation, the client might pass\nin the data to be stored, in which case the memory manager will\ndeal with the actual copy of the data into the memory pool.\nThe memory manager will return to the client a <a class=\"reference internal\" href=\"#term-handle\"><em class=\"xref std std-term ODSAterm\">handle</em></a>\nthat can later be used by the client to retrieve the data.</dd>", "B$^*$-tree": "<dd>A variant on the <a class=\"reference internal\" href=\"#term-b-tree\"><em class=\"xref std std-term ODSAterm\">B$^+$-tree</em></a>.\nThe <span class=\"math\">\\(\\mathrm{B}^*\\)</span> tree is identical to the <span class=\"math\">\\(\\mathrm{B}^+\\)</span>\ntree, except for the rules used to split and merge nodes.\nInstead of splitting a node in half when it overflows, the\n<span class=\"math\">\\(\\mathrm{B}^*\\)</span> tree\ngives some records to its neighboring sibling, if possible.\nIf the sibling is also full, then these two nodes split into three.\nSimilarly, when a node underflows, it is combined with its two\nsiblings, and the total reduced to two nodes.\nThus, the nodes are always at least two thirds full.</dd>", "abstract data type": "<dd>Abbreviated <a class=\"reference internal\" href=\"#term-adt\"><em class=\"xref std std-term ODSAterm\">ADT</em></a>. The specification of a <a class=\"reference internal\" href=\"#term-data-type\"><em class=\"xref std std-term ODSAterm\">data type</em></a>\nwithin some language, independent of an implementation.\nThe interface for the ADT is defined in terms of a <a class=\"reference internal\" href=\"#term-type\"><em class=\"xref std std-term ODSAterm\">type</em></a>\nand a set of operations on that type.\nThe behavior of each operation is determined by its inputs and\noutputs.\nAn ADT does not specify <em>how</em> the data type is implemented.\nThese implementation details are hidden from the user of the ADT\nand protected from outside access, a concept referred to as\n<a class=\"reference internal\" href=\"#term-encapsulation\"><em class=\"xref std std-term ODSAterm\">encapsulation</em></a>.</dd>", "composite type": "<dd>A type whose <a class=\"reference internal\" href=\"#term-member\"><em class=\"xref std std-term ODSAterm\">members</em></a> have subparts.\nFor example, a typical database record.\nAnother term for this is <a class=\"reference internal\" href=\"#term-aggregate-type\"><em class=\"xref std std-term ODSAterm\">aggregate type</em></a>.</dd>", "design pattern": "<dd>An abstraction for describing the design of programs,\nthat is, the interactions of objects and classes.\nExperienced software designers learn and reuse patterns\nfor combining software components, and design patterns allow\nthis design knowledge to be passed on to new programmers more quickly.</dd>", "sequence": "<dd>In set notation, a collection of elements with an order, and\nwhich may contain duplicate-valued elements.\nA sequence is also sometimes called a <a class=\"reference internal\" href=\"#term-tuple\"><em class=\"xref std std-term ODSAterm\">tuple</em></a> or a\n<a class=\"reference internal\" href=\"#term-vector\"><em class=\"xref std std-term ODSAterm\">vector</em></a>.</dd>", "greedy algorithm": "<dd>An algorithm that makes locally optimal choices at each step.</dd>", "B$^+$-tree": "<dd>The most commonly implemented form of <a class=\"reference internal\" href=\"#term-37\"><em class=\"xref std std-term ODSAterm\">B-tree</em></a>.\nA B$^+$-tree does not store data at the\n<a class=\"reference internal\" href=\"#term-internal-node\"><em class=\"xref std std-term ODSAterm\">internal nodes</em></a>, but\ninstead only stores <a class=\"reference internal\" href=\"#term-search-key\"><em class=\"xref std std-term ODSAterm\">search key</em></a> values as direction\nfinders for the purpose of searching through the tree.\nOnly the <a class=\"reference internal\" href=\"#term-leaf-node\"><em class=\"xref std std-term ODSAterm\">leaf nodes</em></a> store a reference to the\nactual data records.</dd>", "key space decomposition": "<dd>The idea that the range for a <a class=\"reference internal\" href=\"#term-search-key\"><em class=\"xref std std-term ODSAterm\">search key</em></a> will be split\ninto pieces.\nThere are two general approaches to this:\n<a class=\"reference internal\" href=\"#term-object-space-decomposition\"><em class=\"xref std std-term ODSAterm\">object space decomposition</em></a> and\n<a class=\"reference internal\" href=\"#term-image-space-decomposition\"><em class=\"xref std std-term ODSAterm\">image space decomposition</em></a>.</dd>", "PR quadtree": "<dd>A type of <a class=\"reference internal\" href=\"#term-quadtree\"><em class=\"xref std std-term ODSAterm\">quadtree</em></a> that stores point data in two\ndimensions.\nThe root of the PR quadtree represents some square region of 2d\nspace.\nIf that space stores more than one data point, then the region\nis decomposed into four equal subquadrants, each represented\n<a class=\"reference internal\" href=\"#term-recursion\"><em class=\"xref std std-term ODSAterm\">recursively</em></a> by a subtree of the PR quadtree.\nSince many leaf nodes of the PR quadtree will contain no data\npoints, implementation often makes use of the <a class=\"reference internal\" href=\"#term-flyweight\"><em class=\"xref std std-term ODSAterm\">Flyweight</em></a>\n<a class=\"reference internal\" href=\"#term-design-pattern\"><em class=\"xref std std-term ODSAterm\">design pattern</em></a>.\nRelated to the <a class=\"reference internal\" href=\"#term-bintree\"><em class=\"xref std std-term ODSAterm\">bintree</em></a>.</dd>", "cycles <cycle>": "", "flush": "<dd>The the context of a <a class=\"reference internal\" href=\"#term-buffer-pool\"><em class=\"xref std std-term ODSAterm\">buffer pool</em></a>, the process of\nremoving the contents stored in a <a class=\"reference internal\" href=\"#term-buffer\"><em class=\"xref std std-term ODSAterm\">buffer</em></a>\nwhen that buffer is required in order to store new data.\nIf the buffer's contents have been changed since having been\nread in from <a class=\"reference internal\" href=\"#term-backing-storage\"><em class=\"xref std std-term ODSAterm\">backing storage</em></a> (this fact would\nnormally be tracked by using a <a class=\"reference internal\" href=\"#term-dirty-bit\"><em class=\"xref std std-term ODSAterm\">dirty bit</em></a>),\nthen they must be copied back to the backing storage before the\nbuffer can be reused.</dd>", "single rotation": "<dd>A type of <a class=\"reference internal\" href=\"#term-rebalancing-operation\"><em class=\"xref std std-term ODSAterm\">rebalancing operation</em></a> used by the\n<a class=\"reference internal\" href=\"#term-splay-tree\"><em class=\"xref std std-term ODSAterm\">Splay Tree</em></a> and <a class=\"reference internal\" href=\"#term-avl-tree\"><em class=\"xref std std-term ODSAterm\">AVL Tree</em></a>.</dd>", "alphabet trie": "<dd>A <a class=\"reference internal\" href=\"#term-trie\"><em class=\"xref std std-term ODSAterm\">trie</em></a> data structure for storing variable-length\nstrings.\nLevel <span class=\"math\">\\(i\\)</span> of the tree corresponds to the letter in\nposition <span class=\"math\">\\(i\\)</span> of the string.\nThe root will have potential branches on each intial letter of\nstring.\nThus, all strings starting with &quot;a&quot; will be stored in the &quot;a&quot;\nbranch of the tree.\nAt the second level, such strings will be separated by branching\non the second letter.</dd>", "multi-dimensional search structure": "<dd>A data structure used to support efficient search on a\n<a class=\"reference internal\" href=\"#term-multi-dimensional-search-key\"><em class=\"xref std std-term ODSAterm\">multi-dimensional search key</em></a>.\nThe main concept here is that a multi-dimensional search\nstructure works more efficiently by considering the multiple\nparts of the search key as a whole, rather than making\nindependent searches on each one-dimensional component of the\nkey.\nA primary example is a <a class=\"reference internal\" href=\"#term-spatial-data-structure\"><em class=\"xref std std-term ODSAterm\">spatial data structure</em></a> that can\nefficiently represent and search for records in\nmulti-dimensional space.</dd>", "fixed-length coding": "<dd>Given a collection of objects, a fixed-length coding scheme\nassigns a code to each object in the collection using codes that\nare all of the same length.\nStandard ASCII and Unicode representations for characters are\nboth examples of fixed-length coding schemes.\nThis is in contrast to <a class=\"reference internal\" href=\"#term-variable-length-coding\"><em class=\"xref std std-term ODSAterm\">variable-length coding</em></a>.</dd>", "2-3 tree": "<dd>A specialized form of the <a class=\"reference internal\" href=\"#term-37\"><em class=\"xref std std-term ODSAterm\">B-tree</em></a> where each internal\nnode has either 2 children or 3 children.\nKey values are ordered to maintain the\n<a class=\"reference internal\" href=\"#term-binary-search-tree-property\"><em class=\"xref std std-term ODSAterm\">binary search tree property</em></a>.\nThe 2-3 tree is always height balanced, and its insert, search,\nand remove operations all have <span class=\"math\">\\(\\Theta(\\log n)\\)</span> cost.</dd>", "dense": "", "dynamic allocation": "<dd>The act of creating an object from <a class=\"reference internal\" href=\"#term-free-store\"><em class=\"xref std std-term ODSAterm\">free store</em></a>.\nIn C++, Java, and JavaScript, this is done using the <code class=\"docutils literal\"><span class=\"pre\">new</span></code>\noperator.</dd>", "non-deterministic choice": "<dd>An operation that captures the concept of nondeterminism.\nA nondeterministic choice can be viewed as either\n&quot;correctly guessing&quot; between a set of choices, or implementing\neach of the choices in parallel.\nIn the parallel view, the nondeterminism was successful if at\nleast one of the choices leads to a correct answer.</dd>", "bucket hashing": "<dd>A method of <a class=\"reference internal\" href=\"#term-hashing\"><em class=\"xref std std-term ODSAterm\">hashing</em></a> where multiple <a class=\"reference internal\" href=\"#term-slot\"><em class=\"xref std std-term ODSAterm\">slots</em></a>\nof the <a class=\"reference internal\" href=\"#term-hash-table\"><em class=\"xref std std-term ODSAterm\">hash table</em></a> are grouped together to form a\n<a class=\"reference internal\" href=\"#term-bucket\"><em class=\"xref std std-term ODSAterm\">bucket</em></a>.\nThe <a class=\"reference internal\" href=\"#term-hash-function\"><em class=\"xref std std-term ODSAterm\">hash function</em></a> then either hashes to some bucket, or\nelse it hashes to a <a class=\"reference internal\" href=\"#term-home-slot\"><em class=\"xref std std-term ODSAterm\">home slot</em></a> in the normal way, but\nthis home slot is part of some bucket.\n<a class=\"reference internal\" href=\"#term-collision-resolution\"><em class=\"xref std std-term ODSAterm\">Collision resolution</em></a> is handled\nfirst by attempting to find a free position within the same\nbucket as the home slot.\nIf the bucket if full, then the record is placed in an\n<a class=\"reference internal\" href=\"#term-overflow-bucket\"><em class=\"xref std std-term ODSAterm\">overflow bucket</em></a>.</dd>", "NP-Complete": "<dd>A class of problems that are related to each other in this way:\nIf ever one such problem is proved to be solvable in\npolynomial time, or proved to require exponential time,\nthen all other NP-Complete problems will cost likewise.\nSince so many real-world problems have been proved to be\nNP-Complete, it would be extremely useful to determine if they\nhave polynomial or exponential cost. But so far, nobody has\nbeen able to determine the truth of the situation.\nA more technical definition is that a problem is NP-Complete if\nit is in NP and is NP-hard.</dd>", "key sort": "<dd>Any sorting opertation applied to a collection of\n<a class=\"reference internal\" href=\"#term-key-value-pair\"><em class=\"xref std std-term ODSAterm\">key-value pairs</em></a> where the value in this\ncase is a reference to a complete record (that is, a pointer to\nthe record in memory or a position for a record on disk).\nThis is in contrast to a sorting operation that works directly\non a collection of records.\nThe intention is that the collection of key-value pairs is far\nsmaller than the collection of records themselves.\nAs such, this might allow for an <a class=\"reference internal\" href=\"#term-internal-sort\"><em class=\"xref std std-term ODSAterm\">internal sort</em></a> when\nsorting the records directly would require an <a class=\"reference internal\" href=\"#term-external-sort\"><em class=\"xref std std-term ODSAterm\">external\nsort</em></a>.\nThe collection of key-value pairs can also act as an\n<a class=\"reference internal\" href=\"#term-indexing\"><em class=\"xref std std-term ODSAterm\">index</em></a>.</dd>", "alphebet trie": "", "binary tree": "<dd>A finite set of nodes which is either empty, or else has a root\nnode together two binary trees, called the left and right\n<a class=\"reference internal\" href=\"#term-subtree\"><em class=\"xref std std-term ODSAterm\">subtrees</em></a>, which are <a class=\"reference internal\" href=\"#term-disjoint\"><em class=\"xref std std-term ODSAterm\">disjoint</em></a> from each\nother and from the <a class=\"reference internal\" href=\"#term-root\"><em class=\"xref std std-term ODSAterm\">root</em></a>.</dd>", "variable-length coding": "<dd>Given a collection of objects, a variable-length coding scheme\nassigns a code to each object in the collection using codes that\ncan be of different lengths.\nTypically this is done in a way such that the objects that are\nmost likely to be used have the shortest codes, with the goal of\nminimizing the total space needed to represent a sequence of\nobjects, such as when representing the characters in a document.\n<a class=\"reference internal\" href=\"#term-huffman-codes\"><em class=\"xref std std-term ODSAterm\">Huffman coding</em></a> is an example of a\nvariable-length coding scheme.\nThis is in contrast to <a class=\"reference internal\" href=\"#term-fixed-length-coding\"><em class=\"xref std std-term ODSAterm\">fixed-length coding</em></a>.</dd>", "self-organizing list": "<dd>A list that, over a series of search operations, will make\nuse of some <a class=\"reference internal\" href=\"#term-heuristic\"><em class=\"xref std std-term ODSAterm\">heuristic</em></a> to re-order its elements in an\neffort to improve search times.\nGenerally speaking, search is done sequentially from the\nbeginning, but the self-organizing heuristic will attempt to put\nthe records that are most likely to be searched for at or near\nthe front of the list.\nWhile typically not as efficient as <a class=\"reference internal\" href=\"#term-binary-search\"><em class=\"xref std std-term ODSAterm\">binary search</em></a> on a\nsorted list, self-organizing lists do not require that the list\nbe sorted (and so do not pay the cost of doing the sorting\noperation).</dd>", "2-3 tree graph": "", "modulus": "<dd>The modulus function returns the\nremainder of an integer division.\nSometimes written <span class=\"math\">\\(n \\bmod m\\)</span> in mathematical expressions,\nthe syntax in many programming languages is <code class=\"docutils literal\"><span class=\"pre\">n</span> <span class=\"pre\">%</span> <span class=\"pre\">m</span></code>.</dd>", "upper bound": "<dd>In <a class=\"reference internal\" href=\"#term-algorithm-analysis\"><em class=\"xref std std-term ODSAterm\">algorithm analysis</em></a>, a <a class=\"reference internal\" href=\"#term-growth-rate\"><em class=\"xref std std-term ODSAterm\">growth rate</em></a> that is\nalways greater than or equal to the that of the\n<a class=\"reference internal\" href=\"#term-algorithm\"><em class=\"xref std std-term ODSAterm\">algorithm</em></a> in question.\nIn practice, this is the slowest-growing function that we know\ngrows at least as fast as all but a constant number of inputs.\nIt could be a gross over-estimate of the truth.\nSince the upper bound for the algorithm can be very different\nfor different situations (such as the <a class=\"reference internal\" href=\"#term-best-case\"><em class=\"xref std std-term ODSAterm\">best case</em></a> or\n<a class=\"reference internal\" href=\"#term-worst-case\"><em class=\"xref std std-term ODSAterm\">worst case</em></a>), we typically have to specify which\nsituation we are referring to.</dd>", "transpose": "<dd>In the context of linear algebra,\nthe transpose of a matrix <span class=\"math\">\\(A\\)</span> is\nanother matrix <span class=\"math\">\\(A^T\\)</span> created by writing the rows of\n<span class=\"math\">\\(A\\)</span> as the columns of <span class=\"math\">\\(A^T\\)</span>.\nIn the context of a <a class=\"reference internal\" href=\"#term-self-organizing-list\"><em class=\"xref std std-term ODSAterm\">self-organizing list</em></a>,\ntranspose is a <a class=\"reference internal\" href=\"#term-heuristic\"><em class=\"xref std std-term ODSAterm\">heuristic</em></a> used to maintain the list.\nUnder this heuristic, whenever a record is accessed it is moved\none position closer to the front of the list.</dd>", "algorithm analysis": "<dd>A less formal version of the term\n<a class=\"reference internal\" href=\"#term-asymptotic-algorithm-analysis\"><em class=\"xref std std-term ODSAterm\">asymptotic algorithm analysis</em></a>, generally used as a\nsynonym for <a class=\"reference internal\" href=\"#term-asymptotic-analysis\"><em class=\"xref std std-term ODSAterm\">asymptotic analysis</em></a>.</dd>", "dynamic array": "<dd>Arrays, once allocated, are of fixed size. A dynamic array puts\nan interface around the array so as to appear to allow the array\nto grow and shrink in size as necessary. Typically this is done\nby allocating a new copy, copying the contents of the old array,\nand then returning the old array to <a class=\"reference internal\" href=\"#term-free-store\"><em class=\"xref std std-term ODSAterm\">free store</em></a>.\nIf done correctly, the <a class=\"reference internal\" href=\"#term-amortized-cost\"><em class=\"xref std std-term ODSAterm\">amortized cost</em></a> for dynamically\nresizing the array can be made constant.\nIn some programming languages such as Java, the term\n<a class=\"reference internal\" href=\"#term-vector\"><em class=\"xref std std-term ODSAterm\">vector</em></a> is used as a synonym for dynamic array.</dd>", "key": "<dd>A field or part of a larger record used to represent that record\nfor the purpose of searching or comparing.\nAnother term for <a class=\"reference internal\" href=\"#term-search-key\"><em class=\"xref std std-term ODSAterm\">search key</em></a>.</dd>", "clique": "<dd>In <a class=\"reference internal\" href=\"#term-graph\"><em class=\"xref std std-term ODSAterm\">graph</em></a> terminology, a clique is a <a class=\"reference internal\" href=\"#term-subgraph\"><em class=\"xref std std-term ODSAterm\">subgraph</em></a>,\ndefined as any <a class=\"reference internal\" href=\"#term-subset\"><em class=\"xref std std-term ODSAterm\">subset</em></a> <span class=\"math\">\\(U\\)</span> of the graph's\n<a class=\"reference internal\" href=\"#term-vertex\"><em class=\"xref std std-term ODSAterm\">vertices</em></a> such that every vertex in <span class=\"math\">\\(U\\)</span>\nhas an <a class=\"reference internal\" href=\"#term-edge\"><em class=\"xref std std-term ODSAterm\">edge</em></a> to every other vertex in <span class=\"math\">\\(U\\)</span>.\nThe size of the clique is the number of vertices in the clique.</dd>", "kd tree": "<dd>A <a class=\"reference internal\" href=\"#term-spatial-data-structure\"><em class=\"xref std std-term ODSAterm\">spatial data structure</em></a> that uses a binary tree to\nstore a collection of data records based on their (point)\nlocation in space.\nIt uses the concept of a <a class=\"reference internal\" href=\"#term-discriminator\"><em class=\"xref std std-term ODSAterm\">discriminator</em></a> at each level to\ndecide which single component of the\n<a class=\"reference internal\" href=\"#term-multi-dimensional-search-key\"><em class=\"xref std std-term ODSAterm\">multi-dimensional search key</em></a> to branch on at that level.\nIt uses a <a class=\"reference internal\" href=\"#term-key-space-decomposition\"><em class=\"xref std std-term ODSAterm\">key space decomposition</em></a>, meaning that all data\nrecords in the left subtree of a node have a value on the\ncorresponding discriminator that is less than that of the node,\nwhile all data records in the right subtree have a greater\nvalue.\nThe <a class=\"reference internal\" href=\"#term-bintree\"><em class=\"xref std std-term ODSAterm\">bintree</em></a> is the <a class=\"reference internal\" href=\"#term-image-space-decomposition\"><em class=\"xref std std-term ODSAterm\">image space decomposition</em></a>\nanalog of the kd tree.</dd>", "data type": "<dd>A type together with a collection of operations to manipulate\nthe type.</dd>", "bintree": "<dd>A <a class=\"reference internal\" href=\"#term-spatial-data-structure\"><em class=\"xref std std-term ODSAterm\">spatial data structure</em></a> in the form of binary\n<a class=\"reference internal\" href=\"#term-trie\"><em class=\"xref std std-term ODSAterm\">trie</em></a>, typically used to store point data in two or more\ndimensions.\nSimilar to a <a class=\"reference internal\" href=\"#term-pr-quadtree\"><em class=\"xref std std-term ODSAterm\">PR quadtree</em></a> except that at each level, it\nsplits one dimension in half.\nSince many leaf nodes of the PR quadtree will contain no data\npoints, implementation often makes use of the <a class=\"reference internal\" href=\"#term-flyweight\"><em class=\"xref std std-term ODSAterm\">flyweight</em></a>\n<a class=\"reference internal\" href=\"#term-design-pattern\"><em class=\"xref std std-term ODSAterm\">design pattern</em></a>.</dd>", "bubble sort": "<dd>A simple sort that requires <span class=\"math\">\\(Theta(n^2)\\)</span> time in\n<a class=\"reference internal\" href=\"#term-best-case\"><em class=\"xref std std-term ODSAterm\">best</em></a>, <a class=\"reference internal\" href=\"#term-average-case\"><em class=\"xref std std-term ODSAterm\">average</em></a>,\nand <a class=\"reference internal\" href=\"#term-worst-case\"><em class=\"xref std std-term ODSAterm\">worst</em></a> cases.\nEven an optimized version will normally run slower than\n<a class=\"reference internal\" href=\"#term-insertion-sort\"><em class=\"xref std std-term ODSAterm\">insertion sort</em></a>, so it has little to recommend it.</dd>", "sorting lower bound": "<dd>The lower bound for the <a class=\"reference internal\" href=\"#term-problem\"><em class=\"xref std std-term ODSAterm\">problem</em></a> of\n:term:sorting &lt;sorting problem&gt;` is <span class=\"math\">\\(\\Omega(n \\log n)\\)</span>.\nThis is traditionally proved using a <a class=\"reference internal\" href=\"#term-decision-tree\"><em class=\"xref std std-term ODSAterm\">decision tree</em></a> model\nfor sorting algorithms, and recognizing that the minimum depth\nof the decision tree for any sorting algorithm is\n<span class=\"math\">\\(\\Omega(n \\log n)\\)</span> since there are <span class=\"math\">\\(n!\\)</span> permutations\nof the <span class=\"math\">\\(n\\)</span> input records to distinguish between during the\nsorting process.</dd>", "move-to-front": "<dd>A <a class=\"reference internal\" href=\"#term-heuristic\"><em class=\"xref std std-term ODSAterm\">heuristic</em></a> used to maintain a\n<a class=\"reference internal\" href=\"#term-self-organizing-list\"><em class=\"xref std std-term ODSAterm\">self-organizing list</em></a>.\nUnder this heuristic, whenever a record is accessed it is moved\nto the front of the list.\nAnalogous to the <a class=\"reference internal\" href=\"#term-least-recently-used\"><em class=\"xref std std-term ODSAterm\">least recently used</em></a> heuristic for\nmaintaining a <a class=\"reference internal\" href=\"#term-buffer-pool\"><em class=\"xref std std-term ODSAterm\">buffer pool</em></a>.</dd>", "weighted graph": "<dd>A <a class=\"reference internal\" href=\"#term-graph\"><em class=\"xref std std-term ODSAterm\">graph</em></a> whose <a class=\"reference internal\" href=\"#term-edge\"><em class=\"xref std std-term ODSAterm\">edges</em></a> each have an\nassociated <a class=\"reference internal\" href=\"#term-weight\"><em class=\"xref std std-term ODSAterm\">weight</em></a> or cost.</dd>", "directed acyclic graph": "<dd>A <a class=\"reference internal\" href=\"#term-graph\"><em class=\"xref std std-term ODSAterm\">graph</em></a> with no cycles.\nAbbreviated as <a class=\"reference internal\" href=\"#term-dag\"><em class=\"xref std std-term ODSAterm\">DAG</em></a>.\nNote that a DAG is not necessarily a <a class=\"reference internal\" href=\"#term-577\"><em class=\"xref std std-term ODSAterm\">tree</em></a> since a given\n<a class=\"reference internal\" href=\"#term-node\"><em class=\"xref std std-term ODSAterm\">node</em></a> might have multiple <a class=\"reference internal\" href=\"#term-parent\"><em class=\"xref std std-term ODSAterm\">parents</em></a>.</dd>", "queue": "<dd>A list-like structure in which elements are inserted only at one\nend, and removed only from the other one end.</dd>", "subgraph": "<dd>A subgraph <span class=\"math\">\\(\\mathbf{S}\\)</span> is formed from <a class=\"reference internal\" href=\"#term-graph\"><em class=\"xref std std-term ODSAterm\">graph</em></a>\n<span class=\"math\">\\(\\mathbf{G}\\)</span> by selecting a <a class=\"reference internal\" href=\"#term-subset\"><em class=\"xref std std-term ODSAterm\">subset</em></a>\n<span class=\"math\">\\(\\mathbf{V}_s\\)</span> of <span class=\"math\">\\(\\mathbf{G}\\)</span>'s <a class=\"reference internal\" href=\"#term-vertex\"><em class=\"xref std std-term ODSAterm\">vertices</em></a> and a subset <span class=\"math\">\\(\\mathbf{E}_s\\)</span> of\n<span class=\"math\">\\(\\mathbf{G}\\)</span>'s <a class=\"reference internal\" href=\"#term-edge\"><em class=\"xref std std-term ODSAterm\">edges</em></a> such that for every\nedge <span class=\"math\">\\(e \\in \\mathbf{E}_s\\)</span>,\nboth vertices of <span class=\"math\">\\(e\\)</span> are in <span class=\"math\">\\(\\mathbf{V}_s\\)</span>.</dd>", "hash table": "<dd>The data structure (usually an array) that stores data\nrecords for lookup using <a class=\"reference internal\" href=\"#term-hashing\"><em class=\"xref std std-term ODSAterm\">hashing</em></a>.</dd>", "double rotation": "<dd>A type of <a class=\"reference internal\" href=\"#term-rebalancing-operation\"><em class=\"xref std std-term ODSAterm\">rebalancing operation</em></a> used by the\n<a class=\"reference internal\" href=\"#term-splay-tree\"><em class=\"xref std std-term ODSAterm\">Splay Tree</em></a> and <a class=\"reference internal\" href=\"#term-avl-tree\"><em class=\"xref std std-term ODSAterm\">AVL Tree</em></a>.</dd>", "open addressing": "<dd>A synonym for <a class=\"reference internal\" href=\"#term-closed-hash-system\"><em class=\"xref std std-term ODSAterm\">closed hashing</em></a>.</dd>", "simple type": "<dd>A <a class=\"reference internal\" href=\"#term-data-type\"><em class=\"xref std std-term ODSAterm\">data type</em></a> whose values contain no subparts.\nAn example is the integers.</dd>", "splaying": "<dd>The act of performing an <a class=\"reference internal\" href=\"#term-rebalancing-operation\"><em class=\"xref std std-term ODSAterm\">rebalancing operation</em></a> on a\n<a class=\"reference internal\" href=\"#term-splay-tree\"><em class=\"xref std std-term ODSAterm\">Splay Tree</em></a>.</dd>", "digraph": "<dd>Abbreviation for <a class=\"reference internal\" href=\"#term-directed-graph\"><em class=\"xref std std-term ODSAterm\">directed graph</em></a>.</dd>", "pop": "<dd>A specialized term used to indicate removing an <a class=\"reference internal\" href=\"#term-element\"><em class=\"xref std std-term ODSAterm\">element</em></a>\nfrom a <a class=\"reference internal\" href=\"#term-stack\"><em class=\"xref std std-term ODSAterm\">stack</em></a>.</dd>", "80/20 rule": "<dd>Given a typical application where there is a collection of\nrecords and a series of search operations for records,\nthe 80/20 rule is an empirical observation that\n80% of the record accessess typically go to 20% of the records.\nThe exact values varies between data collections, and is related\nto the concept of <a class=\"reference internal\" href=\"#term-locality-of-reference\"><em class=\"xref std std-term ODSAterm\">locality of reference</em></a>.</dd>", "aggregate type": "<dd>A <a class=\"reference internal\" href=\"#term-data-type\"><em class=\"xref std std-term ODSAterm\">data type</em></a> whose <a class=\"reference internal\" href=\"#term-member\"><em class=\"xref std std-term ODSAterm\">members</em></a> have subparts.\nFor example, a typical database record.\nAnother term for this is <a class=\"reference internal\" href=\"#term-composite-type\"><em class=\"xref std std-term ODSAterm\">composite type</em></a>.</dd>", "flyweight": "<dd>A <a class=\"reference internal\" href=\"#term-design-pattern\"><em class=\"xref std std-term ODSAterm\">design pattern</em></a> that is meant to solve the following\nproblem:\nYou have an application with many objects.\nSome of these objects are identical in the information that\nthey contain, and the role that they play.\nBut they must be reached from various places, and conceptually they\nreally are distinct objects.\nBecause there is so much duplication of the same information,\nwe want to reduce memory cost by sharing that space.\nFor example, in document layout,\nthe letter &quot;C&quot; might be represented by an object that\ndescribes that character's strokes and bounding box.\nHowever, we do not want to create a separate &quot;C&quot; object everywhere\nin the document that a &quot;C&quot; appears.\nThe solution is to allocate a single copy of the shared representation\nfor &quot;C&quot; objects.\nThen, every place in the document that needs a &quot;C&quot; in a given font,\nsize, and typeface will reference this single copy.\nThe various instances of references to a specific form of &quot;C&quot; are\ncalled flyweights.\nFlyweights can also used to advantage in the implementation of the\n<a class=\"reference internal\" href=\"#term-bintree\"><em class=\"xref std std-term ODSAterm\">bintree</em></a> and <a class=\"reference internal\" href=\"#term-pr-quadtree\"><em class=\"xref std std-term ODSAterm\">PR quadtree</em></a>.</dd>", "serialization": "<dd>The process of taking a data structure in memory and\nrepresenting it as a sequence of bytes.\nThis is sometimes done in order to transmit the data structure\nacross a network or store the data structure in a\n<a class=\"reference internal\" href=\"#term-stream\"><em class=\"xref std std-term ODSAterm\">stream</em></a>, such as on disk.\n<a class=\"reference internal\" href=\"#term-deserialization\"><em class=\"xref std std-term ODSAterm\">Deserialization</em></a> reconstructs the\noriginal data structure from the serialized representation.</dd>", "discriminator": "<dd>A part of a <a class=\"reference internal\" href=\"#term-multi-dimensional-search-key\"><em class=\"xref std std-term ODSAterm\">multi-dimensional search key</em></a>.\nCertain tree data structures such as the <a class=\"reference internal\" href=\"#term-bintree\"><em class=\"xref std std-term ODSAterm\">bintree</em></a> and the\n<a class=\"reference internal\" href=\"#term-kd-tree\"><em class=\"xref std std-term ODSAterm\">kd tree</em></a> operate by making branching decisions at nodes\nof the tree based on a single attribute of the multi-dimensional\nkey, with the attribute determined by the level of the node in\nthe tree.\nFor example, in 2 dimensions, nodes at the odd levels in the\ntree might branch based on the <span class=\"math\">\\(x\\)</span> value of a coordinate,\nwhile at the even levels the tree would branch based on the\n<span class=\"math\">\\(y\\)</span> value of the coordinate.\nThus, the <span class=\"math\">\\(x\\)</span> coordinate is the discriminator for the odd\nlevels, while the <span class=\"math\">\\(y\\)</span> coordinate is the discriminator for\nthe even levels.</dd>", "edges <edge>": "", "key space": "<dd>The range of values that a <a class=\"reference internal\" href=\"#term-key\"><em class=\"xref std std-term ODSAterm\">key</em></a> value may take on.</dd>", "unweighted graph": "", "k-path": "<dd>In <a class=\"reference internal\" href=\"#term-floyd-s-algorithm\"><em class=\"xref std std-term ODSAterm\">Floyd's algorithm</em></a>, a k-path is a path between two\nvertices <span class=\"math\">\\(i\\)</span> and <span class=\"math\">\\(j\\)</span> that can only go through\nvertices with an index value less than or equal to <span class=\"math\">\\(k\\)</span>.</dd>", "BST": "<dd>Abbreviation for <a class=\"reference internal\" href=\"#term-binary-search-tree\"><em class=\"xref std std-term ODSAterm\">binary search tree</em></a>.</dd>", "undirected graph": "<dd>A <a class=\"reference internal\" href=\"#term-graph\"><em class=\"xref std std-term ODSAterm\">graph</em></a> whose <a class=\"reference internal\" href=\"#term-edge\"><em class=\"xref std std-term ODSAterm\">edges</em></a> do not have a direction.</dd>", "strategy": "<dd>An approach to accomplish a task, often encapsulated as an\nalgorithm.\nAlso the name for a <a class=\"reference internal\" href=\"#term-design-pattern\"><em class=\"xref std std-term ODSAterm\">design pattern</em></a> that separates the\nalgorithm for performing a task from the control for applying\nthat task to each member of a collection.\nA good example is a generic sorting function that takes a\ncollection of records (such as an array) and a &quot;strategy&quot; in the\nform of an algorithm that knows how to extract the key from a\nrecord in the array.\nOnly subtly different from the <a class=\"reference internal\" href=\"#term-visitor\"><em class=\"xref std std-term ODSAterm\">visitor</em></a> design pattern,\nwhere the difference is primarily one of intent rather than\nsyntax.\nThe strategy design pattern is focused on encapsulating an\nactivity that is part of a larger process, so that different\nways of performing that activity can be substituted.\nThe visitor design pattern is focused on encapsulating an\nactivity that will be performed on all members of a collection\nso that completely different activities can be substituted\nwithin a generic method that accesses all of the collection\nmembers.</dd>", "NP": "<dd>An abbreviation for\n<a class=\"reference internal\" href=\"#term-non-deterministic-polynomial-time-algorithm\"><em class=\"xref std std-term ODSAterm\">non-deterministic polynomial</em></a>.</dd>", "dirty bit": "<dd>Within a <a class=\"reference internal\" href=\"#term-buffer-pool\"><em class=\"xref std std-term ODSAterm\">buffer pool</em></a>, a piece of information associated\nwith each <a class=\"reference internal\" href=\"#term-buffer\"><em class=\"xref std std-term ODSAterm\">buffer</em></a> that indicates whether the contents of\nthe buffer have changed since being read in from\n<a class=\"reference internal\" href=\"#term-backing-storage\"><em class=\"xref std std-term ODSAterm\">backing storage</em></a>.\nWhen the buffer is <a class=\"reference internal\" href=\"#term-209\"><em class=\"xref std std-term ODSAterm\">flushed</em></a> from the buffer pool,\nthe buffer's contents must be written to the backing storage if\nthe dirty bit is set (that is, if the contents have changed).\nThis means that a relatively expensive write operation is\nrequired.\nIn contrast, if the dirty bit is not set, then it is unnecessary\nto write the contents to backing storage, thus saving time over\nnot keeping track of whether the contents have changed or not.</dd>", "ADT": "<dd>Abbreviation for <a class=\"reference internal\" href=\"#term-abstract-data-type\"><em class=\"xref std std-term ODSAterm\">abstract data type</em></a>.</dd>", "sequential tree representation": "<dd>A representation that stores a series of node values with the\nminimum information needed to reconstruct the tree structure.\nThis is a technique for <a class=\"reference internal\" href=\"#term-serialization\"><em class=\"xref std std-term ODSAterm\">serializing</em></a> a\ntree.</dd>", "activation record": "<dd>The entity that is stored on the <a class=\"reference internal\" href=\"#term-runtime-stack\"><em class=\"xref std std-term ODSAterm\">runtime stack</em></a> during\nprogram execution.\nIt stores any active <a class=\"reference internal\" href=\"#term-local-variable\"><em class=\"xref std std-term ODSAterm\">local variable</em></a> and the return\naddress from which a new subroutine is being called, so that\nthis information can be recovered when the subroutine\nterminates.</dd>", "locality of reference": "<dd>The concept that accesses within a collection of records is not\nevenly distributed.\nThis can express itself as some small fraction of the records\nreceiving the bulk of the accesses (<a class=\"reference internal\" href=\"#term-rule\"><em class=\"xref std std-term ODSAterm\">80/20 rule</em></a>).\nAlternatively, it can express itself as an increased probability\nthat the next or future accesses will come close to the most\nrecent access.\nThis is the fundamental property for success of <a class=\"reference internal\" href=\"#term-caching\"><em class=\"xref std std-term ODSAterm\">caching</em></a>.</dd>", "DFS": "<dd>Abbreviation for <a class=\"reference internal\" href=\"#term-depth-first-search\"><em class=\"xref std std-term ODSAterm\">depth-first search</em></a>.</dd>", "traversal": "<dd>Any process for visiting all of the objects in a collection\n(such as a <a class=\"reference internal\" href=\"#term-577\"><em class=\"xref std std-term ODSAterm\">tree</em></a> or <a class=\"reference internal\" href=\"#term-graph\"><em class=\"xref std std-term ODSAterm\">graph</em></a>) in some order.</dd>", "depth-first search tree": "<dd>A <a class=\"reference internal\" href=\"#term-577\"><em class=\"xref std std-term ODSAterm\">tree</em></a> that can be defined by the operation of a\n<a class=\"reference internal\" href=\"#term-depth-first-search\"><em class=\"xref std std-term ODSAterm\">depth-first search</em></a> (DFS) on a <a class=\"reference internal\" href=\"#term-graph\"><em class=\"xref std std-term ODSAterm\">graph</em></a>.\nThis tree would consist of the <a class=\"reference internal\" href=\"#term-node\"><em class=\"xref std std-term ODSAterm\">nodes</em></a> of the graph\nand a subset of the <a class=\"reference internal\" href=\"#term-edge\"><em class=\"xref std std-term ODSAterm\">edges</em></a> of the graph that was\nfollowed during the DFS.</dd>", "Huffman codes": "<dd>The codes given to a collection of letters (or other symbols)\nthrough the process of Huffman coding.\nHuffman coding uses a <a class=\"reference internal\" href=\"#term-huffman-coding-tree\"><em class=\"xref std std-term ODSAterm\">Huffman coding tree</em></a> to generate\nthe codes.\nThe codes can be of variable length, such that the letters which\nare expected to appear most frequently are shorter.\nHuffman coding is optimal whenever the true frequencies are\nknown, and the frequency of a letter is independent of the\ncontext of that letter in the message.</dd>", "adjacency matrix": "<dd>An implementation for a <a class=\"reference internal\" href=\"#term-graph\"><em class=\"xref std std-term ODSAterm\">graph</em></a> that uses a 2-dimensional\narray where each row and each column corresponds to a\n<a class=\"reference internal\" href=\"#term-vertex\"><em class=\"xref std std-term ODSAterm\">vertex</em></a> in the <a class=\"reference internal\" href=\"#term-graph\"><em class=\"xref std std-term ODSAterm\">graph</em></a>. A given row and column in\nthe matrix corresponds to an edge from the <a class=\"reference internal\" href=\"#term-vertex\"><em class=\"xref std std-term ODSAterm\">vertex</em></a>\ncorresponding to the row to the vertex corresponding to the\ncolumn.</dd>", "Composite design pattern": "<dd>Given a class hierarchy representing a set of objects, and a\ncontainer for a collection of objects, the composite\n<a class=\"reference internal\" href=\"#term-design-pattern\"><em class=\"xref std std-term ODSAterm\">design pattern</em></a> addresses the relationship between the\nobject hierarchy and a bunch of behaviors on the objects.\nIn the composite design, each object is required to implement\nthe collection of behaviors.\nThis is in contrast to the procedural approach where a behavior\n(such as a tree <a class=\"reference internal\" href=\"#term-traversal\"><em class=\"xref std std-term ODSAterm\">traversal</em></a>) is implemented as a\nmethod on  the object collection (such as a <a class=\"reference internal\" href=\"#term-577\"><em class=\"xref std std-term ODSAterm\">tree</em></a>).\nProcedural tree traversal requires that the tree have a method\nthat understands what to do when it encounters any of the object\ntypes (<a class=\"reference internal\" href=\"#term-internal-node\"><em class=\"xref std std-term ODSAterm\">internal</em></a> or\n<a class=\"reference internal\" href=\"#term-leaf-node\"><em class=\"xref std std-term ODSAterm\">leaf nodes</em></a>) that the tree might contain.\nThe composite approach would have the tree call the &quot;traversal&quot;\nmethod on its root node, which then knows how to perform the\n&quot;traversal&quot; behavior.\nThis might in turn require invoking the traversal method of\nother objects (in this case, the children of the root).</dd>", "search lower bound": "<dd>The problem of searching in an array has provable lower bounds\nfor specific variations of the problem.\nFor an unsorted array, it is <span class=\"math\">\\(\\Omega(n)\\)</span>\n<a class=\"reference internal\" href=\"#term-comparison\"><em class=\"xref std std-term ODSAterm\">comparisons</em></a> in the <a class=\"reference internal\" href=\"#term-worst-case\"><em class=\"xref std std-term ODSAterm\">worst case</em></a>,\ntypically proved using an <a class=\"reference internal\" href=\"#term-adversary-argument\"><em class=\"xref std std-term ODSAterm\">adversary argument</em></a>.\nFor a sorted array, it is <span class=\"math\">\\(\\Omega(\\log n)\\)</span> in the worst\ncase, typically proved using an argument similar to the\n<a class=\"reference internal\" href=\"#term-sorting-lower-bound\"><em class=\"xref std std-term ODSAterm\">sorting lower bound</em></a> proof.\nHowever, it is possible to search a sorted array in the average\ncase in <span class=\"math\">\\(O(\\log \\log n)\\)</span> time.</dd>", "dynamic programming": "<dd>An approach to designing algorithms that works by storing a table\nof results for subproblems.\nA typical cause for excessive cost in\n<a class=\"reference internal\" href=\"#term-recursion\"><em class=\"xref std std-term ODSAterm\">recursive</em></a>\nalgorithms is that different branches of the recursion might\nsolve the same subproblem.\nDynamic programming uses a table to store information about\nwhich subproblems have already been solved, and uses the stored\ninformation to immediately give the answer for any repeated\nattempts to solve that subproblem.</dd>", "stack": "<dd>A list-like structure in which elements may be inserted or\nremoved from only one end.</dd>", "bucket": "<dd>In <a class=\"reference internal\" href=\"#term-bucket-hashing\"><em class=\"xref std std-term ODSAterm\">bucket hashing</em></a>, a bucket is a sequence of\n<a class=\"reference internal\" href=\"#term-slot\"><em class=\"xref std std-term ODSAterm\">slots</em></a> in the <a class=\"reference internal\" href=\"#term-hash-table\"><em class=\"xref std std-term ODSAterm\">hash table</em></a> that are grouped\ntogether.</dd>", "binary search tree": "<dd>A binary tree that imposes the following constraint on its node\nvalues: The <a class=\"reference internal\" href=\"#term-search-key\"><em class=\"xref std std-term ODSAterm\">search key</em></a> value for any node <span class=\"math\">\\(A\\)</span> must\nbe greater than the (key) values for all nodes in the left\n<a class=\"reference internal\" href=\"#term-subtree\"><em class=\"xref std std-term ODSAterm\">subtree</em></a> of <span class=\"math\">\\(A\\)</span>, and less than the key values for\nall nodes in the right subtree of <span class=\"math\">\\(A\\)</span>.\nSome convention must be adopted if\nmultiple nodes with the same key value are permitted,\ntypically these are required to be in the right subtree.</dd>", "open hash system": "<dd>A <a class=\"reference internal\" href=\"#term-hash-system\"><em class=\"xref std std-term ODSAterm\">hash system</em></a> where multiple records might be associated\nwith the same slot of a <a class=\"reference internal\" href=\"#term-hash-table\"><em class=\"xref std std-term ODSAterm\">hash table</em></a>.\nTypically this is done using a linked list to store the records.\nThis is in contrast to a <a class=\"reference internal\" href=\"#term-closed-hash-system\"><em class=\"xref std std-term ODSAterm\">closed hash system</em></a>.</dd>", "image space decomposition": "<dd>A from of <a class=\"reference internal\" href=\"#term-key-space-decomposition\"><em class=\"xref std std-term ODSAterm\">key space decomposition</em></a> where the\n<a class=\"reference internal\" href=\"#term-key-space\"><em class=\"xref std std-term ODSAterm\">key space</em></a> splitting points is predetermined (typically\nby splitting in half).\nFor example, a <a class=\"reference internal\" href=\"#term-huffman-coding-tree\"><em class=\"xref std std-term ODSAterm\">Huffman coding tree</em></a> splits the letters\nbeing coded into those with codes that start with 0 on the left\nside, and those with codes that start with 1 on the right side.\nThis regular decomposition of the key space is the basis for a\n<a class=\"reference internal\" href=\"#term-trie\"><em class=\"xref std std-term ODSAterm\">trie</em></a> data structure.\nAn image space decomposition is in opposition to an\n<a class=\"reference internal\" href=\"#term-object-space-decomposition\"><em class=\"xref std std-term ODSAterm\">object space decomposition</em></a>.</dd>", "buddy method": "<dd>In a <a class=\"reference internal\" href=\"#term-memory-manager\"><em class=\"xref std std-term ODSAterm\">memory manager</em></a>, an alternative to using a\n<a class=\"reference internal\" href=\"#term-free-block-list\"><em class=\"xref std std-term ODSAterm\">free block list</em></a> and a <a class=\"reference internal\" href=\"#term-sequential-fit\"><em class=\"xref std std-term ODSAterm\">sequential fit</em></a> method to\nseach for a suitable free block to service a\n<a class=\"reference internal\" href=\"#term-memory-request\"><em class=\"xref std std-term ODSAterm\">memory request</em></a>.\nInstead, the memory pool is broken down as needed into smaller\nchunks by splitting it in half repeatedly until the smallest\npower of 2 that is as big or bigger than the size of the memory\nrequest is reached.\nThe name comes from the fact that the binary representation for\nthe start of the block positions only differ by one bit for\nadjacent blocks of the same size.\nThese are referred to as &quot;buddies&quot; and will be merged together\nif both are free.</dd>", "neighbor": "<dd>In a <a class=\"reference internal\" href=\"#term-graph\"><em class=\"xref std std-term ODSAterm\">graph</em></a>, a <a class=\"reference internal\" href=\"#term-node\"><em class=\"xref std std-term ODSAterm\">node</em></a> <span class=\"math\">\\(w\\)</span> is said to be a\nneighbor of <a class=\"reference internal\" href=\"#term-node\"><em class=\"xref std std-term ODSAterm\">node</em></a> <span class=\"math\">\\(v\\)</span> if there is an <a class=\"reference internal\" href=\"#term-edge\"><em class=\"xref std std-term ODSAterm\">edge</em></a>\nfrom <span class=\"math\">\\(v\\)</span> to <span class=\"math\">\\(w\\)</span>.</dd>", "problem": "<dd>A task to be performed.\nIt is best thought of as a <a class=\"reference internal\" href=\"#term-function\"><em class=\"xref std std-term ODSAterm\">function</em></a> or a mapping of\ninputs to outputs.</dd>", "proof": "<dd>The establishment of the truth of anything, a demonstration.</dd>", "trie": "<dd>A form of <a class=\"reference internal\" href=\"#term-search-tree\"><em class=\"xref std std-term ODSAterm\">search tree</em></a> where an internal node represents\na split in the <a class=\"reference internal\" href=\"#term-key-space\"><em class=\"xref std std-term ODSAterm\">key space</em></a> at a predetermined location,\nrather than split based on the actual <a class=\"reference internal\" href=\"#term-key\"><em class=\"xref std std-term ODSAterm\">key</em></a> values seen.\nFor example, a simple binary search trie for key values in the\nrange 0 to 1023 would store all records with key values less\nthan 512 on the left side of the tree, and all records with key\nvalues equal to or greater than 512 on the right side of the\ntree.\nA trie is always a <a class=\"reference internal\" href=\"#term-full-tree\"><em class=\"xref std std-term ODSAterm\">full tree</em></a>.\nFolklore has it that the term comes from &quot;retrieval&quot;, and should\nbe pronounced as &quot;try&quot; (in contrast to &quot;tree&quot;, to distinguish\nthe differences in the space decomposition method of a search\ntree versus a search trie).\nThe term &quot;trie&quot; is also sometimes used as a synonym for the\n<a class=\"reference internal\" href=\"#term-alphabet-trie\"><em class=\"xref std std-term ODSAterm\">alphabet trie</em></a>.</dd>", "non-deterministic polynomial time algorithm": "<dd>An algorithm that runs in polynomial time, and which may\n(or might not) use <a class=\"reference internal\" href=\"#term-non-deterministic-choice\"><em class=\"xref std std-term ODSAterm\">non-deterministic choice</em></a>.</dd>", "Splay Tree": "<dd>A variant implementation for the <a class=\"reference internal\" href=\"#term-bst\"><em class=\"xref std std-term ODSAterm\">BST</em></a>, which differs from\nthe standard BST in that it uses modified insert and remove\nmethods in order to keep the tree\n<a class=\"reference internal\" href=\"#term-balanced-tree\"><em class=\"xref std std-term ODSAterm\">balanced</em></a>.\nSimilar to an <a class=\"reference internal\" href=\"#term-avl-tree\"><em class=\"xref std std-term ODSAterm\">AVL Tree</em></a> in that it uses the concept of\n<a class=\"reference internal\" href=\"#term-rotation\"><em class=\"xref std std-term ODSAterm\">rotations</em></a> in the insert and remove operations.\nWhile a Splay Tree does not guarentee that the tree is balanced,\nit does guarentee that a series of <span class=\"math\">\\(n\\)</span> operations on the\ntree will have a total cost of <span class=\"math\">\\(\\Theta(n \\log n)\\)</span> cost,\nmeaning that any given operation can be viewed as having\n<a class=\"reference internal\" href=\"#term-amortized-cost\"><em class=\"xref std std-term ODSAterm\">amortized cost</em></a> of <span class=\"math\">\\(\\Theta(\\log n)\\)</span>.</dd>", "DAG": "<dd>Abbreviation for <a class=\"reference internal\" href=\"#term-directed-acyclic-graph\"><em class=\"xref std std-term ODSAterm\">directed acyclic graph</em></a>.</dd>", "hash function": "<dd>In a <a class=\"reference internal\" href=\"#term-hash-system\"><em class=\"xref std std-term ODSAterm\">hash system</em></a>, the function that converts a\n<a class=\"reference internal\" href=\"#term-key\"><em class=\"xref std std-term ODSAterm\">key</em></a> value to a position in the <a class=\"reference internal\" href=\"#term-hash-table\"><em class=\"xref std std-term ODSAterm\">hash table</em></a>.\nThe hope is that this position in the hash table contains the\nrecord that matches the key value.</dd>", "all-pairs shortest paths problem": "<dd>Given a <a class=\"reference internal\" href=\"#term-graph\"><em class=\"xref std std-term ODSAterm\">graph</em></a> with <a class=\"reference internal\" href=\"#term-weight\"><em class=\"xref std std-term ODSAterm\">weights</em></a> or\ndistances on the <a class=\"reference internal\" href=\"#term-edge\"><em class=\"xref std std-term ODSAterm\">edges</em></a>,\nfind the shortest paths between every pair of\nvertices in the graph.\nOne approach to solving this problem is\n<a class=\"reference internal\" href=\"#term-floyd-s-algorithm\"><em class=\"xref std std-term ODSAterm\">Floyd's algorithm</em></a>, which uses the\n<a class=\"reference internal\" href=\"#term-dynamic-programming\"><em class=\"xref std std-term ODSAterm\">dynamic programming</em></a> algorithmic technique.</dd>", "binary search tree property": "<dd>The defining relationship between the <a class=\"reference internal\" href=\"#term-key\"><em class=\"xref std std-term ODSAterm\">key</em></a> values for\n<a class=\"reference internal\" href=\"#term-node\"><em class=\"xref std std-term ODSAterm\">nodes</em></a> in a <a class=\"reference internal\" href=\"#term-bst\"><em class=\"xref std std-term ODSAterm\">BST</em></a>.\nAll nodes stored in the left subtree of a node whose key value\nis <span class=\"math\">\\(K\\)</span> have key values less than or equal to <span class=\"math\">\\(K\\)</span>.\nAll nodes stored in the right subtree of a node whose key value\nis <span class=\"math\">\\(K\\)</span> have key values greater than <span class=\"math\">\\(K\\)</span>.</dd>", "Kruskal's algorithm": "<dd>An algorithm for computing the <a class=\"reference internal\" href=\"#term-mcst\"><em class=\"xref std std-term ODSAterm\">MCST</em></a> of a\n<a class=\"reference internal\" href=\"#term-graph\"><em class=\"xref std std-term ODSAterm\">graph</em></a>.\nDuring processing, it makes use of the <a class=\"reference internal\" href=\"#term-union-find\"><em class=\"xref std std-term ODSAterm\">UNION/FIND</em></a>\nprocess to efficiently determine of two vertices are within the\nsame <a class=\"reference internal\" href=\"#term-subgraph\"><em class=\"xref std std-term ODSAterm\">subgraph</em></a>.</dd>", "labeled graph": "<dd>A <a class=\"reference internal\" href=\"#term-graph\"><em class=\"xref std std-term ODSAterm\">graph</em></a> with labels associated with the\n<a class=\"reference internal\" href=\"#term-node\"><em class=\"xref std std-term ODSAterm\">nodes</em></a>.</dd>", "singly linked list": "<dd>A <a class=\"reference internal\" href=\"#term-linked-list\"><em class=\"xref std std-term ODSAterm\">linked list</em></a> implementation variant where each list\nnode contains access an pointer only to the next element in the list.</dd>", "adjacent": "<dd>Two <a class=\"reference internal\" href=\"#term-node\"><em class=\"xref std std-term ODSAterm\">nodes</em></a> of a <a class=\"reference internal\" href=\"#term-577\"><em class=\"xref std std-term ODSAterm\">tree</em></a> or two\n<a class=\"reference internal\" href=\"#term-vertex\"><em class=\"xref std std-term ODSAterm\">vertices</em></a> of a <a class=\"reference internal\" href=\"#term-graph\"><em class=\"xref std std-term ODSAterm\">graph</em></a> are said to be\nadjacent if they have an <a class=\"reference internal\" href=\"#term-edge\"><em class=\"xref std std-term ODSAterm\">edge</em></a> connecting them.\nIf the edge is directed from <span class=\"math\">\\(a\\)</span> to <span class=\"math\">\\(b\\)</span>,\nthen we say that <span class=\"math\">\\(a\\)</span> is adjacent to <span class=\"math\">\\(b\\)</span>,\nand <span class=\"math\">\\(b\\)</span> is adjacent from <span class=\"math\">\\(a\\)</span>.</dd>", "object space decomposition": "<dd>A from of <a class=\"reference internal\" href=\"#term-key-space-decomposition\"><em class=\"xref std std-term ODSAterm\">key space decomposition</em></a> where the\n<a class=\"reference internal\" href=\"#term-key-space\"><em class=\"xref std std-term ODSAterm\">key space</em></a> is determined\nby the actual values of keys that are found.\nFor example, a <a class=\"reference internal\" href=\"#term-bst\"><em class=\"xref std std-term ODSAterm\">BST</em></a> stores a key value in its root,\nand all other values in the tree with lesser value are in the\nleft <a class=\"reference internal\" href=\"#term-subtree\"><em class=\"xref std std-term ODSAterm\">subtree</em></a>.\nThus, the root value has split (or decomposed) the\n<a class=\"reference internal\" href=\"#term-key-space\"><em class=\"xref std std-term ODSAterm\">key space</em></a> for that key based on its value into left\nand right parts.\nAn object space decomposition is in opposition to an\n<a class=\"reference internal\" href=\"#term-image-space-decomposition\"><em class=\"xref std std-term ODSAterm\">image space decomposition</em></a>.</dd>", "depth-first search": "<dd>A <a class=\"reference internal\" href=\"#term-graph\"><em class=\"xref std std-term ODSAterm\">graph</em></a> <a class=\"reference internal\" href=\"#term-traversal\"><em class=\"xref std std-term ODSAterm\">traversal</em></a> algorithm.\nWhenever a <span class=\"math\">\\(v\\)</span> is <a class=\"reference internal\" href=\"#term-visit\"><em class=\"xref std std-term ODSAterm\">visited</em></a> during the\ntraversal, DFS will <a class=\"reference internal\" href=\"#term-recursion\"><em class=\"xref std std-term ODSAterm\">recursively</em></a> visit all of\n<span class=\"math\">\\(v\\)</span> 's <a class=\"reference internal\" href=\"#term-unvisited\"><em class=\"xref std std-term ODSAterm\">unvisited</em></a> <a class=\"reference internal\" href=\"#term-neighbor\"><em class=\"xref std std-term ODSAterm\">neighbors</em></a>.</dd>", "growth rate": "<dd>In <a class=\"reference internal\" href=\"#term-algorithm-analysis\"><em class=\"xref std std-term ODSAterm\">algorithm analysis</em></a>, the rate at which the cost\nof the <a class=\"reference internal\" href=\"#term-algorithm\"><em class=\"xref std std-term ODSAterm\">algorithm</em></a> grows as the size of its input grows.</dd>", "node": "<dd>The objects that make up a linked structure such as a linked\nlist or binary tree.\nTypically, nodes are allocated using\n<a class=\"reference internal\" href=\"#term-dynamic-memory-allocation\"><em class=\"xref std std-term ODSAterm\">dynamic memory allocation</em></a>.\nIn <a class=\"reference internal\" href=\"#term-graph\"><em class=\"xref std std-term ODSAterm\">graph</em></a> terminology, the nodes are more commonly called\n<a class=\"reference internal\" href=\"#term-vertex\"><em class=\"xref std std-term ODSAterm\">vertices</em></a>.</dd>", "multilist": "<dd>A list that may contain sublists.\nThis term is sometimes used as a synonym to the term\n<a class=\"reference internal\" href=\"#term-bag\"><em class=\"xref std std-term ODSAterm\">bag</em></a>.</dd>", "adjacency list": "<dd>An implementation for a <a class=\"reference internal\" href=\"#term-graph\"><em class=\"xref std std-term ODSAterm\">graph</em></a> that uses an (array-based)\n<a class=\"reference internal\" href=\"#term-list\"><em class=\"xref std std-term ODSAterm\">list</em></a> to represent the <a class=\"reference internal\" href=\"#term-vertex\"><em class=\"xref std std-term ODSAterm\">vertices</em></a> of the\ngraph, and each vertex is in turn represented by a\n(linked) list of the vertices that are\n<a class=\"reference internal\" href=\"#term-neighbor\"><em class=\"xref std std-term ODSAterm\">neighbors</em></a>.</dd>", "B-tree": "<dd>A method for <a class=\"reference internal\" href=\"#term-indexing\"><em class=\"xref std std-term ODSAterm\">indexing</em></a> a large collection of records.\nA B-tree is a <a class=\"reference internal\" href=\"#term-balanced-tree\"><em class=\"xref std std-term ODSAterm\">balanced tree</em></a> that typically has high\nbranching factor (commonly as much as 100\n<a class=\"reference internal\" href=\"#term-child\"><em class=\"xref std std-term ODSAterm\">children</em></a> per <a class=\"reference internal\" href=\"#term-internal-node\"><em class=\"xref std std-term ODSAterm\">internal node</em></a>),\ncausing the tree to be very shallow.\nWhen stored on disk, the node size is selected to be same as the\ndesired unit of I/O (so some multiple of the disk <a class=\"reference internal\" href=\"#term-sector\"><em class=\"xref std std-term ODSAterm\">sector</em></a>\nsize).\nThis makes it easy to gain access to the record associated with\na given <a class=\"reference internal\" href=\"#term-search-key\"><em class=\"xref std std-term ODSAterm\">search key</em></a> stored in the tree with few\n<a class=\"reference internal\" href=\"#term-disk-access\"><em class=\"xref std std-term ODSAterm\">disk accesses</em></a>.\nThe most commonly implemented variant of the B-tree is the\n<a class=\"reference internal\" href=\"#term-b-tree\"><em class=\"xref std std-term ODSAterm\">B$^+$-tree</em></a>.</dd>", "buffer": "<dd>A block of memory, most often in <a class=\"reference internal\" href=\"#term-primary-storage\"><em class=\"xref std std-term ODSAterm\">primary storage</em></a>.\nThe size of a buffer is typically one or a multiple of the basic\nunit of I/O that is read or written on each access to\n<a class=\"reference internal\" href=\"#term-secondary-storage\"><em class=\"xref std std-term ODSAterm\">secondary storage</em></a> such as a <a class=\"reference internal\" href=\"#term-disk-drive\"><em class=\"xref std std-term ODSAterm\">disk drive</em></a>.</dd>", "multi-dimensional search key": "<dd>A search key containing multiple parts, that works in\nconjunction with a <a class=\"reference internal\" href=\"#term-multi-dimensional-search-structure\"><em class=\"xref std std-term ODSAterm\">multi-dimensional search structure</em></a>.\nMost typically, a <a class=\"reference internal\" href=\"#term-spatial\"><em class=\"xref std std-term ODSAterm\">spatial</em></a> search key representing a\nposition in multi-dimensional (2 or 3 dimensions) space.\nBut a multi-dimensional key could be used to organize data within\nnon-spatial dimensions, such as temperature and time.</dd>", "lower bounds proof": "<dd>A proof regarding the lower bound, with this term most typically\nreferring to the lower bound for any possible algorithm to solve\na given <a class=\"reference internal\" href=\"#term-problem\"><em class=\"xref std std-term ODSAterm\">problem</em></a>.\nMany problems have a simple lower bound based on the concept\nthat the minimum amount of processing is related to looking at\nall of the problem's input.\nHowever, some problems have a higher lower bound than that.\nFor example, the lower bound for the problem of sorting\n(<span class=\"math\">\\(\\Omega(n \\log n)\\)</span>) is greater than the input size to\nsorting (<span class=\"math\">\\(n\\)</span>).\nProving such &quot;non-trivial&quot; lower bounds for problems is\nnotoriously difficult.</dd>", "vertex": "<dd>Another name for a <a class=\"reference internal\" href=\"#term-node\"><em class=\"xref std std-term ODSAterm\">node</em></a> in a <a class=\"reference internal\" href=\"#term-graph\"><em class=\"xref std std-term ODSAterm\">graph</em></a>.</dd>", "minimal-cost spanning tree": "<dd>Abbreviated as MCST, or sometimes as MST.\nDerived from a <a class=\"reference internal\" href=\"#term-weighted-graph\"><em class=\"xref std std-term ODSAterm\">weighted graph</em></a>, the MCST is the\n<a class=\"reference internal\" href=\"#term-subset\"><em class=\"xref std std-term ODSAterm\">subset</em></a> of the graph's <a class=\"reference internal\" href=\"#term-edge\"><em class=\"xref std std-term ODSAterm\">edges</em></a> that\nmaintains the connectivitiy of the graph while having lowest\ntotal cost (as defined by the sum of the\n<a class=\"reference internal\" href=\"#term-weight\"><em class=\"xref std std-term ODSAterm\">weights</em></a> of the edges in the MCST).\nThe result is referred to as a <a class=\"reference internal\" href=\"#term-577\"><em class=\"xref std std-term ODSAterm\">tree</em></a> because it would\nnever have a <a class=\"reference internal\" href=\"#term-cycle\"><em class=\"xref std std-term ODSAterm\">cycle</em></a> (since an edge could be removed from\nthe cycle and still preserve connectivity).\nTwo algorithms to solve this problem are\n<a class=\"reference internal\" href=\"#term-prim-s-algorithm\"><em class=\"xref std std-term ODSAterm\">Prim's algorithm</em></a> and <a class=\"reference internal\" href=\"#term-kruskal-s-algorithm\"><em class=\"xref std std-term ODSAterm\">Kruskal's algorithm</em></a>.</dd>", "push": "<dd>A specialized term used to indicate inserting an <a class=\"reference internal\" href=\"#term-element\"><em class=\"xref std std-term ODSAterm\">element</em></a>\nonto a <a class=\"reference internal\" href=\"#term-stack\"><em class=\"xref std std-term ODSAterm\">stack</em></a>.</dd>", "topological sort": "<dd>The process of laying out the <a class=\"reference internal\" href=\"#term-vertex\"><em class=\"xref std std-term ODSAterm\">vertices</em></a> of a\n<a class=\"reference internal\" href=\"#term-dag\"><em class=\"xref std std-term ODSAterm\">DAG</em></a> in a <a class=\"reference internal\" href=\"#term-linear-order\"><em class=\"xref std std-term ODSAterm\">linear order</em></a> such that no vertex\n<span class=\"math\">\\(A\\)</span> in the order is preceded by a vertex that can be\nreached by a (directed) <a class=\"reference internal\" href=\"#term-path\"><em class=\"xref std std-term ODSAterm\">path</em></a> from <span class=\"math\">\\(A\\)</span>.\nUsually the (directed) edges in the graph define a\nprerequisite system, and the goal of the topological sort is\nto list the vertices in an order such that no prerequisites are\nviolated.</dd>", "splay tree": "", "acyclic graph": "<dd>In <a class=\"reference internal\" href=\"#term-graph\"><em class=\"xref std std-term ODSAterm\">graph</em></a> terminology, a graph that contains no\n<a class=\"reference internal\" href=\"#term-cycle\"><em class=\"xref std std-term ODSAterm\">cycles</em></a>.</dd>", "binary trie": "<dd>A <a class=\"reference internal\" href=\"#term-binary-tree\"><em class=\"xref std std-term ODSAterm\">binary tree</em></a> whose structure is that of a <a class=\"reference internal\" href=\"#term-trie\"><em class=\"xref std std-term ODSAterm\">trie</em></a>.\nGenerally this is an implementation for a <a class=\"reference internal\" href=\"#term-search-tree\"><em class=\"xref std std-term ODSAterm\">search tree</em></a>.\nThis means that the <a class=\"reference internal\" href=\"#term-search-key\"><em class=\"xref std std-term ODSAterm\">search key</em></a> values are thought of a\nbinary digits, with the digit in the position corresponding to\nthis a node's <a class=\"reference internal\" href=\"#term-level\"><em class=\"xref std std-term ODSAterm\">level</em></a> in the tree indicating a left branch\nif it is &quot;0&quot;, or a right branch if it is &quot;1&quot;.\nExamples include the <a class=\"reference internal\" href=\"#term-huffman-coding-tree\"><em class=\"xref std std-term ODSAterm\">Huffman coding tree</em></a> and the\n<a class=\"reference internal\" href=\"#term-bintree\"><em class=\"xref std std-term ODSAterm\">Bintree</em></a>.</dd>", "hashing": "<dd>A search method that uses a <a class=\"reference internal\" href=\"#term-hash-function\"><em class=\"xref std std-term ODSAterm\">hash function</em></a> to convert a\n<a class=\"reference internal\" href=\"#term-search-key\"><em class=\"xref std std-term ODSAterm\">search key</em></a> value into a position within a\n<a class=\"reference internal\" href=\"#term-hash-table\"><em class=\"xref std std-term ODSAterm\">hash table</em></a>.\nIn a properly implemented <a class=\"reference internal\" href=\"#term-hash-system\"><em class=\"xref std std-term ODSAterm\">hash system</em></a>, that position in\nthe table will have high probability of containing the record\nthat matches the key value.\nSometimes, the hash function will return an position that does\nnot store the desired key, due to a process called\n<a class=\"reference internal\" href=\"#term-collision\"><em class=\"xref std std-term ODSAterm\">collision</em></a>.\nIn that case, the desired record is found through a process\nknown as <a class=\"reference internal\" href=\"#term-collision-resolution\"><em class=\"xref std std-term ODSAterm\">collision resolution</em></a>.</dd>", "search trie": "<dd>Any <a class=\"reference internal\" href=\"#term-search-tree\"><em class=\"xref std std-term ODSAterm\">search tree</em></a> that is a <a class=\"reference internal\" href=\"#term-trie\"><em class=\"xref std std-term ODSAterm\">trie</em></a>.</dd>", "algorithm": "<dd>A method or a process followed to solve a <a class=\"reference internal\" href=\"#term-problem\"><em class=\"xref std std-term ODSAterm\">problem</em></a>.</dd>", "buffer pool": "<dd>A collection of one or more <a class=\"reference internal\" href=\"#term-buffer\"><em class=\"xref std std-term ODSAterm\">buffers</em></a>.\nThe buffer pool is an example of a <a class=\"reference internal\" href=\"#term-caching\"><em class=\"xref std std-term ODSAterm\">cache</em></a>.\nIt is stored in <a class=\"reference internal\" href=\"#term-primary-storage\"><em class=\"xref std std-term ODSAterm\">primary storage</em></a>, and holds data that is\nexpected to be used in the near future.\nWhen a data value is requested, the buffer pool is searched\nfirst.\nIf the value is found in the buffer pool, then\n<a class=\"reference internal\" href=\"#term-secondary-storage\"><em class=\"xref std std-term ODSAterm\">secondary storage</em></a> need not be accessed.\nIf the value is not found in the buffer pool, then it must be\nfetched from secondary storage.\nA number of traditional <a class=\"reference internal\" href=\"#term-heuristic\"><em class=\"xref std std-term ODSAterm\">heuristics</em></a>\nhave been developed for deciding which data to <a class=\"reference internal\" href=\"#term-209\"><em class=\"xref std std-term ODSAterm\">flush</em></a>\nfrom the buffer pool when new data must be stored,\nsuch as <a class=\"reference internal\" href=\"#term-least-recently-used\"><em class=\"xref std std-term ODSAterm\">least recently used</em></a>.</dd>", "UNION/FIND": "<dd>A process for mainining a collection of disjoint sets.\nThe <a class=\"reference internal\" href=\"#term-find\"><em class=\"xref std std-term ODSAterm\">FIND</em></a> operation determines which disjoint set a given\nobject resides in, and the <a class=\"reference internal\" href=\"#term-union\"><em class=\"xref std std-term ODSAterm\">UNION</em></a> operation combines two\ndisjoint sets when it is determined that they are members of the\nsame <a class=\"reference internal\" href=\"#term-equivalence-class\"><em class=\"xref std std-term ODSAterm\">equivalence class</em></a> under some\n<a class=\"reference internal\" href=\"#term-equivalence-relation\"><em class=\"xref std std-term ODSAterm\">equivalence relation</em></a>.</dd>", "cohesion": "<dd>In <a class=\"reference internal\" href=\"#term-object-oriented-programming-paradigm\"><em class=\"xref std std-term ODSAterm\">object-oriented programming</em></a>,\na term that refers to the degree to which a class has a single\nwell-defined role or responsibility.</dd>", "depth": "<dd>The depth of a node <span class=\"math\">\\(M\\)</span> in a tree is the length\nof the path from the root of the tree to <span class=\"math\">\\(M\\)</span>.</dd>", "AVL Tree": "<dd>A variant implementation for the <a class=\"reference internal\" href=\"#term-bst\"><em class=\"xref std std-term ODSAterm\">BST</em></a>, which differs from\nthe standard BST in that it uses modified insert and remove\nmethods in order to keep the tree\n<a class=\"reference internal\" href=\"#term-balanced-tree\"><em class=\"xref std std-term ODSAterm\">balanced</em></a>.\nSimilar to a <a class=\"reference internal\" href=\"#term-splay-tree\"><em class=\"xref std std-term ODSAterm\">Splay Tree</em></a> in that it uses the concept of\n<a class=\"reference internal\" href=\"#term-rotation\"><em class=\"xref std std-term ODSAterm\">rotations</em></a> in the insert and remove operations.</dd>", "spatial data structure": "<dd>A <a class=\"reference internal\" href=\"#term-data-structure\"><em class=\"xref std std-term ODSAterm\">data structure</em></a> designed to support efficient\nprocessing when a\n<a class=\"reference internal\" href=\"#term-spatial-attribute\"><em class=\"xref std std-term ODSAterm\">spatial attribute</em></a> is used as the key.\nIn particular, a data structure that supports efficient search\nby location, or finds all records within a given region in two\nor more dimensions.\nExamples of spatial data structures to store point data include\nthe <a class=\"reference internal\" href=\"#term-bintree\"><em class=\"xref std std-term ODSAterm\">bintree</em></a>, the <a class=\"reference internal\" href=\"#term-pr-quadtree\"><em class=\"xref std std-term ODSAterm\">PR quadtree</em></a> and the\n<a class=\"reference internal\" href=\"#term-kd-tree\"><em class=\"xref std std-term ODSAterm\">kd tree</em></a>.</dd>", "caching": "<dd>The concept of keeping selected data in <a class=\"reference internal\" href=\"#term-main-memory\"><em class=\"xref std std-term ODSAterm\">main memory</em></a>.\nThe goal is to have in main memory the data values that are\nmost likely to be used in the near future.\nAn example of a caching technique is the use of a\n<a class=\"reference internal\" href=\"#term-buffer-pool\"><em class=\"xref std std-term ODSAterm\">buffer pool</em></a>.</dd>", "vertices <vertex>": "", "NP-hard": "<dd>A problem that is &quot;as hard as&quot; any other problem in <a class=\"reference internal\" href=\"#term-np\"><em class=\"xref std std-term ODSAterm\">NP</em></a>.\nThat is, Problem X is NP-hard if any algorithm in NP can be\n<a class=\"reference internal\" href=\"#term-reduction\"><em class=\"xref std std-term ODSAterm\">reduced</em></a> to X in polynomial time.</dd>", "local variable": "", "AVL tree": ""}}