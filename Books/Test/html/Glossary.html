
<!DOCTYPE html>




<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>2.1. Glossary &mdash; Test</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/normalize.css" type="text/css" />
    <link rel="stylesheet" href="../../../JSAV/css/JSAV.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/odsaMOD-min.css" type="text/css" />
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.11.4/themes/smoothness/jquery-ui.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/odsaStyle-min.css" type="text/css" />
    
  <script type="text/javascript">
    var DOCUMENTATION_OPTIONS = {
      URL_ROOT:    './',
      VERSION:     '0.4.1',
      COLLAPSE_INDEX: false,
      FILE_SUFFIX: '.html',
      HAS_SOURCE:  true
    };
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
      },
      "HTML-CSS": {
        scale: "80"
      }
    });
  </script>
    <link rel="index" title="Test" href="index.html" />
    <link rel="next" title="2. Bibliography" href="Bibliography.html" />
    <link rel="prev" title="1. Heap Memory" href="HeapMem.html" />

  </head>

  <body>


      <div class="header">
        
  
      <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
      <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="https://code.jquery.com/ui/1.11.4/jquery-ui.min.js"></script>
    <script type="text/javascript" src="../../../JSAV/lib/jquery.transit.js"></script>
    <script type="text/javascript" src="../../../JSAV/lib/raphael.js"></script>
    <script type="text/javascript" src="../../../JSAV/build/JSAV-min.js"></script>
    <script type="text/javascript" src="_static/config.js"></script>
    <script type="text/javascript" src="../../../lib/odsaUtils-min.js"></script>
    <script type="text/javascript" src="../../../lib/odsaMOD-min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js"></script>
    <script type="text/javascript" src="../../../lib/dataStructures.js"></script>
    <script type="text/javascript" src="../../../lib/conceptMap.js"></script>

        
<a id="username-link" style="float:right;color:red;margin:10px 20px auto; display: none" class="username-link" href="Gradebook.html"></a>
<a id="login-link" style="float:right;color:red;margin:10px 20px auto" class="login-link" href="#"><Macro 'login'></a>
<div id="login-box" class="login-popup">
  <a href="#" class="close"><img src="_static/Images/close_pop.png" class="btn_close" title="Close Window" alt="Close" /></a>
  <form method="post" class="signin" action="https://#">
    <fieldset class="textbox">
      <label class="username">
        <span>Username</span>
        <input id="username" value="" type="text" autocomplete="on" placeholder="Username" tabindex="1">
      </label>
      <label class="password">
        <span>Password</span>
        <input id="password" value="" type="password" placeholder="Password" tabindex="2">
        <span><a id="forgot" href="#">Forgot your password?</a></span>
      </label>

      <p>
        <input type="submit" id="login-submit-button" value="Sign in" tabindex="3" />
      </p>
      <p>
        <input type="button" id="register-button" value="Register" tabindex="4" />
      </p>
    </fieldset>
  </form>
</div>

        
<a id="registration-link" style="float:right;color:red;margin:10px 20px auto" class="registration-link" href="#">Register</a>
<div id="registration-box" class="registration-popup ">
  <a href="#" class="close"><img src="_static/Images/close_pop.png" class="btn_close" title="Close Window" alt="Close Window" /></a>
  <form method="post" class="signin" action="https://#">
    <fieldset class="textbox">
      <div id="register_error" class="error"></div>
      <label class="username">
        <span>Username:</span>
        <input type="text" id="user" placeholder="Username" />
      </label>

      <label class="password">
        <span>Password</span>
        <input id="pass" type="password" placeholder="Password" />
      </label>

      <label class="password">
        <span>Confirm Password</span>
        <input id="rpass" type="password" placeholder="Confirm Password" />
      </label>

      <label class="email">
        <span>Email:</span>
        <input type="text" id="email" placeholder="Email">
      </label>

      <p>
        <input type="submit" id="register-submit-button" value="Register &rarr;"/>
      </p>
    </fieldset>
  </form>
</div>
<img class="leftlogo" src="_static/OpenDSALogoT64.png" alt="Logo"/><div class="title-wrapper">
          <div class="title-inbetween" style="display: table-cell; vertical-align: middle;">
            <div class="title-content">
              <h1 class="heading" ><a href="index.html">
                <span>Test</span></a></h1>
              <h2 class="heading" ><span>Chapter 2 Appendix</span></h2>
            </div>
          </div>
        </div>
      </div>
      <div class="topnav">
        <p>
            <a style="float:left;color:blue;" href="../source/Glossary.rst"
              target="_blank" rel="nofollow">Show Source | </a>&#160;&#160;
            <a class="abt" style="float:left;color:blue;" href="#" rel="nofollow">| About</a>&#160;&#160;

          
        «&#160;&#160;<a id="prevmod" href="HeapMem.html">1.1. Heap Memory</a>
        &#160;&#160;::&#160;&#160;
        <a  class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a  id="nextmod" href="Bibliography.html">2.2. Bibliography</a>&#160;&#160;»


        </p>
      </div>
       
      <div class="content">
        
  <script>ODSA.SETTINGS.DISP_MOD_COMP = true;ODSA.SETTINGS.MODULE_NAME = "Glossary";ODSA.SETTINGS.MODULE_LONG_NAME = "Glossary";ODSA.SETTINGS.MODULE_CHAPTER = "Appendix"; ODSA.SETTINGS.BUILD_DATE = "2017-10-25 15:09:37"; ODSA.SETTINGS.BUILD_CMAP = false;JSAV_OPTIONS['lang']='en';JSAV_EXERCISE_OPTIONS['code']='java_generic';</script><div class="section" id="id1">
<h1>2.1. Glossary<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<dl class="glossary docutils">
<dt id="term-tree">2-3 tree</dt>
<dd>A specialized form of the <a class="reference internal" href="#term-37"><em class="xref std std-term ODSAterm">B-tree</em></a> where each internal
node has either 2 children or 3 children.
Key values are ordered to maintain the
<a class="reference internal" href="#term-binary-search-tree-property"><em class="xref std std-term ODSAterm">binary search tree property</em></a>.
The 2-3 tree is always height balanced, and its insert, search,
and remove operations all have <span class="math">\(\Theta(\log n)\)</span> cost.</dd>
<dt id="term-rule">80/20 rule</dt>
<dd>Given a typical application where there is a collection of
records and a series of search operations for records,
the 80/20 rule is an empirical observation that
80% of the record accessess typically go to 20% of the records.
The exact values varies between data collections, and is related
to the concept of <a class="reference internal" href="#term-locality-of-reference"><em class="xref std std-term ODSAterm">locality of reference</em></a>.</dd>
<dt id="term-abstract-data-type">abstract data type</dt>
<dd>Abbreviated <a class="reference internal" href="#term-adt"><em class="xref std std-term ODSAterm">ADT</em></a>. The specification of a <a class="reference internal" href="#term-data-type"><em class="xref std std-term ODSAterm">data type</em></a>
within some language, independent of an implementation.
The interface for the ADT is defined in terms of a <a class="reference internal" href="#term-type"><em class="xref std std-term ODSAterm">type</em></a>
and a set of operations on that type.
The behavior of each operation is determined by its inputs and
outputs.
An ADT does not specify <em>how</em> the data type is implemented.
These implementation details are hidden from the user of the ADT
and protected from outside access, a concept referred to as
<a class="reference internal" href="#term-encapsulation"><em class="xref std std-term ODSAterm">encapsulation</em></a>.</dd>
<dt id="term-activation-record">activation record</dt>
<dd>The entity that is stored on the <a class="reference internal" href="#term-runtime-stack"><em class="xref std std-term ODSAterm">runtime stack</em></a> during
program execution.
It stores any active <a class="reference internal" href="#term-local-variable"><em class="xref std std-term ODSAterm">local variable</em></a> and the return
address from which a new subroutine is being called, so that
this information can be recovered when the subroutine
terminates.</dd>
<dt id="term-acyclic-graph">acyclic graph</dt>
<dd>In <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> terminology, a graph that contains no
<a class="reference internal" href="#term-cycle"><em class="xref std std-term ODSAterm">cycles</em></a>.</dd>
<dt id="term-address">address</dt>
<dd>A location in memory.</dd>
<dt id="term-adjacency-list">adjacency list</dt>
<dd>An implementation for a <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> that uses an (array-based)
<a class="reference internal" href="#term-list"><em class="xref std std-term ODSAterm">list</em></a> to represent the <a class="reference internal" href="#term-vertex"><em class="xref std std-term ODSAterm">vertices</em></a> of the
graph, and each vertex is in turn represented by a
(linked) list of the vertices that are
<a class="reference internal" href="#term-neighbor"><em class="xref std std-term ODSAterm">neighbors</em></a>.</dd>
<dt id="term-adjacency-matrix">adjacency matrix</dt>
<dd>An implementation for a <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> that uses a 2-dimensional
array where each row and each column corresponds to a
<a class="reference internal" href="#term-vertex"><em class="xref std std-term ODSAterm">vertex</em></a> in the <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a>. A given row and column in
the matrix corresponds to an edge from the <a class="reference internal" href="#term-vertex"><em class="xref std std-term ODSAterm">vertex</em></a>
corresponding to the row to the vertex corresponding to the
column.</dd>
<dt id="term-adjacent">adjacent</dt>
<dd>Two <a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">nodes</em></a> of a <a class="reference internal" href="#term-577"><em class="xref std std-term ODSAterm">tree</em></a> or two
<a class="reference internal" href="#term-vertex"><em class="xref std std-term ODSAterm">vertices</em></a> of a <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> are said to be
adjacent if they have an <a class="reference internal" href="#term-edge"><em class="xref std std-term ODSAterm">edge</em></a> connecting them.
If the edge is directed from <span class="math">\(a\)</span> to <span class="math">\(b\)</span>,
then we say that <span class="math">\(a\)</span> is adjacent to <span class="math">\(b\)</span>,
and <span class="math">\(b\)</span> is adjacent from <span class="math">\(a\)</span>.</dd>
<dt id="term-adt">ADT</dt>
<dd>Abbreviation for <a class="reference internal" href="#term-abstract-data-type"><em class="xref std std-term ODSAterm">abstract data type</em></a>.</dd>
<dt id="term-adversary">adversary</dt>
<dd>A fictional construct introduced for use in an
<a class="reference internal" href="#term-adversary-argument"><em class="xref std std-term ODSAterm">adversary argument</em></a>.</dd>
<dt id="term-adversary-argument">adversary argument</dt>
<dd>A type of <a class="reference internal" href="#term-lower-bounds-proof"><em class="xref std std-term ODSAterm">lower bounds proof</em></a> for a problem where a
(fictional) &quot;adversary&quot; is assumed to control access to an
algorithm's input, and which yields information about that input
in such a way
that will drive the cost for any proposed algorithm to solve the
problem as high as possible.
So long as the adversary never gives an answer that conflicts
with any previous answer, it is permitted to do whatever
necessary to make the algorithm require as much cost as
possible.</dd>
<dt id="term-aggregate-type">aggregate type</dt>
<dd>A <a class="reference internal" href="#term-data-type"><em class="xref std std-term ODSAterm">data type</em></a> whose <a class="reference internal" href="#term-member"><em class="xref std std-term ODSAterm">members</em></a> have subparts.
For example, a typical database record.
Another term for this is <a class="reference internal" href="#term-composite-type"><em class="xref std std-term ODSAterm">composite type</em></a>.</dd>
<dt id="term-algorithm">algorithm</dt>
<dd>A method or a process followed to solve a <a class="reference internal" href="#term-problem"><em class="xref std std-term ODSAterm">problem</em></a>.</dd>
<dt id="term-algorithm-analysis">algorithm analysis</dt>
<dd>A less formal version of the term
<a class="reference internal" href="#term-asymptotic-algorithm-analysis"><em class="xref std std-term ODSAterm">asymptotic algorithm analysis</em></a>, generally used as a
synonym for <a class="reference internal" href="#term-asymptotic-analysis"><em class="xref std std-term ODSAterm">asymptotic analysis</em></a>.</dd>
<dt id="term-all-pairs-shortest-paths-problem">all-pairs shortest paths problem</dt>
<dd>Given a <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> with <a class="reference internal" href="#term-weight"><em class="xref std std-term ODSAterm">weights</em></a> or
distances on the <a class="reference internal" href="#term-edge"><em class="xref std std-term ODSAterm">edges</em></a>,
find the shortest paths between every pair of
vertices in the graph.
One approach to solving this problem is
<a class="reference internal" href="#term-floyd-s-algorithm"><em class="xref std std-term ODSAterm">Floyd's algorithm</em></a>, which uses the
<a class="reference internal" href="#term-dynamic-programming"><em class="xref std std-term ODSAterm">dynamic programming</em></a> algorithmic technique.</dd>
<dt id="term-allocated"><span id="term-allocation"></span>allocated<br />allocation</dt>
<dd>Reserving memory for an object in the Heap memory.</dd>
<dt id="term-alphabet-trie">alphabet trie</dt>
<dd>A <a class="reference internal" href="#term-trie"><em class="xref std std-term ODSAterm">trie</em></a> data structure for storing variable-length
strings.
Level <span class="math">\(i\)</span> of the tree corresponds to the letter in
position <span class="math">\(i\)</span> of the string.
The root will have potential branches on each intial letter of
string.
Thus, all strings starting with &quot;a&quot; will be stored in the &quot;a&quot;
branch of the tree.
At the second level, such strings will be separated by branching
on the second letter.</dd>
<dt id="term-amortized-analysis">amortized analysis</dt>
<dd>An <a class="reference internal" href="#term-algorithm-analysis"><em class="xref std std-term ODSAterm">algorithm analysis</em></a> techique that looks at the total
cost for a series of operations and amortizes this total cost
over the full series.
This is as opposed to considering every individual operation to
independently have the <a class="reference internal" href="#term-worst-case"><em class="xref std std-term ODSAterm">worst case</em></a> cost, which might lead
to an overestimate for the total cost of the series.</dd>
<dt id="term-amortized-cost">amortized cost</dt>
<dd>The total cost for a series of operations to be used in an
<a class="reference internal" href="#term-amortized-analysis"><em class="xref std std-term ODSAterm">amortized analysis</em></a>.</dd>
<dt id="term-ancestor">ancestor</dt>
<dd>In a tree, for a given node <span class="math">\(A\)</span>, any node on a
<a class="reference internal" href="#term-path"><em class="xref std std-term ODSAterm">path</em></a> from <span class="math">\(A\)</span> up to the root is an ancestor of
<span class="math">\(A\)</span>.</dd>
<dt id="term-antisymmetric">antisymmetric</dt>
<dd>In set notation, relation <span class="math">\(R\)</span> is antisymmetric if whenever
<span class="math">\(aRb\)</span> and <span class="math">\(bRa\)</span>, then <span class="math">\(a = b\)</span>, for all
<span class="math">\(a, b \in \mathbf{S}\)</span>.</dd>
<dt id="term-arm">arm</dt>
<dd>In the context of an <a class="reference internal" href="#term-i-o-head"><em class="xref std std-term ODSAterm">I/O head</em></a>, this attaches the sensor
on the I/O head to the <a class="reference internal" href="#term-boom"><em class="xref std std-term ODSAterm">boom</em></a>.</dd>
<dt id="term-array-based-list">array-based list</dt>
<dd>An implementation for the <a class="reference internal" href="#term-list"><em class="xref std std-term ODSAterm">list</em></a> ADT that uses an array to
store the list elements. Typical implementations fix the array
size at creation of the list, and the <a class="reference internal" href="#term-overhead"><em class="xref std std-term ODSAterm">overhead</em></a>
is the number of array positions that are presently unused.</dd>
<dt id="term-array-based-queue">array-based queue</dt>
<dd>Analogous to an <a class="reference internal" href="#term-array-based-list"><em class="xref std std-term ODSAterm">array-based list</em></a>, this uses an array to
store the elements when implementing the <a class="reference internal" href="#term-queue"><em class="xref std std-term ODSAterm">queue</em></a> ADT.</dd>
<dt id="term-array-based-stack">array-based stack</dt>
<dd>Analogous to an <a class="reference internal" href="#term-array-based-list"><em class="xref std std-term ODSAterm">array-based list</em></a>, this uses an array to
store the elements when implementing the <a class="reference internal" href="#term-stack"><em class="xref std std-term ODSAterm">stack</em></a> ADT.</dd>
<dt id="term-ascii-character-coding">ASCII character coding</dt>
<dd>American Standard Code for Information Interchange.
A commonly used method for encoding characters using a binary code.
Standard ASCII uses an 8-bit code to represent upper and lower
case letters, digits, some punctuation, and some number of
non-printing characters (such as carrage return).
Now largely replaced by UTF-8 encoding.</dd>
<dt id="term-asymptotic-algorithm-analysis">asymptotic algorithm analysis</dt>
<dd>A more formal term for <a class="reference internal" href="#term-asymptotic-analysis"><em class="xref std std-term ODSAterm">asymptotic analysis</em></a>.</dd>
<dt id="term-asymptotic-analysis">asymptotic analysis</dt>
<dd>A method for estimating the efficiency of an algorithm or
computer program by identifying its <a class="reference internal" href="#term-growth-rate"><em class="xref std std-term ODSAterm">growth rate</em></a>.
Asymptotic analysis also gives a way to
define the inherent difficulty of a <a class="reference internal" href="#term-problem"><em class="xref std std-term ODSAterm">problem</em></a>.
We frequently use the term <a class="reference internal" href="#term-algorithm-analysis"><em class="xref std std-term ODSAterm">algorithm analysis</em></a> to mean
the same thing.</dd>
<dt id="term-attribute">attribute</dt>
<dd>In <a class="reference internal" href="#term-object-oriented-programming-paradigm"><em class="xref std std-term ODSAterm">object-oriented programming</em></a>,
a synonym for <a class="reference internal" href="#term-data-member"><em class="xref std std-term ODSAterm">data member</em></a>.</dd>
<dt id="term-automatic-variable">automatic variable</dt>
<dd>A synonym for <a class="reference internal" href="#term-local-variable"><em class="xref std std-term ODSAterm">local variable</em></a>.
When program flow enters and leaves the variable's scope,
automatic variables will be allocated and de-allocated
automatically.</dd>
<dt id="term-average-case">average case</dt>
<dd>In <a class="reference internal" href="#term-algorithm-analysis"><em class="xref std std-term ODSAterm">algorithm analysis</em></a>, the average of the costs for all
<a class="reference internal" href="#term-problem-instance"><em class="xref std std-term ODSAterm">problem instances</em></a> of a given input
size <span class="math">\(n\)</span>. If not all problem
instances have equal probability of occurring, then average case
must be calculated using a weighted average.</dd>
<dt id="term-average-seek-time">average seek time</dt>
<dd>Expected (average) time to perform a <a class="reference internal" href="#term-seek"><em class="xref std std-term ODSAterm">seek</em></a> operation on a
<a class="reference internal" href="#term-disk-drive"><em class="xref std std-term ODSAterm">disk drive</em></a>, assuming that the seek is between two
randomly selected tracks.
This is one of two metrics commonly provided by disk drive
vendors for disk drive performance, with the other being
<a class="reference internal" href="#term-track-to-track-seek-time"><em class="xref std std-term ODSAterm">track-to-track seek time</em></a>.</dd>
<dt id="term-avl-tree">AVL Tree</dt>
<dd>A variant implementation for the <a class="reference internal" href="#term-bst"><em class="xref std std-term ODSAterm">BST</em></a>, which differs from
the standard BST in that it uses modified insert and remove
methods in order to keep the tree
<a class="reference internal" href="#term-balanced-tree"><em class="xref std std-term ODSAterm">balanced</em></a>.
Similar to a <a class="reference internal" href="#term-splay-tree"><em class="xref std std-term ODSAterm">Splay Tree</em></a> in that it uses the concept of
<a class="reference internal" href="#term-rotation"><em class="xref std std-term ODSAterm">rotations</em></a> in the insert and remove operations.</dd>
<dt id="term-36">B$^*$-tree</dt>
<dd>A variant on the <a class="reference internal" href="#term-b-tree"><em class="xref std std-term ODSAterm">B$^+$-tree</em></a>.
The <span class="math">\(\mathrm{B}^*\)</span> tree is identical to the <span class="math">\(\mathrm{B}^+\)</span>
tree, except for the rules used to split and merge nodes.
Instead of splitting a node in half when it overflows, the
<span class="math">\(\mathrm{B}^*\)</span> tree
gives some records to its neighboring sibling, if possible.
If the sibling is also full, then these two nodes split into three.
Similarly, when a node underflows, it is combined with its two
siblings, and the total reduced to two nodes.
Thus, the nodes are always at least two thirds full.</dd>
<dt id="term-b-tree">B$^+$-tree</dt>
<dd>The most commonly implemented form of <a class="reference internal" href="#term-37"><em class="xref std std-term ODSAterm">B-tree</em></a>.
A B$^+$-tree does not store data at the
<a class="reference internal" href="#term-internal-node"><em class="xref std std-term ODSAterm">internal nodes</em></a>, but
instead only stores <a class="reference internal" href="#term-search-key"><em class="xref std std-term ODSAterm">search key</em></a> values as direction
finders for the purpose of searching through the tree.
Only the <a class="reference internal" href="#term-leaf-node"><em class="xref std std-term ODSAterm">leaf nodes</em></a> store a reference to the
actual data records.</dd>
<dt id="term-37">B-tree</dt>
<dd>A method for <a class="reference internal" href="#term-indexing"><em class="xref std std-term ODSAterm">indexing</em></a> a large collection of records.
A B-tree is a <a class="reference internal" href="#term-balanced-tree"><em class="xref std std-term ODSAterm">balanced tree</em></a> that typically has high
branching factor (commonly as much as 100
<a class="reference internal" href="#term-child"><em class="xref std std-term ODSAterm">children</em></a> per <a class="reference internal" href="#term-internal-node"><em class="xref std std-term ODSAterm">internal node</em></a>),
causing the tree to be very shallow.
When stored on disk, the node size is selected to be same as the
desired unit of I/O (so some multiple of the disk <a class="reference internal" href="#term-sector"><em class="xref std std-term ODSAterm">sector</em></a>
size).
This makes it easy to gain access to the record associated with
a given <a class="reference internal" href="#term-search-key"><em class="xref std std-term ODSAterm">search key</em></a> stored in the tree with few
<a class="reference internal" href="#term-disk-access"><em class="xref std std-term ODSAterm">disk accesses</em></a>.
The most commonly implemented variant of the B-tree is the
<a class="reference internal" href="#term-b-tree"><em class="xref std std-term ODSAterm">B$^+$-tree</em></a>.</dd>
<dt id="term-backing-storage">backing storage</dt>
<dd>In the context of a <a class="reference internal" href="#term-caching"><em class="xref std std-term ODSAterm">caching</em></a> system or
<a class="reference internal" href="#term-buffer-pool"><em class="xref std std-term ODSAterm">buffer pool</em></a>, backing storage is the relatively large but
slower source of data that needs to be cached.
For example, in a <a class="reference internal" href="#term-virtual-memory"><em class="xref std std-term ODSAterm">virtual memory</em></a>, the disk drive would
be the backing storage.
In the context of a web browser, the Internet might be
considered the backing storage.</dd>
<dt id="term-bag">bag</dt>
<dd>In set notation, a bag is a collection of elements with no order
(like a set), but which allows for duplicate-valued elements
(unlike a set).</dd>
<dt id="term-balanced-tree">balanced tree</dt>
<dd>A <a class="reference internal" href="#term-577"><em class="xref std std-term ODSAterm">tree</em></a> where the <a class="reference internal" href="#term-subtree"><em class="xref std std-term ODSAterm">subtrees</em></a> meet some
criteria for being balanced.
Two possibilities are that the tree is
<a class="reference internal" href="#term-height-balanced"><em class="xref std std-term ODSAterm">height balanced</em></a>, or that the tree has a roughly equal
number of <a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">nodes</em></a> in each subtree.</dd>
<dt id="term-base">base</dt>
<dd>Synonym for <a class="reference internal" href="#term-radix"><em class="xref std std-term ODSAterm">radix</em></a>.</dd>
<dt id="term-base-case">base case</dt>
<dd>In <a class="reference internal" href="#term-recursion"><em class="xref std std-term ODSAterm">recursion</em></a> or <a class="reference internal" href="#term-proof-by-induction"><em class="xref std std-term ODSAterm">proof by induction</em></a>, the base case
is the termination condition.
This is a simple input or value that can be solved (or proved in
the case of induction) without resorting to a recursive call
(or the <a class="reference internal" href="#term-induction-hypothesis"><em class="xref std std-term ODSAterm">induction hypothesis</em></a>).</dd>
<dt id="term-base-class">base class</dt>
<dd>In <a class="reference internal" href="#term-object-oriented-programming-paradigm"><em class="xref std std-term ODSAterm">object-oriented programming</em></a>,
a class from which another class <a class="reference internal" href="#term-inherit"><em class="xref std std-term ODSAterm">inherits</em></a>.
The class that inherits is called a <a class="reference internal" href="#term-subclass"><em class="xref std std-term ODSAterm">subclass</em></a>.</dd>
<dt id="term-base-type">base type</dt>
<dd>The <a class="reference internal" href="#term-data-type"><em class="xref std std-term ODSAterm">data type</em></a> for the elements in a set.
For example, the set might consist of the integer values 3, 5,
and 7.
In this example, the base type is integers.</dd>
<dt id="term-basic-operation">basic operation</dt>
<dd>Examples of basic operations include inserting a data
item into the data structure, deleting a data item from the
data structure, and finding a specified data item.</dd>
<dt id="term-best-case">best case</dt>
<dd>In algorithm analysis, the <a class="reference internal" href="#term-problem-instance"><em class="xref std std-term ODSAterm">problem instance</em></a> from among
all problem instances for a given input size <span class="math">\(n\)</span> that has
least cost. Note that the best case is <strong>not</strong> when <span class="math">\(n\)</span> is
small, since we are referring to the best from a class of inputs
(i.e, those inputs of size <span class="math">\(n\)</span>).</dd>
<dt id="term-best-fit">best fit</dt>
<dd>In a <a class="reference internal" href="#term-memory-manager"><em class="xref std std-term ODSAterm">memory manager</em></a>, best fit is a <a class="reference internal" href="#term-heuristic"><em class="xref std std-term ODSAterm">heuristic</em></a>
for deciding which <a class="reference internal" href="#term-free-block"><em class="xref std std-term ODSAterm">free block</em></a> to use when allocating
memory from a <a class="reference internal" href="#term-memory-pool"><em class="xref std std-term ODSAterm">memory pool</em></a>.
Best fit will always allocate from the smallest
<a class="reference internal" href="#term-free-block"><em class="xref std std-term ODSAterm">free block</em></a> that is large enough to service the memory
request.
The rationale is that this will be the method that best
preserves large blocks needed for unusually large requests.
The disadvantage is that it tends to
cause <a class="reference internal" href="#term-external-fragmentation"><em class="xref std std-term ODSAterm">external fragmentation</em></a> in the form of small,
unuseable memory blocks.</dd>
<dt id="term-bfs">BFS</dt>
<dd>Abbreviation for <a class="reference internal" href="#term-breadth-first-search"><em class="xref std std-term ODSAterm">breadth-first search</em></a>.</dd>
<dt id="term-big-oh-notation">big-Oh notation</dt>
<dd>In <a class="reference internal" href="#term-algorithm-analysis"><em class="xref std std-term ODSAterm">algorithm analysis</em></a>, a shorthand notation for
describing the <a class="reference internal" href="#term-upper-bound"><em class="xref std std-term ODSAterm">upper bound</em></a> for an <a class="reference internal" href="#term-algorithm"><em class="xref std std-term ODSAterm">algorithm</em></a> or
<a class="reference internal" href="#term-problem"><em class="xref std std-term ODSAterm">problem</em></a>.</dd>
<dt id="term-binary-search">binary search</dt>
<dd>A standard <a class="reference internal" href="#term-recursion"><em class="xref std std-term ODSAterm">recursive</em></a> algorithm for finding
the <a class="reference internal" href="#term-record"><em class="xref std std-term ODSAterm">record</em></a> with a given <a class="reference internal" href="#term-search-key"><em class="xref std std-term ODSAterm">search key</em></a> value within
a sorted list.
It runs in <span class="math">\(O(\log n)\)</span> time.
At each step, look at the middle of the current sublist, and throw
away the half of the records whose keys are either too small or
too large.</dd>
<dt id="term-binary-search-tree">binary search tree</dt>
<dd>A binary tree that imposes the following constraint on its node
values: The <a class="reference internal" href="#term-search-key"><em class="xref std std-term ODSAterm">search key</em></a> value for any node <span class="math">\(A\)</span> must
be greater than the (key) values for all nodes in the left
<a class="reference internal" href="#term-subtree"><em class="xref std std-term ODSAterm">subtree</em></a> of <span class="math">\(A\)</span>, and less than the key values for
all nodes in the right subtree of <span class="math">\(A\)</span>.
Some convention must be adopted if
multiple nodes with the same key value are permitted,
typically these are required to be in the right subtree.</dd>
<dt id="term-binary-search-tree-property">binary search tree property</dt>
<dd>The defining relationship between the <a class="reference internal" href="#term-key"><em class="xref std std-term ODSAterm">key</em></a> values for
<a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">nodes</em></a> in a <a class="reference internal" href="#term-bst"><em class="xref std std-term ODSAterm">BST</em></a>.
All nodes stored in the left subtree of a node whose key value
is <span class="math">\(K\)</span> have key values less than or equal to <span class="math">\(K\)</span>.
All nodes stored in the right subtree of a node whose key value
is <span class="math">\(K\)</span> have key values greater than <span class="math">\(K\)</span>.</dd>
<dt id="term-binary-tree">binary tree</dt>
<dd>A finite set of nodes which is either empty, or else has a root
node together two binary trees, called the left and right
<a class="reference internal" href="#term-subtree"><em class="xref std std-term ODSAterm">subtrees</em></a>, which are <a class="reference internal" href="#term-disjoint"><em class="xref std std-term ODSAterm">disjoint</em></a> from each
other and from the <a class="reference internal" href="#term-root"><em class="xref std std-term ODSAterm">root</em></a>.</dd>
<dt id="term-binary-trie">binary trie</dt>
<dd>A <a class="reference internal" href="#term-binary-tree"><em class="xref std std-term ODSAterm">binary tree</em></a> whose structure is that of a <a class="reference internal" href="#term-trie"><em class="xref std std-term ODSAterm">trie</em></a>.
Generally this is an implementation for a <a class="reference internal" href="#term-search-tree"><em class="xref std std-term ODSAterm">search tree</em></a>.
This means that the <a class="reference internal" href="#term-search-key"><em class="xref std std-term ODSAterm">search key</em></a> values are thought of a
binary digits, with the digit in the position corresponding to
this a node's <a class="reference internal" href="#term-level"><em class="xref std std-term ODSAterm">level</em></a> in the tree indicating a left branch
if it is &quot;0&quot;, or a right branch if it is &quot;1&quot;.
Examples include the <a class="reference internal" href="#term-huffman-coding-tree"><em class="xref std std-term ODSAterm">Huffman coding tree</em></a> and the
<a class="reference internal" href="#term-bintree"><em class="xref std std-term ODSAterm">Bintree</em></a>.</dd>
<dt id="term-binning">binning</dt>
<dd>In <a class="reference internal" href="#term-hashing"><em class="xref std std-term ODSAterm">hashing</em></a>, binning is a type of <a class="reference internal" href="#term-hash-function"><em class="xref std std-term ODSAterm">hash function</em></a>.
Say we are given keys in the range 0 to 999, and have a hash
table of size 10.
In this case, a possible hash function might simply divide the
key value by 100.
Thus, all keys in the range 0 to 99 would hash to slot 0, keys
100 to 199 would hash to slot 1, and so on.
In other words, this hash function &quot;bins&quot; the first 100 keys to
the first slot, the next 100 keys to the second slot, and so
on.
This approach tends to make the hash function dependent on the
distribution of the high-order bits of the keys.</dd>
<dt id="term-binsort">Binsort</dt>
<dd>A sort that works by taking each record and placing it into a
bin based on its value. The bins are then gathered up in order
to sort the list. It is generally not practical in this form,
but it is the conceptual underpinning of the <a class="reference internal" href="#term-radix-sort"><em class="xref std std-term ODSAterm">radix sort</em></a>.</dd>
<dt id="term-bintree">bintree</dt>
<dd>A <a class="reference internal" href="#term-spatial-data-structure"><em class="xref std std-term ODSAterm">spatial data structure</em></a> in the form of binary
<a class="reference internal" href="#term-trie"><em class="xref std std-term ODSAterm">trie</em></a>, typically used to store point data in two or more
dimensions.
Similar to a <a class="reference internal" href="#term-pr-quadtree"><em class="xref std std-term ODSAterm">PR quadtree</em></a> except that at each level, it
splits one dimension in half.
Since many leaf nodes of the PR quadtree will contain no data
points, implementation often makes use of the <a class="reference internal" href="#term-flyweight"><em class="xref std std-term ODSAterm">flyweight</em></a>
<a class="reference internal" href="#term-design-pattern"><em class="xref std std-term ODSAterm">design pattern</em></a>.</dd>
<dt id="term-block">block</dt>
<dd>A unit of storage, usually referring to storage on a
<a class="reference internal" href="#term-disk-drive"><em class="xref std std-term ODSAterm">disk drive</em></a> or other <a class="reference internal" href="#term-peripheral-storage"><em class="xref std std-term ODSAterm">peripheral storage</em></a> device.
A block is the basic unit of I/O for that device.</dd>
<dt id="term-boolean-variable">Boolean variable</dt>
<dd>A variable that takes on one of the two values <code class="docutils literal"><span class="pre">True</span></code> and
<code class="docutils literal"><span class="pre">False</span></code>.</dd>
<dt id="term-boom">boom</dt>
<dd>In the context of an <a class="reference internal" href="#term-i-o-head"><em class="xref std std-term ODSAterm">I/O head</em></a>, is the central structure
to which all of the I/O heads are attached.
Thus, the all move together during a <a class="reference internal" href="#term-seek"><em class="xref std std-term ODSAterm">seek</em></a> operation.</dd>
<dt id="term-bounding-box">bounding box</dt>
<dd>A box (usually aligned to the coordinate axes of the reference
system) that contains a (potentially complex) object. In
graphics and computational geometry, complex objects might be
associated with a bounding box for use by algorithms that search
for objects in a particular location. The idea is that if the
bounding box is not within the area of interest, then neither is
the object. Checking the bounding box is cheaper than checking
the object, but it does require some time. So if enough objects
are not outside the area of interest, this approach will not
save time. But if most objects are outside of the area of
interest, then checking bounding boxes first can save a lot of
time.</dd>
<dt id="term-breadth-first-search">breadth-first search</dt>
<dd>A <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> <a class="reference internal" href="#term-traversal"><em class="xref std std-term ODSAterm">traversal</em></a> algorithm.
As the name implies, all immediate <a class="reference internal" href="#term-neighbor"><em class="xref std std-term ODSAterm">neighbors</em></a>
for a <a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">node</em></a> are <a class="reference internal" href="#term-visit"><em class="xref std std-term ODSAterm">visited</em></a> before any
more-distant nodes are visited.
BFS is driven by a <a class="reference internal" href="#term-queue"><em class="xref std std-term ODSAterm">queue</em></a>.
A start vertex is placed on the queue.
Then, until the queue is empty, a node is taken off the
queue, visited, and and then any <a class="reference internal" href="#term-unvisited"><em class="xref std std-term ODSAterm">unvisited</em></a> neighbors are
placed onto the queue.</dd>
<dt id="term-break-even-point">break-even point</dt>
<dd>The point at which two costs become even when measured as the
function of some variable.
In particular, used to compare the space requirements of two
implementations.
For example, when comparing the space requirements of an
<a class="reference internal" href="#term-array-based-list"><em class="xref std std-term ODSAterm">array-based list</em></a> implementation versus a
<a class="reference internal" href="#term-linked-list"><em class="xref std std-term ODSAterm">linked list</em></a> implementation, the key issue is how full
the list is compared to its capacity limit (for the array-based
list).
The point where the two representations would have the same
space cost is the break-even point.
As the list becomes more full beyond this point, the array-based
list implementation becomes more space efficent, while as the
list becomes less full below this point, the linked list
implementation becomes more space efficient.</dd>
<dt id="term-bst">BST</dt>
<dd>Abbreviation for <a class="reference internal" href="#term-binary-search-tree"><em class="xref std std-term ODSAterm">binary search tree</em></a>.</dd>
<dt id="term-bubble-sort">bubble sort</dt>
<dd>A simple sort that requires <span class="math">\(Theta(n^2)\)</span> time in
<a class="reference internal" href="#term-best-case"><em class="xref std std-term ODSAterm">best</em></a>, <a class="reference internal" href="#term-average-case"><em class="xref std std-term ODSAterm">average</em></a>,
and <a class="reference internal" href="#term-worst-case"><em class="xref std std-term ODSAterm">worst</em></a> cases.
Even an optimized version will normally run slower than
<a class="reference internal" href="#term-insertion-sort"><em class="xref std std-term ODSAterm">insertion sort</em></a>, so it has little to recommend it.</dd>
<dt id="term-bucket">bucket</dt>
<dd>In <a class="reference internal" href="#term-bucket-hashing"><em class="xref std std-term ODSAterm">bucket hashing</em></a>, a bucket is a sequence of
<a class="reference internal" href="#term-slot"><em class="xref std std-term ODSAterm">slots</em></a> in the <a class="reference internal" href="#term-hash-table"><em class="xref std std-term ODSAterm">hash table</em></a> that are grouped
together.</dd>
<dt id="term-bucket-hashing">bucket hashing</dt>
<dd>A method of <a class="reference internal" href="#term-hashing"><em class="xref std std-term ODSAterm">hashing</em></a> where multiple <a class="reference internal" href="#term-slot"><em class="xref std std-term ODSAterm">slots</em></a>
of the <a class="reference internal" href="#term-hash-table"><em class="xref std std-term ODSAterm">hash table</em></a> are grouped together to form a
<a class="reference internal" href="#term-bucket"><em class="xref std std-term ODSAterm">bucket</em></a>.
The <a class="reference internal" href="#term-hash-function"><em class="xref std std-term ODSAterm">hash function</em></a> then either hashes to some bucket, or
else it hashes to a <a class="reference internal" href="#term-home-slot"><em class="xref std std-term ODSAterm">home slot</em></a> in the normal way, but
this home slot is part of some bucket.
<a class="reference internal" href="#term-collision-resolution"><em class="xref std std-term ODSAterm">Collision resolution</em></a> is handled
first by attempting to find a free position within the same
bucket as the home slot.
If the bucket if full, then the record is placed in an
<a class="reference internal" href="#term-overflow-bucket"><em class="xref std std-term ODSAterm">overflow bucket</em></a>.</dd>
<dt id="term-bucket-sort">bucket sort</dt>
<dd>A variation on the <a class="reference internal" href="#term-binsort"><em class="xref std std-term ODSAterm">Binsort</em></a>, where each bin is associated
with a range of <a class="reference internal" href="#term-key"><em class="xref std std-term ODSAterm">key</em></a> values.
This will require some method of
sorting the records placed into each bin.</dd>
<dt id="term-buddy-method">buddy method</dt>
<dd>In a <a class="reference internal" href="#term-memory-manager"><em class="xref std std-term ODSAterm">memory manager</em></a>, an alternative to using a
<a class="reference internal" href="#term-free-block-list"><em class="xref std std-term ODSAterm">free block list</em></a> and a <a class="reference internal" href="#term-sequential-fit"><em class="xref std std-term ODSAterm">sequential fit</em></a> method to
seach for a suitable free block to service a
<a class="reference internal" href="#term-memory-request"><em class="xref std std-term ODSAterm">memory request</em></a>.
Instead, the memory pool is broken down as needed into smaller
chunks by splitting it in half repeatedly until the smallest
power of 2 that is as big or bigger than the size of the memory
request is reached.
The name comes from the fact that the binary representation for
the start of the block positions only differ by one bit for
adjacent blocks of the same size.
These are referred to as &quot;buddies&quot; and will be merged together
if both are free.</dd>
<dt id="term-buffer">buffer</dt>
<dd>A block of memory, most often in <a class="reference internal" href="#term-primary-storage"><em class="xref std std-term ODSAterm">primary storage</em></a>.
The size of a buffer is typically one or a multiple of the basic
unit of I/O that is read or written on each access to
<a class="reference internal" href="#term-secondary-storage"><em class="xref std std-term ODSAterm">secondary storage</em></a> such as a <a class="reference internal" href="#term-disk-drive"><em class="xref std std-term ODSAterm">disk drive</em></a>.</dd>
<dt id="term-buffer-passing">buffer passing</dt>
<dd>An approach to implementing the <a class="reference internal" href="#term-adt"><em class="xref std std-term ODSAterm">ADT</em></a> for a
<a class="reference internal" href="#term-buffer-pool"><em class="xref std std-term ODSAterm">buffer pool</em></a>, where a pointer to a <a class="reference internal" href="#term-buffer"><em class="xref std std-term ODSAterm">buffer</em></a> is
passed between the client and the buffer pool.
This is in contrast to a <a class="reference internal" href="#term-message-passing"><em class="xref std std-term ODSAterm">message passing</em></a> approach,
it is most likely to be used for long messages or when the
message size is always the same as the buffer size, such as when
implementing a <a class="reference internal" href="#term-37"><em class="xref std std-term ODSAterm">B-tree</em></a>.</dd>
<dt id="term-buffer-pool">buffer pool</dt>
<dd>A collection of one or more <a class="reference internal" href="#term-buffer"><em class="xref std std-term ODSAterm">buffers</em></a>.
The buffer pool is an example of a <a class="reference internal" href="#term-caching"><em class="xref std std-term ODSAterm">cache</em></a>.
It is stored in <a class="reference internal" href="#term-primary-storage"><em class="xref std std-term ODSAterm">primary storage</em></a>, and holds data that is
expected to be used in the near future.
When a data value is requested, the buffer pool is searched
first.
If the value is found in the buffer pool, then
<a class="reference internal" href="#term-secondary-storage"><em class="xref std std-term ODSAterm">secondary storage</em></a> need not be accessed.
If the value is not found in the buffer pool, then it must be
fetched from secondary storage.
A number of traditional <a class="reference internal" href="#term-heuristic"><em class="xref std std-term ODSAterm">heuristics</em></a>
have been developed for deciding which data to <a class="reference internal" href="#term-209"><em class="xref std std-term ODSAterm">flush</em></a>
from the buffer pool when new data must be stored,
such as <a class="reference internal" href="#term-least-recently-used"><em class="xref std std-term ODSAterm">least recently used</em></a>.</dd>
<dt id="term-buffering">buffering</dt>
<dd>A synonym for <a class="reference internal" href="#term-caching"><em class="xref std std-term ODSAterm">caching</em></a>.
More specifically, it refers to an arrangement where all
accesses to data (such as on a
<a class="reference internal" href="#term-peripheral-storage"><em class="xref std std-term ODSAterm">peripheral storage</em></a> device) must
be done in multiples of some minimum unit of storage.
On a <a class="reference internal" href="#term-disk-drive"><em class="xref std std-term ODSAterm">disk drive</em></a>, this basic or smallest unit of I/O is a
<a class="reference internal" href="#term-sector"><em class="xref std std-term ODSAterm">sector</em></a>.
It is called &quot;buffering&quot; because the block of data returned by
such an access is stored in a <a class="reference internal" href="#term-buffer"><em class="xref std std-term ODSAterm">buffer</em></a>.</dd>
<dt id="term-caching">caching</dt>
<dd>The concept of keeping selected data in <a class="reference internal" href="#term-main-memory"><em class="xref std std-term ODSAterm">main memory</em></a>.
The goal is to have in main memory the data values that are
most likely to be used in the near future.
An example of a caching technique is the use of a
<a class="reference internal" href="#term-buffer-pool"><em class="xref std std-term ODSAterm">buffer pool</em></a>.</dd>
<dt id="term-call-stack">call stack</dt>
<dd>Known also as execution stack. A stack that stores the function
call sequence and the return address for each function.</dd>
<dt id="term-cartesian-product">Cartesian product</dt>
<dd>For sets, this is another name for the <a class="reference internal" href="#term-set-product"><em class="xref std std-term ODSAterm">set product</em></a>.</dd>
<dt id="term-ceiling">ceiling</dt>
<dd>Written <span class="math">\(\lceil x \rceil\)</span>, for real value <span class="math">\(x\)</span> the
ceiling is the least integer <span class="math">\(\geq x\)</span>.</dd>
<dt id="term-child">child</dt>
<dd>In a tree, the set of <a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">nodes</em></a> directly pointed to
by a node <span class="math">\(R\)</span> are the <a class="reference internal" href="#term-child"><em class="xref std std-term ODSAterm">children</em></a> of <span class="math">\(R\)</span>.</dd>
<dt id="term-circular-first-fit">circular first fit</dt>
<dd>In a <a class="reference internal" href="#term-memory-manager"><em class="xref std std-term ODSAterm">memory manager</em></a>, circular first fit is a
<a class="reference internal" href="#term-heuristic"><em class="xref std std-term ODSAterm">heuristic</em></a> for deciding which <a class="reference internal" href="#term-free-block"><em class="xref std std-term ODSAterm">free block</em></a> to use
when allocating memory from a <a class="reference internal" href="#term-memory-pool"><em class="xref std std-term ODSAterm">memory pool</em></a>.
Circular first fit is a minor modification on <a class="reference internal" href="#term-first-fit"><em class="xref std std-term ODSAterm">first fit</em></a>
memory allocation, where the last free block allocated from is
remembered, and search for the next suitable free block picks up
from there.
Like first fit, it has the advantage that it is typically not
necessary to look at all free blocks on the free block list to
find a suitable free block.
And it has the advantage over first fit that it spreads out
memory allocations evenly across the <a class="reference internal" href="#term-free-block-list"><em class="xref std std-term ODSAterm">free block list</em></a>.
This might help to minimize <a class="reference internal" href="#term-external-fragmentation"><em class="xref std std-term ODSAterm">external fragmentation</em></a>.</dd>
<dt id="term-circular-list">circular list</dt>
<dd>A <a class="reference internal" href="#term-list"><em class="xref std std-term ODSAterm">list</em></a> ADT implementation variant where the last element
of the list provides access to the first element of the list.</dd>
<dt id="term-class">class</dt>
<dd>In the <a class="reference internal" href="#term-object-oriented-programming-paradigm"><em class="xref std std-term ODSAterm">object-oriented programming paradigm</em></a>
an ADT and its implementation together make up a class.
An instantiation of a class within a program is termed an
<a class="reference internal" href="#term-object"><em class="xref std std-term ODSAterm">object</em></a>.</dd>
<dt id="term-class-hierarchy">class hierarchy</dt>
<dd>In <a class="reference internal" href="#term-object-oriented-programming-paradigm"><em class="xref std std-term ODSAterm">object-oriented programming</em></a>,
a set of classes and their interrelationships.
One of the classes is the <a class="reference internal" href="#term-base-class"><em class="xref std std-term ODSAterm">base class</em></a>, and the others are
<a class="reference internal" href="#term-subclass"><em class="xref std std-term ODSAterm">subclasses</em></a> that <a class="reference internal" href="#term-inherit"><em class="xref std std-term ODSAterm">inherit</em></a> either
directly or indirectly from the base class.</dd>
<dt id="term-client">client</dt>
<dd>The user of a service.
For example, the object or part of the program that calls a
<a class="reference internal" href="#term-memory-manager"><em class="xref std std-term ODSAterm">memory manager</em></a> class is the client of that memory
manager.
Likewise the class or code that calls a <a class="reference internal" href="#term-buffer-pool"><em class="xref std std-term ODSAterm">buffer pool</em></a>.</dd>
<dt id="term-clique">clique</dt>
<dd>In <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> terminology, a clique is a <a class="reference internal" href="#term-subgraph"><em class="xref std std-term ODSAterm">subgraph</em></a>,
defined as any <a class="reference internal" href="#term-subset"><em class="xref std std-term ODSAterm">subset</em></a> <span class="math">\(U\)</span> of the graph's
<a class="reference internal" href="#term-vertex"><em class="xref std std-term ODSAterm">vertices</em></a> such that every vertex in <span class="math">\(U\)</span>
has an <a class="reference internal" href="#term-edge"><em class="xref std std-term ODSAterm">edge</em></a> to every other vertex in <span class="math">\(U\)</span>.
The size of the clique is the number of vertices in the clique.</dd>
<dt id="term-closed-hash-system">closed hash system</dt>
<dd>A <a class="reference internal" href="#term-hash-system"><em class="xref std std-term ODSAterm">hash system</em></a> where all records are stored in slots of
the <a class="reference internal" href="#term-hash-table"><em class="xref std std-term ODSAterm">hash table</em></a>.
This is in contrast to an <a class="reference internal" href="#term-open-hash-system"><em class="xref std std-term ODSAterm">open hash system</em></a>.</dd>
<dt id="term-closed-form-solution">closed-form solution</dt>
<dd>An algebraic equation with the same value as a <a class="reference internal" href="#term-summation"><em class="xref std std-term ODSAterm">summation</em></a>
or <a class="reference internal" href="#term-recurrence-relation"><em class="xref std std-term ODSAterm">recurrence relation</em></a>.
The process of replacing the summation or
recurrence with its closed-form solution is known as solving the
summation or recurrence.</dd>
<dt id="term-cluster">cluster</dt>
<dd>In <a class="reference internal" href="#term-file-processing"><em class="xref std std-term ODSAterm">file processing</em></a>, a collection of physically adjacent
<a class="reference internal" href="#term-sector"><em class="xref std std-term ODSAterm">sectors</em></a> that define the smallest allowed
allocation unit of space to a disk file.
The idea of requiring space to be allocated in multiples of
sectors is that this will reduce the number of
<a class="reference internal" href="#term-extent"><em class="xref std std-term ODSAterm">extents</em></a> required to store the file, which
reduces the expected number of <a class="reference internal" href="#term-seek"><em class="xref std std-term ODSAterm">seek</em></a> operations reuquired
to process a series of <a class="reference internal" href="#term-disk-access"><em class="xref std std-term ODSAterm">disk accesses</em></a> to
the file.
The disadvantage of large cluster size is that it increases
<a class="reference internal" href="#term-internal-fragmentation"><em class="xref std std-term ODSAterm">internal fragmentation</em></a> since any space not actually
used by the file in the last cluster is wasted.</dd>
<dt id="term-cohesion">cohesion</dt>
<dd>In <a class="reference internal" href="#term-object-oriented-programming-paradigm"><em class="xref std std-term ODSAterm">object-oriented programming</em></a>,
a term that refers to the degree to which a class has a single
well-defined role or responsibility.</dd>
<dt id="term-collision">collision</dt>
<dd>In a <a class="reference internal" href="#term-hash-system"><em class="xref std std-term ODSAterm">hash system</em></a>, this refers to the case where two
search <a class="reference internal" href="#term-key"><em class="xref std std-term ODSAterm">keys</em></a> are mapped by the
<a class="reference internal" href="#term-hash-function"><em class="xref std std-term ODSAterm">hash function</em></a> to the same
slot in the <a class="reference internal" href="#term-hash-table"><em class="xref std std-term ODSAterm">hash table</em></a>.
This can happen on insertion or search when another record has
already been hashed to that slot.
In this case, a <a class="reference internal" href="#term-closed-hash-system"><em class="xref std std-term ODSAterm">closed hash system</em></a> will require a
process known as <a class="reference internal" href="#term-collision-resolution"><em class="xref std std-term ODSAterm">collision resolution</em></a> to find the
location of the desired record.</dd>
<dt id="term-collision-resolution">collision resolution</dt>
<dd>The outcome of a <a class="reference internal" href="#term-collision-resolution-policy"><em class="xref std std-term ODSAterm">collision resolution policy</em></a>.</dd>
<dt id="term-collision-resolution-policy">collision resolution policy</dt>
<dd>In <a class="reference internal" href="#term-hashing"><em class="xref std std-term ODSAterm">hashing</em></a>, the process of resolving a
<a class="reference internal" href="#term-collision"><em class="xref std std-term ODSAterm">collision</em></a>.
Specifically in a <a class="reference internal" href="#term-closed-hash-system"><em class="xref std std-term ODSAterm">closed hash system</em></a>, this is the
process of finding the proper position in a <a class="reference internal" href="#term-hash-table"><em class="xref std std-term ODSAterm">hash table</em></a>
that contains the
desired record if the <a class="reference internal" href="#term-hash-function"><em class="xref std std-term ODSAterm">hash function</em></a> did not return the
correct position for that record due to a <a class="reference internal" href="#term-collision"><em class="xref std std-term ODSAterm">collision</em></a> with
another record.</dd>
<dt id="term-comparable">comparable</dt>
<dd>The concept that two objects can be compared to determine if they
are equal or not, or to determine which one is greater than the
other.
In set notation, elements <span class="math">\(x\)</span> and <span class="math">\(y\)</span> of a set are
comparable under a given relation <span class="math">\(R\)</span> if either
<span class="math">\(xRy\)</span> or <span class="math">\(yRx\)</span>.
To be reliably compared for a greater/lesser relationship,
the values being compared must belong to a <a class="reference internal" href="#term-total-order"><em class="xref std std-term ODSAterm">total order</em></a>.
In programming, the property of a data type such that two
elements of the type can be compared to determine if they the
same (a weaker version), or which of the two is larger (a
stronger version).
<code class="docutils literal"><span class="pre">Comparable</span></code> is also the name of an interface in Java that
asserts a comparable relationship between objects with a class,
and <code class="docutils literal"><span class="pre">.compareTo()</span></code> is the <code class="docutils literal"><span class="pre">Comparable</span></code> interface method that
implements the actual comparison between two objects of the class.</dd>
<dt id="term-comparator">comparator</dt>
<dd>A function given as a parameter to a method of a library
(or alternatively, a parameter for a C++ template or a Java
generic).
The comparator function concept provides a generic way
encapulates the process of performing a comparison between two
objects of a specific type.
For example, if we want to write a generic sorting routine, that
can handle any record type, we can require that the user of the
sorting routine pass in a comparator function
to define how records in the collection are to be compared.</dd>
<dt id="term-comparison">comparison</dt>
<dd>The act of comparing two <a class="reference internal" href="#term-key"><em class="xref std std-term ODSAterm">keys</em></a> or
<a class="reference internal" href="#term-record"><em class="xref std std-term ODSAterm">records</em></a>.
For many <a class="reference internal" href="#term-data-type"><em class="xref std std-term ODSAterm">data types</em></a>, a comparison has
constant time cost.
The number of comparisons required is often used as a
<a class="reference internal" href="#term-measure-of-cost"><em class="xref std std-term ODSAterm">measure of cost</em></a> for sorting and searching algorithms.</dd>
<dt id="term-compile-time-polymorphism">compile-time polymorphism</dt>
<dd>A form of <a class="reference internal" href="#term-polymorphism"><em class="xref std std-term ODSAterm">polymorphism</em></a> known as Overloading.
Overloaded methods have the same names, but different signatures
as a method available elsewhere in the class.
Compare to <a class="reference internal" href="#term-run-time-polymorphism"><em class="xref std std-term ODSAterm">run-time polymorphism</em></a>.</dd>
<dt id="term-complete-binary-tree">complete binary tree</dt>
<dd>A binary tree where the nodes are filled in row by row, with the
bottom row filled in left to right.
Due to this requirement, there is only one tree of <span class="math">\(n\)</span>
nodes for any value of <span class="math">\(n\)</span>.
Since storing the records in an array in row order leads to a
simple mapping from a node's position in the array to its
<a class="reference internal" href="#term-parent"><em class="xref std std-term ODSAterm">parent</em></a>, <a class="reference internal" href="#term-sibling"><em class="xref std std-term ODSAterm">siblings</em></a>, and
<a class="reference internal" href="#term-child"><em class="xref std std-term ODSAterm">children</em></a>, the array representation is most
commonly used to implement the complete binary tree.
The <a class="reference internal" href="#term-heap"><em class="xref std std-term ODSAterm">heap</em></a> data structure is a complete binary tree with
partial ordering constraints on the node values.</dd>
<dt id="term-complete-graph">complete graph</dt>
<dd>A <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> where every <a class="reference internal" href="#term-vertex"><em class="xref std std-term ODSAterm">vertex</em></a> connects to every
other vertex.</dd>
<dt id="term-composite-design-pattern">Composite design pattern</dt>
<dd>Given a class hierarchy representing a set of objects, and a
container for a collection of objects, the composite
<a class="reference internal" href="#term-design-pattern"><em class="xref std std-term ODSAterm">design pattern</em></a> addresses the relationship between the
object hierarchy and a bunch of behaviors on the objects.
In the composite design, each object is required to implement
the collection of behaviors.
This is in contrast to the procedural approach where a behavior
(such as a tree <a class="reference internal" href="#term-traversal"><em class="xref std std-term ODSAterm">traversal</em></a>) is implemented as a
method on  the object collection (such as a <a class="reference internal" href="#term-577"><em class="xref std std-term ODSAterm">tree</em></a>).
Procedural tree traversal requires that the tree have a method
that understands what to do when it encounters any of the object
types (<a class="reference internal" href="#term-internal-node"><em class="xref std std-term ODSAterm">internal</em></a> or
<a class="reference internal" href="#term-leaf-node"><em class="xref std std-term ODSAterm">leaf nodes</em></a>) that the tree might contain.
The composite approach would have the tree call the &quot;traversal&quot;
method on its root node, which then knows how to perform the
&quot;traversal&quot; behavior.
This might in turn require invoking the traversal method of
other objects (in this case, the children of the root).</dd>
<dt id="term-composite-type">composite type</dt>
<dd>A type whose <a class="reference internal" href="#term-member"><em class="xref std std-term ODSAterm">members</em></a> have subparts.
For example, a typical database record.
Another term for this is <a class="reference internal" href="#term-aggregate-type"><em class="xref std std-term ODSAterm">aggregate type</em></a>.</dd>
<dt id="term-composition">composition</dt>
<dd>Relationships between classes based on usage rather than
<a class="reference internal" href="#term-inherit"><em class="xref std std-term ODSAterm">inheritance</em></a>, i.e. a <strong>HAS-A</strong> relationship.
For example, some code in class 'A' has a reference to some
other class 'B'.</dd>
<dt id="term-computability">computability</dt>
<dd>A branch of computer science that deals with the theory of
solving problems through computation.
More specificially, it deals with the limits to what problems
(functions) are computable.
An example of a famous problem that cannot in principle be
solved by a computer is the <a class="reference internal" href="#term-halting-problem"><em class="xref std std-term ODSAterm">halting problem</em></a>.</dd>
<dt id="term-computational-complexity-theory">computational complexity theory</dt>
<dd>A branch of the theory of computation in theoretical computer
science and mathematics that focuses on classifying
computational problems according to their inherent difficulty,
and relating those classes to each other.
An example is the study of <a class="reference internal" href="#term-np-complete"><em class="xref std std-term ODSAterm">NP-Complete</em></a> problems.</dd>
<dt id="term-connected-component">connected component</dt>
<dd>In an <a class="reference internal" href="#term-undirected-graph"><em class="xref std std-term ODSAterm">undirected graph</em></a>, a <a class="reference internal" href="#term-subset"><em class="xref std std-term ODSAterm">subset</em></a> of the
<a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">nodes</em></a> such that each node in the subset can be
reached from any other node in that subset.</dd>
<dt id="term-connected-graph">connected graph</dt>
<dd>An <a class="reference internal" href="#term-undirected-graph"><em class="xref std std-term ODSAterm">undirected graph</em></a> is a connected graph if there is at
least one path from any <a class="reference internal" href="#term-vertex"><em class="xref std std-term ODSAterm">vertex</em></a> to any other.</dd>
<dt id="term-constant-running-time">constant running time</dt>
<dd>The cost of a function whose running time is not related to its
input size.
In Theta notation, this is traditionally written as
<span class="math">\(\Theta(1)\)</span>.</dd>
<dt id="term-constructive-induction">constructive induction</dt>
<dd>A process for finding the
<a class="reference internal" href="#term-closed-form-solution"><em class="xref std std-term ODSAterm">closed form</em></a> for a
<a class="reference internal" href="#term-recurrence-relation"><em class="xref std std-term ODSAterm">recurrence relation</em></a>,
that involves substituting in a guess for the closed form to
replace the recursive part(s) of the recurrence.
Depending on the goal (typically either to show that the
hypothesized growth rate is right, or to find the precise
constants), one then manipulates the resulting non-recursive
equation.</dd>
<dt id="term-container"><span id="term-container-class"></span>container<br />container class</dt>
<dd>A <a class="reference internal" href="#term-data-structure"><em class="xref std std-term ODSAterm">data structure</em></a> that stores a collection of
<a class="reference internal" href="#term-record"><em class="xref std std-term ODSAterm">records</em></a>.
Typical examples are arrays,
<a class="reference internal" href="#term-search-tree"><em class="xref std std-term ODSAterm">search trees</em></a>, and
<a class="reference internal" href="#term-hash-table"><em class="xref std std-term ODSAterm">hash tables</em></a>.</dd>
<dt id="term-cost">cost</dt>
<dd>The amount of resources that the solution consumes.</dd>
<dt id="term-cost-model">cost model</dt>
<dd>In <a class="reference internal" href="#term-algorithm-analysis"><em class="xref std std-term ODSAterm">algorithm analysis</em></a>, a definition for the cost of each
<a class="reference internal" href="#term-basic-operation"><em class="xref std std-term ODSAterm">basic operation</em></a> performed by the algorithm,
along with a definition for the size of the input.
Having these definitions allows us to calculate the <a class="reference internal" href="#term-cost"><em class="xref std std-term ODSAterm">cost</em></a>
to run the algorithm on a given input, and from there determine
the <a class="reference internal" href="#term-growth-rate"><em class="xref std std-term ODSAterm">growth rate</em></a> of the algorithm.
A cost model would be considered &quot;good&quot; if it yields predictions
that conform to our understanding of reality.</dd>
<dt id="term-cpu">CPU</dt>
<dd>Acronym for Central Processing Unit, the primary processing
device for a computer.</dd>
<dt id="term-current-position">current position</dt>
<dd>A property of some list ADTs, where there is maintained a
&quot;current position&quot; state that can be referred to later.</dd>
<dt id="term-cycle">cycle</dt>
<dd>In <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> terminology,
a <a class="reference internal" href="#term-cycle"><em class="xref std std-term ODSAterm">cycle</em></a> is a <a class="reference internal" href="#term-path"><em class="xref std std-term ODSAterm">path</em></a> of length three or more that
connects some <a class="reference internal" href="#term-vertex"><em class="xref std std-term ODSAterm">vertex</em></a> <span class="math">\(v_1\)</span> to itself.</dd>
<dt id="term-cylinder">cylinder</dt>
<dd>A <a class="reference internal" href="#term-disk-drive"><em class="xref std std-term ODSAterm">disk drive</em></a> normally consists of a stack of
<a class="reference internal" href="#term-platter"><em class="xref std std-term ODSAterm">platters</em></a>.
While this might not be so true today, traditionally all of the
<a class="reference internal" href="#term-i-o-head"><em class="xref std std-term ODSAterm">I/O heads</em></a> moved together during a
<a class="reference internal" href="#term-seek"><em class="xref std std-term ODSAterm">seek</em></a> operation.
Thus, when a given I/O head is positioned over a particular
<a class="reference internal" href="#term-track"><em class="xref std std-term ODSAterm">track</em></a> on a platter, the other I/O heads are also
positioned over the corresponding track on their platters.
That collection of tracks is called a cylinder.
A given cylinder represents all of the data that can be read
from all of the platters without doing another seek operation.</dd>
<dt id="term-cylinder-index">cylinder index</dt>
<dd>In the <a class="reference internal" href="#term-isam"><em class="xref std std-term ODSAterm">ISAM</em></a> system, a simple <a class="reference internal" href="#term-linear-index"><em class="xref std std-term ODSAterm">linear index</em></a> that
stores the lowest key value stored in each <a class="reference internal" href="#term-cylinder"><em class="xref std std-term ODSAterm">cylinder</em></a>.</dd>
<dt id="term-cylinder-overflow">cylinder overflow</dt>
<dd>In the <a class="reference internal" href="#term-isam"><em class="xref std std-term ODSAterm">ISAM</em></a> system, this is space reserved for storing
any records that can not fit in their respective
<a class="reference internal" href="#term-cylinder"><em class="xref std std-term ODSAterm">cylinder</em></a>.</dd>
<dt id="term-dag">DAG</dt>
<dd>Abbreviation for <a class="reference internal" href="#term-directed-acyclic-graph"><em class="xref std std-term ODSAterm">directed acyclic graph</em></a>.</dd>
<dt id="term-data-field">data field</dt>
<dd>In <a class="reference internal" href="#term-object-oriented-programming-paradigm"><em class="xref std std-term ODSAterm">object-oriented programming</em></a>,
a synonym for <a class="reference internal" href="#term-data-member"><em class="xref std std-term ODSAterm">data member</em></a>.</dd>
<dt id="term-data-item">data item</dt>
<dd>A piece of information or a record whose value is drawn from a type.</dd>
<dt id="term-data-member">data member</dt>
<dd>The variables that together define the space required by a data
item are referred to as data members.
Some of the commonly used synonyms include <a class="reference internal" href="#term-data-field"><em class="xref std std-term ODSAterm">data field</em></a>,
<a class="reference internal" href="#term-attribute"><em class="xref std std-term ODSAterm">attribute</em></a>, and <a class="reference internal" href="#term-instance-variable"><em class="xref std std-term ODSAterm">instance variable</em></a>.</dd>
<dt id="term-data-structure">data structure</dt>
<dd>The implementation for an <a class="reference internal" href="#term-adt"><em class="xref std std-term ODSAterm">ADT</em></a>.</dd>
<dt id="term-data-type">data type</dt>
<dd>A type together with a collection of operations to manipulate
the type.</dd>
<dt id="term-deallocated"><span id="term-deallocation"></span>deallocated<br />deallocation</dt>
<dd>Free the memory allocated to an unused object.</dd>
<dt id="term-decision-problem">decision problem</dt>
<dd>A problem whose output is either &quot;YES&quot; or &quot;NO&quot;.</dd>
<dt id="term-decision-tree">decision tree</dt>
<dd>A theoretical construct for modeling the behavior of algorithms.
Each point at which the algorithm makes a decision (such as an
if statement) is modeled by a branch in the tree that represents
the algorithms behavior.
Decision trees can be used in
<a class="reference internal" href="#term-lower-bounds-proof"><em class="xref std std-term ODSAterm">lower bounds proofs</em></a>,
such as the proof that sorting requires
<span class="math">\(\Omega(n \log n)\)</span> comparisons in the <a class="reference internal" href="#term-worst-case"><em class="xref std std-term ODSAterm">worst case</em></a>.</dd>
<dt id="term-deep-copy">deep copy</dt>
<dd>Copying the actual content of a <a class="reference internal" href="#term-pointee"><em class="xref std std-term ODSAterm">pointee</em></a>.</dd>
<dt id="term-degree">degree</dt>
<dd>In <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> terminology, the degree for a <a class="reference internal" href="#term-vertex"><em class="xref std std-term ODSAterm">vertex</em></a> is
its number of <a class="reference internal" href="#term-neighbor"><em class="xref std std-term ODSAterm">neighbors</em></a>.
In a <a class="reference internal" href="#term-directed-graph"><em class="xref std std-term ODSAterm">directed graph</em></a>, the <a class="reference internal" href="#term-in-degree"><em class="xref std std-term ODSAterm">in degree</em></a> is the number
of edges directed into the vertex, and the <a class="reference internal" href="#term-out-degree"><em class="xref std std-term ODSAterm">out degree</em></a> is
the number of edges directed out of the vertex.
In <a class="reference internal" href="#term-577"><em class="xref std std-term ODSAterm">tree</em></a> terminology, the degree for a <a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">node</em></a> is
its number of <a class="reference internal" href="#term-child"><em class="xref std std-term ODSAterm">children</em></a>.</dd>
<dt id="term-delegation-mental-model-for-recursion">delegation mental model for recursion</dt>
<dd>A way of thinking about the process of <a class="reference internal" href="#term-recursion"><em class="xref std std-term ODSAterm">recursion</em></a>.
The recursive function &quot;delegates&quot; most of the work when it
makes the recursive call.
The advantage of the delegation mental model for recursion is
that you don't need to think about how the delegated task is
performed.
It just gets done.</dd>
<dt id="term-dense-graph">dense graph</dt>
<dd>A <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> where the actual number of <a class="reference internal" href="#term-edge"><em class="xref std std-term ODSAterm">edges</em></a>
is a large fraction of the possible number of edges.
Generally, this is interpreted to mean that the <a class="reference internal" href="#term-degree"><em class="xref std std-term ODSAterm">degree</em></a>
for any <a class="reference internal" href="#term-vertex"><em class="xref std std-term ODSAterm">vertex</em></a> in the graph is relatively high.</dd>
<dt id="term-depth">depth</dt>
<dd>The depth of a node <span class="math">\(M\)</span> in a tree is the length
of the path from the root of the tree to <span class="math">\(M\)</span>.</dd>
<dt id="term-depth-first-search">depth-first search</dt>
<dd>A <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> <a class="reference internal" href="#term-traversal"><em class="xref std std-term ODSAterm">traversal</em></a> algorithm.
Whenever a <span class="math">\(v\)</span> is <a class="reference internal" href="#term-visit"><em class="xref std std-term ODSAterm">visited</em></a> during the
traversal, DFS will <a class="reference internal" href="#term-recursion"><em class="xref std std-term ODSAterm">recursively</em></a> visit all of
<span class="math">\(v\)</span> 's <a class="reference internal" href="#term-unvisited"><em class="xref std std-term ODSAterm">unvisited</em></a> <a class="reference internal" href="#term-neighbor"><em class="xref std std-term ODSAterm">neighbors</em></a>.</dd>
<dt id="term-depth-first-search-tree">depth-first search tree</dt>
<dd>A <a class="reference internal" href="#term-577"><em class="xref std std-term ODSAterm">tree</em></a> that can be defined by the operation of a
<a class="reference internal" href="#term-depth-first-search"><em class="xref std std-term ODSAterm">depth-first search</em></a> (DFS) on a <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a>.
This tree would consist of the <a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">nodes</em></a> of the graph
and a subset of the <a class="reference internal" href="#term-edge"><em class="xref std std-term ODSAterm">edges</em></a> of the graph that was
followed during the DFS.</dd>
<dt id="term-dequeue">dequeue</dt>
<dd>A specialized term used to indicate removing an element from a queue.</dd>
<dt id="term-dereference">dereference</dt>
<dd>Means accessing the value of a <a class="reference internal" href="#term-pointee"><em class="xref std std-term ODSAterm">pointee</em></a>.</dd>
<dt id="term-descendant">descendant</dt>
<dd>In a tree, the set of all nodes that have a node <span class="math">\(A\)</span> as an
<a class="reference internal" href="#term-ancestor"><em class="xref std std-term ODSAterm">ancestor</em></a> are the descendants of <span class="math">\(A\)</span>.
In other words, all of the nodes that can be reached from
<span class="math">\(A\)</span> by progressing downwards in tree.
Another way to say it is: The
<a class="reference internal" href="#term-child"><em class="xref std std-term ODSAterm">children</em></a> of <span class="math">\(A\)</span>, their children, and so
on.</dd>
<dt id="term-deserialization">deserialization</dt>
<dd>The process of returning a <a class="reference internal" href="#term-serialization"><em class="xref std std-term ODSAterm">serialized</em></a>
representation for a data structure back to its original
in-memory form.</dd>
<dt id="term-design-pattern">design pattern</dt>
<dd>An abstraction for describing the design of programs,
that is, the interactions of objects and classes.
Experienced software designers learn and reuse patterns
for combining software components, and design patterns allow
this design knowledge to be passed on to new programmers more quickly.</dd>
<dt id="term-deterministic-algorithm">deterministic algorithm</dt>
<dd>An algorithm that does not involve any element of randomness,
and so its behavior on a given input will always be the same.
This is in contrast to a <a class="reference internal" href="#term-randomized-algorithm"><em class="xref std std-term ODSAterm">randomized algorithm</em></a>.</dd>
<dt id="term-dfs">DFS</dt>
<dd>Abbreviation for <a class="reference internal" href="#term-depth-first-search"><em class="xref std std-term ODSAterm">depth-first search</em></a>.</dd>
<dt id="term-dictionary">dictionary</dt>
<dd>An abstract data type or interface for a data structure or
software subsystem that supports insertion, search, and deletion
of records.</dd>
<dt id="term-digraph">digraph</dt>
<dd>Abbreviation for <a class="reference internal" href="#term-directed-graph"><em class="xref std std-term ODSAterm">directed graph</em></a>.</dd>
<dt id="term-dijkstra-s-algorithm">Dijkstra's algorithm</dt>
<dd>An algorithm to solve the
<a class="reference internal" href="#term-single-source-shortest-paths-problem"><em class="xref std std-term ODSAterm">single-source shortest paths problem</em></a> in a <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a>.
This is a <a class="reference internal" href="#term-greedy-algorithm"><em class="xref std std-term ODSAterm">greedy algorithm</em></a>.
It is nearly identical to <a class="reference internal" href="#term-prim-s-algorithm"><em class="xref std std-term ODSAterm">Prim's algorithm</em></a> for finding a
<a class="reference internal" href="#term-minimal-cost-spanning-tree"><em class="xref std std-term ODSAterm">minimal-cost spanning tree</em></a>, with the only difference
being the calculation done to update the best-known distance.</dd>
<dt id="term-diminishing-increment-sort">diminishing increment sort</dt>
<dd>Another name for <a class="reference internal" href="#term-shellsort"><em class="xref std std-term ODSAterm">Shellsort</em></a>.</dd>
<dt id="term-direct-access">direct access</dt>
<dd>A storage device, such as a disk drive, that has some ability to
move to a desired data location more-or-less directly.
This is in contrast to a <a class="reference internal" href="#term-sequential-access"><em class="xref std std-term ODSAterm">sequential access</em></a> storage
device such as a tape drive.</dd>
<dt id="term-direct-proof">direct proof</dt>
<dd>In general, a direct proof is just a &quot;logical explanation&quot;.
A direct proof is sometimes referred to as an argument by deduction.
This is simply an argument in terms of logic.
Often written in English with words such as &quot;if ... then&quot;,
it could also be written with logic notation such as
<span class="math">\(P \Rightarrow Q\)</span>.</dd>
<dt id="term-directed-acyclic-graph">directed acyclic graph</dt>
<dd>A <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> with no cycles.
Abbreviated as <a class="reference internal" href="#term-dag"><em class="xref std std-term ODSAterm">DAG</em></a>.
Note that a DAG is not necessarily a <a class="reference internal" href="#term-577"><em class="xref std std-term ODSAterm">tree</em></a> since a given
<a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">node</em></a> might have multiple <a class="reference internal" href="#term-parent"><em class="xref std std-term ODSAterm">parents</em></a>.</dd>
<dt id="term-directed-edge">directed edge</dt>
<dd>An <a class="reference internal" href="#term-edge"><em class="xref std std-term ODSAterm">edge</em></a> that goes from <a class="reference internal" href="#term-vertex"><em class="xref std std-term ODSAterm">vertex</em></a> to another.
In contrast, an <a class="reference internal" href="#term-undirected-edge"><em class="xref std std-term ODSAterm">undirected edge</em></a> simply links to vertices
without a direction.</dd>
<dt id="term-directed-graph">directed graph</dt>
<dd>A <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> whose <a class="reference internal" href="#term-edge"><em class="xref std std-term ODSAterm">edges</em></a> each are directed
from one of its defining <a class="reference internal" href="#term-vertex"><em class="xref std std-term ODSAterm">vertices</em></a> to the
other.</dd>
<dt id="term-dirty-bit">dirty bit</dt>
<dd>Within a <a class="reference internal" href="#term-buffer-pool"><em class="xref std std-term ODSAterm">buffer pool</em></a>, a piece of information associated
with each <a class="reference internal" href="#term-buffer"><em class="xref std std-term ODSAterm">buffer</em></a> that indicates whether the contents of
the buffer have changed since being read in from
<a class="reference internal" href="#term-backing-storage"><em class="xref std std-term ODSAterm">backing storage</em></a>.
When the buffer is <a class="reference internal" href="#term-209"><em class="xref std std-term ODSAterm">flushed</em></a> from the buffer pool,
the buffer's contents must be written to the backing storage if
the dirty bit is set (that is, if the contents have changed).
This means that a relatively expensive write operation is
required.
In contrast, if the dirty bit is not set, then it is unnecessary
to write the contents to backing storage, thus saving time over
not keeping track of whether the contents have changed or not.</dd>
<dt id="term-discriminator">discriminator</dt>
<dd>A part of a <a class="reference internal" href="#term-multi-dimensional-search-key"><em class="xref std std-term ODSAterm">multi-dimensional search key</em></a>.
Certain tree data structures such as the <a class="reference internal" href="#term-bintree"><em class="xref std std-term ODSAterm">bintree</em></a> and the
<a class="reference internal" href="#term-kd-tree"><em class="xref std std-term ODSAterm">kd tree</em></a> operate by making branching decisions at nodes
of the tree based on a single attribute of the multi-dimensional
key, with the attribute determined by the level of the node in
the tree.
For example, in 2 dimensions, nodes at the odd levels in the
tree might branch based on the <span class="math">\(x\)</span> value of a coordinate,
while at the even levels the tree would branch based on the
<span class="math">\(y\)</span> value of the coordinate.
Thus, the <span class="math">\(x\)</span> coordinate is the discriminator for the odd
levels, while the <span class="math">\(y\)</span> coordinate is the discriminator for
the even levels.</dd>
<dt id="term-disjoint">disjoint</dt>
<dd>Two parts of a <a class="reference internal" href="#term-data-structure"><em class="xref std std-term ODSAterm">data structure</em></a> or two
collections with no objects in common are disjoint.
This term is often used in conjunction with a data structure
that has <a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">nodes</em></a> (such as a <a class="reference internal" href="#term-577"><em class="xref std std-term ODSAterm">tree</em></a>).
Also used in the context of <a class="reference internal" href="#term-set"><em class="xref std std-term ODSAterm">sets</em></a>, where two
<a class="reference internal" href="#term-subset"><em class="xref std std-term ODSAterm">subsets</em></a> are disjoint if they share no elements.</dd>
<dt id="term-disjoint-sets">disjoint sets</dt>
<dd>A collection of <a class="reference internal" href="#term-set"><em class="xref std std-term ODSAterm">sets</em></a>, any pair of which share no
elements in common.
A collection of disjoint sets partitions some objects
such that every object is in exactly one of the disjoint sets.</dd>
<dt id="term-disk-access">disk access</dt>
<dd>The act of reading data from a disk drive (or other form of
<a class="reference internal" href="#term-peripheral-storage"><em class="xref std std-term ODSAterm">peripheral storage</em></a>).
The number of times data must be read from (or written to) a
disk is often a good measure of cost for an algorithm that
involves disk I/O, since this is usually the dominant cost.</dd>
<dt id="term-disk-controller">disk controller</dt>
<dd>The control mechanism for a <a class="reference internal" href="#term-disk-drive"><em class="xref std std-term ODSAterm">disk drive</em></a>.
Responsible for the action of reading or writing a <a class="reference internal" href="#term-sector"><em class="xref std std-term ODSAterm">sector</em></a>
of data.</dd>
<dt id="term-disk-drive">disk drive</dt>
<dd>An example of <a class="reference internal" href="#term-peripheral-storage"><em class="xref std std-term ODSAterm">peripheral storage</em></a> or
<a class="reference internal" href="#term-secondary-storage"><em class="xref std std-term ODSAterm">secondary storage</em></a>.
Data access times are typically measured in thousandths of a
second (milliseconds), which
is roughly a million times slower than access times for
<a class="reference internal" href="#term-ram"><em class="xref std std-term ODSAterm">RAM</em></a>, which is an example of a <a class="reference internal" href="#term-primary-storage"><em class="xref std std-term ODSAterm">primary storage</em></a>
device.
Reads from and writes to a disk drive are always done in terms
of some minimum size, which is typically called a
<a class="reference internal" href="#term-block"><em class="xref std std-term ODSAterm">block</em></a>.
The block size is 512 bytes on most disk drives.
Disk drives and RAM are typical parts of a computer's
<a class="reference internal" href="#term-memory-hierarchy"><em class="xref std std-term ODSAterm">memory hierarchy</em></a>.</dd>
<dt id="term-disk-i-o">disk I/O</dt>
<dd>Refers to the act of reading data from or writing data to a
<a class="reference internal" href="#term-disk-drive"><em class="xref std std-term ODSAterm">disk drive</em></a>.
All disk reads and writes are done in units of a <a class="reference internal" href="#term-sector"><em class="xref std std-term ODSAterm">sector</em></a>
or <a class="reference internal" href="#term-block"><em class="xref std std-term ODSAterm">block</em></a>.</dd>
<dt id="term-disk-based-space-time-tradeoff">disk-based space/time tradeoff</dt>
<dd>In contrast to the standard <a class="reference internal" href="#term-space-time-tradeoff"><em class="xref std std-term ODSAterm">space/time tradeoff</em></a>, this
principle states that the smaller you can make your disk storage
requirements, the faster your program will run.
This is because the time to read information from disk is
enormous compared to computation time, so almost any amount of
additional computation needed to unpack the data is going to be
less than the disk-reading time saved by reducing the storage
requirements.</dd>
<dt id="term-distance">distance</dt>
<dd>In <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> representations, a synonym for <a class="reference internal" href="#term-weight"><em class="xref std std-term ODSAterm">weight</em></a>.</dd>
<dt id="term-divide-and-conquer">divide and conquer</dt>
<dd>A technique for designing algorithms where a solution is found
by breaking the problem into smaller (similar) subproblems,
solving the subproblems, then combining the subproblem solutions
to form the solution to the original problem.
This process is often implemented using <a class="reference internal" href="#term-recursion"><em class="xref std std-term ODSAterm">recursion</em></a>.</dd>
<dt id="term-divide-and-conquer-recurrences">divide-and-conquer recurrences</dt>
<dd><p class="first">A common form of <a class="reference internal" href="#term-recurrence-relation"><em class="xref std std-term ODSAterm">recurrence relation</em></a>
that have the form</p>
<div class="math">
\[{\bf T}(n) = a{\bf T}(n/b) + cn^k; \quad {\bf T}(1) = c\]</div>
<p class="last">where <span class="math">\(a\)</span>, <span class="math">\(b\)</span>, <span class="math">\(c\)</span>, and <span class="math">\(k\)</span> are constants.
In general, this recurrence describes a problem of size <span class="math">\(n\)</span>
divided into <span class="math">\(a\)</span> subproblems of size <span class="math">\(n/b\)</span>,
while <span class="math">\(cn^k\)</span> is the amount of work necessary to combine the
partial solutions.</p>
</dd>
<dt id="term-divide-and-guess">divide-and-guess</dt>
<dd>A technique for finding a <a class="reference internal" href="#term-closed-form-solution"><em class="xref std std-term ODSAterm">closed-form solution</em></a> to a
<a class="reference internal" href="#term-summation"><em class="xref std std-term ODSAterm">summation</em></a> or <a class="reference internal" href="#term-recurrence-relation"><em class="xref std std-term ODSAterm">recurrence relation</em></a>.</dd>
<dt id="term-domain">domain</dt>
<dd>The set of possible inputs to a function.</dd>
<dt id="term-double-buffering">double buffering</dt>
<dd>The idea of using multiple <a class="reference internal" href="#term-buffer"><em class="xref std std-term ODSAterm">buffers</em></a> to allow the
<a class="reference internal" href="#term-cpu"><em class="xref std std-term ODSAterm">CPU</em></a> to operate in parallel with a
<a class="reference internal" href="#term-peripheral-storage"><em class="xref std std-term ODSAterm">peripheral storage</em></a> device.
Once the first buffer's worth of data has been read in, the CPU
can process this while the next block of data is being
read from the peripheral storage.
For this idea to work, the next block of data to be processed
must be known or predicted with reasonable accuracy.</dd>
<dt id="term-double-hashing">double hashing</dt>
<dd>A <a class="reference internal" href="#term-collision-resolution"><em class="xref std std-term ODSAterm">collision resolution</em></a> method. A second hash
function is used to generate a value <span class="math">\(c\)</span> on the key.
That value is then used by this key as the step size in
<a class="reference internal" href="#term-linear-probing-by-steps"><em class="xref std std-term ODSAterm">linear probing by steps</em></a>.
Since different keys use different step sizes (as generated by
the second hash function), this process avoids the clustering
caused by standard linear probing by steps.</dd>
<dt id="term-double-rotation">double rotation</dt>
<dd>A type of <a class="reference internal" href="#term-rebalancing-operation"><em class="xref std std-term ODSAterm">rebalancing operation</em></a> used by the
<a class="reference internal" href="#term-splay-tree"><em class="xref std std-term ODSAterm">Splay Tree</em></a> and <a class="reference internal" href="#term-avl-tree"><em class="xref std std-term ODSAterm">AVL Tree</em></a>.</dd>
<dt id="term-doubly-linked-list">doubly linked list</dt>
<dd>A <a class="reference internal" href="#term-linked-list"><em class="xref std std-term ODSAterm">linked list</em></a> implementation variant where each list
node contains access pointers to both the previous element and
the next element on the list.</dd>
<dt id="term-dsa">DSA</dt>
<dd>Abbreviation for Data Structures and Algorithms.</dd>
<dt id="term-dynamic">dynamic</dt>
<dd>Something that is changes (in contrast to <a class="reference internal" href="#term-static"><em class="xref std std-term ODSAterm">static</em></a>).
In computer programming, dynamic normally refers to something
that happens at run time.
For example, run-time analysis is analysis of the program's
behavior, as opposed to its (static) text or structure
Dynamic binding or dynamic memory allocation occurs at run time.</dd>
<dt id="term-dynamic-allocation">dynamic allocation</dt>
<dd>The act of creating an object from <a class="reference internal" href="#term-free-store"><em class="xref std std-term ODSAterm">free store</em></a>.
In C++, Java, and JavaScript, this is done using the <code class="docutils literal"><span class="pre">new</span></code>
operator.</dd>
<dt id="term-dynamic-array">dynamic array</dt>
<dd>Arrays, once allocated, are of fixed size. A dynamic array puts
an interface around the array so as to appear to allow the array
to grow and shrink in size as necessary. Typically this is done
by allocating a new copy, copying the contents of the old array,
and then returning the old array to <a class="reference internal" href="#term-free-store"><em class="xref std std-term ODSAterm">free store</em></a>.
If done correctly, the <a class="reference internal" href="#term-amortized-cost"><em class="xref std std-term ODSAterm">amortized cost</em></a> for dynamically
resizing the array can be made constant.
In some programming languages such as Java, the term
<a class="reference internal" href="#term-vector"><em class="xref std std-term ODSAterm">vector</em></a> is used as a synonym for dynamic array.</dd>
<dt id="term-dynamic-memory-allocation">dynamic memory allocation</dt>
<dd>A programming technique where linked objects in a data structure
are created from <a class="reference internal" href="#term-free-store"><em class="xref std std-term ODSAterm">free store</em></a> as needed. When no longer
needed, the object is either returned to <a class="reference internal" href="#term-free-store"><em class="xref std std-term ODSAterm">free store</em></a> or
left as <a class="reference internal" href="#term-garbage"><em class="xref std std-term ODSAterm">garbage</em></a>, depending on the programming language.</dd>
<dt id="term-dynamic-programming">dynamic programming</dt>
<dd>An approach to designing algorithms that works by storing a table
of results for subproblems.
A typical cause for excessive cost in
<a class="reference internal" href="#term-recursion"><em class="xref std std-term ODSAterm">recursive</em></a>
algorithms is that different branches of the recursion might
solve the same subproblem.
Dynamic programming uses a table to store information about
which subproblems have already been solved, and uses the stored
information to immediately give the answer for any repeated
attempts to solve that subproblem.</dd>
<dt id="term-edge">edge</dt>
<dd>The connection that links two <a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">nodes</em></a> in a
<a class="reference internal" href="#term-577"><em class="xref std std-term ODSAterm">tree</em></a>, <a class="reference internal" href="#term-linked-list"><em class="xref std std-term ODSAterm">linked list</em></a>, or <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a>.</dd>
<dt id="term-efficient">efficient</dt>
<dd>A solution is said to be efficient
if it solves the problem within the required
<a class="reference internal" href="#term-resource-constraints"><em class="xref std std-term ODSAterm">resource constraints</em></a>.
A solution is sometimes said to be
efficient if it requires fewer resources than known
alternatives, regardless of whether it meets any particular
requirements.</dd>
<dt id="term-element">element</dt>
<dd>One value or member in a set.</dd>
<dt id="term-empirical-comparison">empirical comparison</dt>
<dd>An approach to comparing to things by actually seeing how they
perform.
Most typically, we are referring to the comparison of two
programs by running each on a suite of test data and measuring
the actual running times.
Empirical comparison is subject to many possible complications,
including unfair selection of test data, and inaccuracies in the
time measurements due to variations in the computing environment
between various executions of the programs.</dd>
<dt id="term-empty">empty</dt>
<dd>For a <a class="reference internal" href="#term-container"><em class="xref std std-term ODSAterm">container</em></a> class, the state of containing no
<a class="reference internal" href="#term-element"><em class="xref std std-term ODSAterm">elements</em></a>.</dd>
<dt id="term-encapsulation">encapsulation</dt>
<dd>In programming, the concept of hiding implementation details
from the user of an ADT, and protecting
<a class="reference internal" href="#term-data-member"><em class="xref std std-term ODSAterm">data members</em></a> of an
object from outside access.</dd>
<dt id="term-enqueue">enqueue</dt>
<dd>A specialized term used to indicate inserting an element onto a queue.</dd>
<dt id="term-entry-sequenced-file">entry-sequenced file</dt>
<dd>A file that stores records in the order that they were added to
the file.</dd>
<dt id="term-enumeration">enumeration</dt>
<dd>The process by which a <a class="reference internal" href="#term-traversal"><em class="xref std std-term ODSAterm">traversal</em></a> lists every object in
the <a class="reference internal" href="#term-container"><em class="xref std std-term ODSAterm">container</em></a> exactly once.
Thus, a traversal that prints the <a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">nodes</em></a> is said
to enumerate the nodes.
An enumeration can also refer to the actual listing that is
produced by the traversal
(as well as the process that created that listing).</dd>
<dt id="term-equivalence-class">equivalence class</dt>
<dd>An <a class="reference internal" href="#term-equivalence-relation"><em class="xref std std-term ODSAterm">equivalence relation</em></a> can be used to partition a set
into equivalence classes.</dd>
<dt id="term-equivalence-relation">equivalence relation</dt>
<dd>Relation <span class="math">\(R\)</span> is an equivalence relation on set
<span class="math">\(\mathbf{S}\)</span> if it is <a class="reference internal" href="#term-reflexive"><em class="xref std std-term ODSAterm">reflexive</em></a>,
<a class="reference internal" href="#term-symmetric"><em class="xref std std-term ODSAterm">symmetric</em></a>, and <a class="reference internal" href="#term-transitive"><em class="xref std std-term ODSAterm">transitive</em></a>.</dd>
<dt id="term-estimation">estimation</dt>
<dd>As a technical skill, this is the process of generating a rough
estimate in order to evaluate the feasibility of a proposed
solution.
This is sometimes known as &quot;back of the napkin&quot; or
&quot;back of the envelope&quot; calculation.
The estimation process can be formalized as (1) determine the
major parameters that affect the problem, (2) derive an equation
that relates the parameters to the problem, then (3) select
values for the parameters and apply the equation to yield an
estimated solution.</dd>
<dt id="term-exact-match-query">exact-match query</dt>
<dd>Records are accessed by unique identifier.</dd>
<dt id="term-exceptions">exceptions</dt>
<dd>Exceptions are techniques used to predict possible runtime errors and handle them properly.</dd>
<dt id="term-exchange">exchange</dt>
<dd>A swap of adjacent records in an array.</dd>
<dt id="term-exchange-sort">exchange sort</dt>
<dd>A sort that relies solely on exchanges (swaps of adjacent
records) to reorder the list.
<a class="reference internal" href="#term-insertion-sort"><em class="xref std std-term ODSAterm">Insertion Sort</em></a> and
<a class="reference internal" href="#term-bubble-sort"><em class="xref std std-term ODSAterm">Bubble Sort</em></a> are examples of exchange sorts.
All exchange sorts require
<span class="math">\(\Theta(n^2)\)</span> time in the <a class="reference internal" href="#term-worst-case"><em class="xref std std-term ODSAterm">worst case</em></a>.</dd>
<dt id="term-expanding-the-recurrence">expanding the recurrence</dt>
<dd>A technique for solving a <a class="reference internal" href="#term-recurrence-relation"><em class="xref std std-term ODSAterm">recurrence relation</em></a>.
The idea is to replace the recursive part of the recurrence with
a copy of recurrence.</dd>
<dt id="term-exponential-growth-rate">exponential growth rate</dt>
<dd>A <a class="reference internal" href="#term-growth-rate"><em class="xref std std-term ODSAterm">growth rate</em></a> function where <span class="math">\(n\)</span> (the input size)
appears in the exponent. For example, <span class="math">\(2^n\)</span>.</dd>
<dt id="term-expression-tree">expression tree</dt>
<dd>A <a class="reference internal" href="#term-577"><em class="xref std std-term ODSAterm">tree</em></a> structure meant to represent a mathematical expression.
<a class="reference internal" href="#term-internal-node"><em class="xref std std-term ODSAterm">Internal nodes</em></a> of the expression tree
are operators in the expression, with the subtrees being the
sub-expressions that are its operand.
All <a class="reference internal" href="#term-leaf-node"><em class="xref std std-term ODSAterm">leaf nodes</em></a> are operands.</dd>
<dt id="term-extent">extent</dt>
<dd>A physically contiguous block of <a class="reference internal" href="#term-sector"><em class="xref std std-term ODSAterm">sectors</em></a> on a
<a class="reference internal" href="#term-disk-drive"><em class="xref std std-term ODSAterm">disk drive</em></a> that are all part of a given disk file.
The fewer extents needed to store the data for a disk file,
generally the fewer <a class="reference internal" href="#term-seek"><em class="xref std std-term ODSAterm">seek</em></a> operations that will be
required to process a series of <a class="reference internal" href="#term-disk-access"><em class="xref std std-term ODSAterm">disk access</em></a> operations
on that file.</dd>
<dt id="term-external-fragmentation">external fragmentation</dt>
<dd>A condition that arises when a series of
<a class="reference internal" href="#term-memory-request"><em class="xref std std-term ODSAterm">memory requests</em></a>
result in lots of small <a class="reference internal" href="#term-free-block"><em class="xref std std-term ODSAterm">free blocks</em></a>, no one
of which is useful for servicing typical requests.</dd>
<dt id="term-external-sort">external sort</dt>
<dd>A sorting algorithm that is applied to data stored in
<a class="reference internal" href="#term-peripheral-storage"><em class="xref std std-term ODSAterm">peripheral storage</em></a> such as on a <a class="reference internal" href="#term-disk-drive"><em class="xref std std-term ODSAterm">disk drive</em></a>.
This is in contrast to an <a class="reference internal" href="#term-internal-sort"><em class="xref std std-term ODSAterm">internal sort</em></a> that works on
data stored in <a class="reference internal" href="#term-main-memory"><em class="xref std std-term ODSAterm">main memory</em></a>.</dd>
<dt id="term-factorial">factorial</dt>
<dd>The factorial function is defined as <span class="math">\(f(n) = n f(n-1)\)</span> for
<span class="math">\(n &gt; 0\)</span>.</dd>
<dt id="term-failure-policy">failure policy</dt>
<dd>In a <a class="reference internal" href="#term-memory-manager"><em class="xref std std-term ODSAterm">memory manager</em></a>, a failure policy is the response
that takes place when there is no way to satisfy a
<a class="reference internal" href="#term-memory-request"><em class="xref std std-term ODSAterm">memory request</em></a> from the current
<a class="reference internal" href="#term-free-block"><em class="xref std std-term ODSAterm">free blocks</em></a> in the <a class="reference internal" href="#term-memory-pool"><em class="xref std std-term ODSAterm">memory pool</em></a>.
Possibilities include rejecting the request, expanding the
memory pool, collecting <a class="reference internal" href="#term-garbage"><em class="xref std std-term ODSAterm">garbage</em></a>, and reorganizing the
memory pool (to collect together free space).</dd>
<dt id="term-fifo">FIFO</dt>
<dd>Abbreviation for &quot;first-in, first-out&quot;.
This is the access paradigm for a <a class="reference internal" href="#term-queue"><em class="xref std std-term ODSAterm">queue</em></a>,
and an old terminolgy for the queue is &quot;FIFO list&quot;.</dd>
<dt id="term-file-allocation-table">file allocation table</dt>
<dd>A legacy file system architecture orginially developed for DOS
and then used in Windows.
It is still in use in many small-scale peripheral devices such
as USB memory sticks and digital camera memory.</dd>
<dt id="term-file-manager">file manager</dt>
<dd>A part of the <a class="reference internal" href="#term-operating-system"><em class="xref std std-term ODSAterm">operating system</em></a>
responsible for taking requests for data from a
<a class="reference internal" href="#term-logical-file"><em class="xref std std-term ODSAterm">logical file</em></a> and mapping those requests to the
physical location of the data on disk.</dd>
<dt id="term-file-processing">file processing</dt>
<dd>The domain with Computer Science that deals with processing data
stored on a <a class="reference internal" href="#term-disk-drive"><em class="xref std std-term ODSAterm">disk drive</em></a> (in a file), or more broadly,
dealing with data stored on any <a class="reference internal" href="#term-peripheral-storage"><em class="xref std std-term ODSAterm">peripheral storage</em></a>
device.
Two fundamental properties make dealing with data on a
peripheral device different from dealing with data in main
memory:
(1) Reading/writing data on a peripheral storage device is far
slower than reading/writing data to main memory (for example, a
typical disk drive is about a million times slower than
<a class="reference internal" href="#term-ram"><em class="xref std std-term ODSAterm">RAM</em></a>).
(2) All I/O to a peripheral device is typically in terms of a
<a class="reference internal" href="#term-block"><em class="xref std std-term ODSAterm">block</em></a> of data (for example, nearly all disk drives do
all I/O in terms of blocks of 512 bytes).</dd>
<dt id="term-file-structure">file structure</dt>
<dd>The organization of data on <a class="reference internal" href="#term-peripheral-storage"><em class="xref std std-term ODSAterm">peripheral storage</em></a>,
such as a <a class="reference internal" href="#term-disk-drive"><em class="xref std std-term ODSAterm">disk drive</em></a> or DVD drive.</dd>
<dt id="term-find">FIND</dt>
<dd>One half of the <a class="reference internal" href="#term-union-find"><em class="xref std std-term ODSAterm">UNION/FIND</em></a> algorithm for managing
<a class="reference internal" href="#term-disjoint-sets"><em class="xref std std-term ODSAterm">disjoint sets</em></a>.
It is the process of moving upwards in a
tree to find the tree's root.</dd>
<dt id="term-first-fit">first fit</dt>
<dd>In a <a class="reference internal" href="#term-memory-manager"><em class="xref std std-term ODSAterm">memory manager</em></a>, first fit is a <a class="reference internal" href="#term-heuristic"><em class="xref std std-term ODSAterm">heuristic</em></a>
for deciding which <a class="reference internal" href="#term-free-block"><em class="xref std std-term ODSAterm">free block</em></a> to use when allocating
memory from a <a class="reference internal" href="#term-memory-pool"><em class="xref std std-term ODSAterm">memory pool</em></a>.
First fit will always allocate the first <a class="reference internal" href="#term-free-block"><em class="xref std std-term ODSAterm">free block</em></a> on
the <a class="reference internal" href="#term-free-block-list"><em class="xref std std-term ODSAterm">free block list</em></a> that is large enough to service the
memory request.
The advantage of this approach is that it is typically not
necessary to look at all free blocks on the free block list to
find a suitable free block.
The disadvantage is that it is not &quot;intelligently&quot; selecting
what might be a better choice of free block.</dd>
<dt id="term-fixed-length-coding">fixed-length coding</dt>
<dd>Given a collection of objects, a fixed-length coding scheme
assigns a code to each object in the collection using codes that
are all of the same length.
Standard ASCII and Unicode representations for characters are
both examples of fixed-length coding schemes.
This is in contrast to <a class="reference internal" href="#term-variable-length-coding"><em class="xref std std-term ODSAterm">variable-length coding</em></a>.</dd>
<dt id="term-floor">floor</dt>
<dd>Written <span class="math">\(\lfloor x \rfloor\)</span>, for real value <span class="math">\(x\)</span> the
floor is the greatest integer <span class="math">\(\leq x\)</span>.</dd>
<dt id="term-floyd-s-algorithm">Floyd's algorithm</dt>
<dd>An algorithm to solve the
<a class="reference internal" href="#term-all-pairs-shortest-paths-problem"><em class="xref std std-term ODSAterm">all-pairs shortest paths problem</em></a>.
It uses the <a class="reference internal" href="#term-dynamic-programming"><em class="xref std std-term ODSAterm">dynamic programming</em></a> algorithmic technique,
and runs in <span class="math">\(\Theta(n^3)\)</span> time.
As with any <a class="reference internal" href="#term-dynamic-programming"><em class="xref std std-term ODSAterm">dynamic programming</em></a> algorithm,
the key issue is to avoid duplicating work by using proper
bookkeeping on the algorithm's progress through the solution space.
The basic idea is to first find all the direct edge costs, then
improving those costs by allowing paths through <a class="reference internal" href="#term-vertex"><em class="xref std std-term ODSAterm">vertex</em></a>
0, then the cheapest paths involving paths going through
vertices 0 and 1, and so on.</dd>
<dt id="term-flush">flush</dt>
<dd>The act of removing data from a <a class="reference internal" href="#term-caching"><em class="xref std std-term ODSAterm">cache</em></a>, most
typically because other data considered of higher future value
must replace it in the cache.
If the data being flushed has been modified since it was first
read in from <a class="reference internal" href="#term-secondary-storage"><em class="xref std std-term ODSAterm">secondary storage</em></a> (and the changes are
meant to be saved), then it must be written back to that
secondary storage.</dd>
<dt id="term-209">flush</dt>
<dd>The the context of a <a class="reference internal" href="#term-buffer-pool"><em class="xref std std-term ODSAterm">buffer pool</em></a>, the process of
removing the contents stored in a <a class="reference internal" href="#term-buffer"><em class="xref std std-term ODSAterm">buffer</em></a>
when that buffer is required in order to store new data.
If the buffer's contents have been changed since having been
read in from <a class="reference internal" href="#term-backing-storage"><em class="xref std std-term ODSAterm">backing storage</em></a> (this fact would
normally be tracked by using a <a class="reference internal" href="#term-dirty-bit"><em class="xref std std-term ODSAterm">dirty bit</em></a>),
then they must be copied back to the backing storage before the
buffer can be reused.</dd>
<dt id="term-flyweight">flyweight</dt>
<dd>A <a class="reference internal" href="#term-design-pattern"><em class="xref std std-term ODSAterm">design pattern</em></a> that is meant to solve the following
problem:
You have an application with many objects.
Some of these objects are identical in the information that
they contain, and the role that they play.
But they must be reached from various places, and conceptually they
really are distinct objects.
Because there is so much duplication of the same information,
we want to reduce memory cost by sharing that space.
For example, in document layout,
the letter &quot;C&quot; might be represented by an object that
describes that character's strokes and bounding box.
However, we do not want to create a separate &quot;C&quot; object everywhere
in the document that a &quot;C&quot; appears.
The solution is to allocate a single copy of the shared representation
for &quot;C&quot; objects.
Then, every place in the document that needs a &quot;C&quot; in a given font,
size, and typeface will reference this single copy.
The various instances of references to a specific form of &quot;C&quot; are
called flyweights.
Flyweights can also used to advantage in the implementation of the
<a class="reference internal" href="#term-bintree"><em class="xref std std-term ODSAterm">bintree</em></a> and <a class="reference internal" href="#term-pr-quadtree"><em class="xref std std-term ODSAterm">PR quadtree</em></a>.</dd>
<dt id="term-folding-method">folding method</dt>
<dd>In <a class="reference internal" href="#term-hashing"><em class="xref std std-term ODSAterm">hashing</em></a>, an approach to implementing a
<a class="reference internal" href="#term-hash-function"><em class="xref std std-term ODSAterm">hash function</em></a>.
Most typically used when the key is a string, the folding method
breaks the string into pieces (perhaps each letter is a piece,
or a small series of letters is a piece), converts the letter(s)
to an integer value (typically by using its underlying encoding
value), and summing up the pieces.</dd>
<dt id="term-forest">forest</dt>
<dd>A collection of one or more <a class="reference internal" href="#term-577"><em class="xref std std-term ODSAterm">trees</em></a>.</dd>
<dt id="term-free-block">free block</dt>
<dd>A block of unused space in a <a class="reference internal" href="#term-memory-pool"><em class="xref std std-term ODSAterm">memory pool</em></a>.</dd>
<dt id="term-free-block-list">free block list</dt>
<dd>In a <a class="reference internal" href="#term-memory-manager"><em class="xref std std-term ODSAterm">memory manager</em></a>, the list that stores the necessary
information about the current <a class="reference internal" href="#term-free-block"><em class="xref std std-term ODSAterm">free blocks</em></a>.
Generally, this is done with some sort of <a class="reference internal" href="#term-linked-list"><em class="xref std std-term ODSAterm">linked list</em></a>,
where each node of the linked list indicates the start position
and length of the free block in the <a class="reference internal" href="#term-memory-pool"><em class="xref std std-term ODSAterm">memory pool</em></a>.</dd>
<dt id="term-free-store">free store</dt>
<dd>Space available to a program during runtime to be used for
<a class="reference internal" href="#term-dynamic-allocation"><em class="xref std std-term ODSAterm">dynamic allocation</em></a> of objects.
The free store is distinct from the <a class="reference internal" href="#term-runtime-stack"><em class="xref std std-term ODSAterm">runtime stack</em></a>.
The free store is sometimes referred to as the <a class="reference internal" href="#term-heap"><em class="xref std std-term ODSAterm">heap</em></a>,
which can be confusing because <a class="reference internal" href="#term-heap"><em class="xref std std-term ODSAterm">heap</em></a> more often refers to
a specific data structure. Most programming languages provide
functions to allocate (and maybe to deallocate) objects from the
free store, such as <code class="docutils literal"><span class="pre">new</span></code> in C++ and Java.</dd>
<dt id="term-free-tree">free tree</dt>
<dd>A connected, <a class="reference internal" href="#term-undirected-graph"><em class="xref std std-term ODSAterm">undirected graph</em></a> with no simple cycles.
An equivalent definition is that a free tree is connected and
has <span class="math">\(|\mathbf{V}| - 1\)</span> edges.</dd>
<dt id="term-freelist">freelist</dt>
<dd>A simple and faster alternative to using <a class="reference internal" href="#term-free-store"><em class="xref std std-term ODSAterm">free store</em></a> when
the objects being dynamically allocated are all of the same size
(and thus are interchangeable).
Typically implemented as a <a class="reference internal" href="#term-linked-stack"><em class="xref std std-term ODSAterm">linked stack</em></a>, released
objects are put on the front of the freelist.
When a request is made to allocate an object, the freelist is
checked first and it provides the object if possible.
If the freelist is empty, then a new object is allocated from
<a class="reference internal" href="#term-free-store"><em class="xref std std-term ODSAterm">free store</em></a>.</dd>
<dt id="term-frequency-count">frequency count</dt>
<dd>A <a class="reference internal" href="#term-heuristic"><em class="xref std std-term ODSAterm">heuristic</em></a> used to maintain a
<a class="reference internal" href="#term-self-organizing-list"><em class="xref std std-term ODSAterm">self-organizing list</em></a>.
Under this heuristic, a count is maintained for every record.
When a record access is made, its count is increased.
If this makes its count greater than that of another record in
the list, it moves up toward the front of the list accordingly
so as to keep the list sorted by frequency.
Analogous to the <a class="reference internal" href="#term-least-frequently-used"><em class="xref std std-term ODSAterm">least frequently used</em></a> heuristic for
maintaining a <a class="reference internal" href="#term-buffer-pool"><em class="xref std std-term ODSAterm">buffer pool</em></a>.</dd>
<dt id="term-full-binary-tree-theorem">full binary tree theorem</dt>
<dd>This theorem states that
the number of leaves in a non-empty full binary tree is one
more than the number of internal nodes.
Equivalently, then number of null pointers in a standard
<a class="reference internal" href="#term-pointer-based-implementation-for-binary-tree-nodes"><em class="xref std std-term ODSAterm">pointer-based implementation for binary tree nodes</em></a>
is one more than the number of nodes in the binary tree.</dd>
<dt id="term-full-tree">full tree</dt>
<dd>A <a class="reference internal" href="#term-binary-tree"><em class="xref std std-term ODSAterm">binary tree</em></a> is full if every <a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">node</em></a> is either a
<a class="reference internal" href="#term-leaf-node"><em class="xref std std-term ODSAterm">leaf node</em></a> or else it is an <a class="reference internal" href="#term-internal-node"><em class="xref std std-term ODSAterm">internal node</em></a> with
two non-empty <a class="reference internal" href="#term-child"><em class="xref std std-term ODSAterm">children</em></a>.</dd>
<dt id="term-function">function</dt>
<dd>In mathematics, a matching between inputs (the <a class="reference internal" href="#term-domain"><em class="xref std std-term ODSAterm">domain</em></a>)
and outputs (the <a class="reference internal" href="#term-range"><em class="xref std std-term ODSAterm">range</em></a>).
In programming, a subroutine that takes input parameters and
uses them to compute and return a value.
In this case, it is usually considered bad practice for a
function to change any global variables
(doing so is called a side effect).</dd>
<dt id="term-garbage">garbage</dt>
<dd>In <a class="reference internal" href="#term-memory-manager"><em class="xref std std-term ODSAterm">memory management</em></a>,
any memory that was previously (dynamically)
allocated by the program during runtime, but which is no longer
accessible since all pointers to the memory have been deleted or
overwritten.
In some languages, garbage can be recovered by
<a class="reference internal" href="#term-garbage-collection"><em class="xref std std-term ODSAterm">garbage collection</em></a>.
In languages such as C and C++ that do not support garbage
collection, so creating garbage is considered a
<a class="reference internal" href="#term-memory-leak"><em class="xref std std-term ODSAterm">memory leak</em></a>.</dd>
<dt id="term-garbage-collection">garbage collection</dt>
<dd>Languages with garbage collection such
Java, JavaScript, Lisp, and Scheme will periodically reclaim
<a class="reference internal" href="#term-garbage"><em class="xref std std-term ODSAterm">garbage</em></a> and return it to <a class="reference internal" href="#term-free-store"><em class="xref std std-term ODSAterm">free store</em></a>.</dd>
<dt id="term-general-tree">general tree</dt>
<dd>A tree in which any given node can have any number of
<a class="reference internal" href="#term-child"><em class="xref std std-term ODSAterm">children</em></a>.
This is in contrast to, for example, a <a class="reference internal" href="#term-binary-tree"><em class="xref std std-term ODSAterm">binary tree</em></a> where
each node has a fixed number of children (some of which might be
<code class="docutils literal"><span class="pre">null</span></code>).
General tree nodes tend to be harder to implement for this reason.</dd>
<dt id="term-graph">graph</dt>
<dd>A <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> <span class="math">\(\mathbf{G} = (\mathbf{V}, \mathbf{E})\)</span>
consists of a set of <a class="reference internal" href="#term-vertex"><em class="xref std std-term ODSAterm">vertices</em></a>
<span class="math">\(\mathbf{V}\)</span> and a set of <a class="reference internal" href="#term-edge"><em class="xref std std-term ODSAterm">edges</em></a>
<span class="math">\(\mathbf{E}\)</span>, such that each edge in <span class="math">\(\mathbf{E}\)</span> is
a connection between a pair of vertices in <span class="math">\(\mathbf{V}\)</span>.</dd>
<dt id="term-greedy-algorithm">greedy algorithm</dt>
<dd>An algorithm that makes locally optimal choices at each step.</dd>
<dt id="term-growth-rate">growth rate</dt>
<dd>In <a class="reference internal" href="#term-algorithm-analysis"><em class="xref std std-term ODSAterm">algorithm analysis</em></a>, the rate at which the cost
of the <a class="reference internal" href="#term-algorithm"><em class="xref std std-term ODSAterm">algorithm</em></a> grows as the size of its input grows.</dd>
<dt id="term-guess-and-test">guess-and-test</dt>
<dd>A technique used when trying to determine the
<a class="reference internal" href="#term-closed-form-solution"><em class="xref std std-term ODSAterm">closed-form solution</em></a> for a
<a class="reference internal" href="#term-summation"><em class="xref std std-term ODSAterm">summation</em></a> or <a class="reference internal" href="#term-recurrence-relation"><em class="xref std std-term ODSAterm">recurrence relation</em></a>.
Given a hypothesis for the closed-form solution,
if it is correct, then it is often relatively easy to prove that
using <a class="reference internal" href="#term-proof-by-induction"><em class="xref std std-term ODSAterm">induction</em></a>.</dd>
<dt id="term-guided-traversal">guided traversal</dt>
<dd>A <a class="reference internal" href="#term-tree-traversal"><em class="xref std std-term ODSAterm">tree traversal</em></a> that does not need to visit every node
in the tree.
An example would be a <a class="reference internal" href="#term-range-query"><em class="xref std std-term ODSAterm">range query</em></a> in a <a class="reference internal" href="#term-bst"><em class="xref std std-term ODSAterm">BST</em></a>.</dd>
<dt id="term-halting-problem">halting problem</dt>
<dd>The halting problem is to answer this question:
Given a computer program <span class="math">\(P\)</span> and an
input <span class="math">\(I\)</span>, will program <span class="math">\(P\)</span> halt when executed on
input <span class="math">\(I\)</span>?
This problem has been proved impossible to solve in the general
case.
Thus, it is an example of an <a class="reference internal" href="#term-unsolveable-problem"><em class="xref std std-term ODSAterm">unsolveable problem</em></a>.</dd>
<dt id="term-handle">handle</dt>
<dd>When using a <a class="reference internal" href="#term-memory-manager"><em class="xref std std-term ODSAterm">memory manager</em></a> to store data, the
<a class="reference internal" href="#term-client"><em class="xref std std-term ODSAterm">client</em></a> will pass data to be stored
(the <a class="reference internal" href="#term-message"><em class="xref std std-term ODSAterm">message</em></a>) to the memory manager, and the memory
manager will return to the client a handle.
The handle encodes the necessary information that the memory
manager can later use to recover and return the message to the
client.
This is typically the location and length of the message within
the <a class="reference internal" href="#term-memory-pool"><em class="xref std std-term ODSAterm">memory pool</em></a>.</dd>
<dt id="term-hard-algorithm">hard algorithm</dt>
<dd>&quot;Hard&quot; is traditionally defined in relation to running time, and
a &quot;hard&quot; algorithm is defined to be an algorithm with exponential
running time.</dd>
<dt id="term-hard-problem">hard problem</dt>
<dd>&quot;Hard&quot; is traditionally defined in relation to running time, and
a &quot;hard&quot; problem is defined to be one whose best known algorithm
requires exponential running time.</dd>
<dt id="term-harmonic-series">harmonic series</dt>
<dd>The sum of reciprocals from 1 to <span class="math">\(n\)</span> is called the
Harmonic Series, and is written <span class="math">\({\cal H}_n\)</span>.
This sum has a value between <span class="math">\(\log_e n\)</span> and
<span class="math">\(\log_e n + 1\)</span>.</dd>
<dt id="term-hash-function">hash function</dt>
<dd>In a <a class="reference internal" href="#term-hash-system"><em class="xref std std-term ODSAterm">hash system</em></a>, the function that converts a
<a class="reference internal" href="#term-key"><em class="xref std std-term ODSAterm">key</em></a> value to a position in the <a class="reference internal" href="#term-hash-table"><em class="xref std std-term ODSAterm">hash table</em></a>.
The hope is that this position in the hash table contains the
record that matches the key value.</dd>
<dt id="term-hash-system">hash system</dt>
<dd>The implementation for search based on hash lookup in a
<a class="reference internal" href="#term-hash-table"><em class="xref std std-term ODSAterm">hash table</em></a>.
The <a class="reference internal" href="#term-search-key"><em class="xref std std-term ODSAterm">search key</em></a> is processed by a
<a class="reference internal" href="#term-hash-function"><em class="xref std std-term ODSAterm">hash function</em></a>, which returns a position in a
<a class="reference internal" href="#term-hash-table"><em class="xref std std-term ODSAterm">hash table</em></a>, which hopefully is the correct position in
which to find the record corresponding to the search key.</dd>
<dt id="term-hash-table">hash table</dt>
<dd>The data structure (usually an array) that stores data
records for lookup using <a class="reference internal" href="#term-hashing"><em class="xref std std-term ODSAterm">hashing</em></a>.</dd>
<dt id="term-hashing">hashing</dt>
<dd>A search method that uses a <a class="reference internal" href="#term-hash-function"><em class="xref std std-term ODSAterm">hash function</em></a> to convert a
<a class="reference internal" href="#term-search-key"><em class="xref std std-term ODSAterm">search key</em></a> value into a position within a
<a class="reference internal" href="#term-hash-table"><em class="xref std std-term ODSAterm">hash table</em></a>.
In a properly implemented <a class="reference internal" href="#term-hash-system"><em class="xref std std-term ODSAterm">hash system</em></a>, that position in
the table will have high probability of containing the record
that matches the key value.
Sometimes, the hash function will return an position that does
not store the desired key, due to a process called
<a class="reference internal" href="#term-collision"><em class="xref std std-term ODSAterm">collision</em></a>.
In that case, the desired record is found through a process
known as <a class="reference internal" href="#term-collision-resolution"><em class="xref std std-term ODSAterm">collision resolution</em></a>.</dd>
<dt id="term-head">head</dt>
<dd>The beginning of a <a class="reference internal" href="#term-list"><em class="xref std std-term ODSAterm">list</em></a>.</dd>
<dt id="term-header-node">header node</dt>
<dd>Commonly used in implementations for a <a class="reference internal" href="#term-linked-list"><em class="xref std std-term ODSAterm">linked list</em></a> or
related structure, this <a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">node</em></a> preceeds the first element
of the list.
Its purpose is to simplify the code implementation by
reducing the number of special cases that must be programmed
for.</dd>
<dt id="term-heap">heap</dt>
<dd>This term has two different meanings.
Uncommonly, it is a synonym for <a class="reference internal" href="#term-free-store"><em class="xref std std-term ODSAterm">free store</em></a>.
Most often it is used to refer to a particular data structure.
This data structure is a <a class="reference internal" href="#term-complete-binary-tree"><em class="xref std std-term ODSAterm">complete binary tree</em></a> with the
requirement that every <a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">node</em></a> has a value greater than its
<a class="reference internal" href="#term-child"><em class="xref std std-term ODSAterm">children</em></a> (called a <a class="reference internal" href="#term-max-heap"><em class="xref std std-term ODSAterm">max heap</em></a>), or else
the requirement that every node has a value less than its
children (called a <a class="reference internal" href="#term-min-heap"><em class="xref std std-term ODSAterm">min heap</em></a>).
Since it is a complete binary tree, a heap is nearly always
implemented using an array rather than an explicit tree
structure.
To add a new value to a heap, or to remove the extreme value
(the max value in a max-heap or min value in a min-heap) and
update the heap,
takes <span class="math">\(\Theta(\log n)\)</span> time in the <a class="reference internal" href="#term-worst-case"><em class="xref std std-term ODSAterm">worst case</em></a>.
However, if given all of the values in an unordered array,
the values can be re-arranged to form a heap in only
<span class="math">\(\Theta(n)\)</span> time.
Due to its space and time efficiency, the heap is a
popular choice for implementing a <a class="reference internal" href="#term-priority-queue"><em class="xref std std-term ODSAterm">priority queue</em></a>.</dd>
<dt id="term-heapsort">Heapsort</dt>
<dd>A sorting algorithm that costs <span class="math">\(\Theta(n \log n)\)</span> time in
the :term`best &lt;best case&gt;`, <a class="reference internal" href="#term-average-case"><em class="xref std std-term ODSAterm">average</em></a>,
and <a class="reference internal" href="#term-worst-case"><em class="xref std std-term ODSAterm">worst</em></a> cases.
It tends to be slower than <a class="reference internal" href="#term-mergesort"><em class="xref std std-term ODSAterm">Mergesort</em></a> and
<a class="reference internal" href="#term-quicksort"><em class="xref std std-term ODSAterm">Quicksort</em></a>.
It works by building a <a class="reference internal" href="#term-max-heap"><em class="xref std std-term ODSAterm">max heap</em></a>, and
then repeatedly removing the item with maximum <a class="reference internal" href="#term-key"><em class="xref std std-term ODSAterm">key</em></a> value
(moving it to the end of the heap) until all elements have been
removed (and replaced at their proper location in the array).</dd>
<dt id="term-height">height</dt>
<dd>The height of a tree is one more than the <a class="reference internal" href="#term-depth"><em class="xref std std-term ODSAterm">depth</em></a> of the
deepest <a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">node</em></a> in the tree.</dd>
<dt id="term-height-balanced">height balanced</dt>
<dd>The condition the <a class="reference internal" href="#term-depth"><em class="xref std std-term ODSAterm">depths</em></a> of each <a class="reference internal" href="#term-subtree"><em class="xref std std-term ODSAterm">subtree</em></a>
in a tree are roughly the same.</dd>
<dt id="term-heuristic">heuristic</dt>
<dd>A way to solve a problem that is not guarenteed to be optimal.
While it might not be guarenteed to be optimal, it is generally
expected (by the agent employing the heuristic) to provide a
reasonably efficient solution.</dd>
<dt id="term-home-position">home position</dt>
<dd>In <a class="reference internal" href="#term-hashing"><em class="xref std std-term ODSAterm">hashing</em></a>, a synonym for <a class="reference internal" href="#term-home-slot"><em class="xref std std-term ODSAterm">home slot</em></a>.</dd>
<dt id="term-home-slot">home slot</dt>
<dd>In <a class="reference internal" href="#term-hashing"><em class="xref std std-term ODSAterm">hashing</em></a>, this is the <a class="reference internal" href="#term-slot"><em class="xref std std-term ODSAterm">slot</em></a> in the
<a class="reference internal" href="#term-hash-table"><em class="xref std std-term ODSAterm">hash table</em></a> determined for a given key by the
<a class="reference internal" href="#term-hash-function"><em class="xref std std-term ODSAterm">hash function</em></a>.</dd>
<dt id="term-homogeneity">homogeneity</dt>
<dd>In a <a class="reference internal" href="#term-container"><em class="xref std std-term ODSAterm">container</em></a> class, this is the property that all
objects stored in the ncontainer are of the same class.
For example, if you have a list intended to store Payroll
records, is it possible for the programmer to insert an integer
onto the list instead?</dd>
<dt id="term-huffman-codes">Huffman codes</dt>
<dd>The codes given to a collection of letters (or other symbols)
through the process of Huffman coding.
Huffman coding uses a <a class="reference internal" href="#term-huffman-coding-tree"><em class="xref std std-term ODSAterm">Huffman coding tree</em></a> to generate
the codes.
The codes can be of variable length, such that the letters which
are expected to appear most frequently are shorter.
Huffman coding is optimal whenever the true frequencies are
known, and the frequency of a letter is independent of the
context of that letter in the message.</dd>
<dt id="term-huffman-coding-tree">Huffman coding tree</dt>
<dd>A Huffman coding tree is a <a class="reference internal" href="#term-full-tree"><em class="xref std std-term ODSAterm">full binary tree</em></a>
that is used to represent letters (or other symbols)
efficiently.
Each letter is associated with a node in the tree, and is then
given a <a class="reference internal" href="#term-huffman-codes"><em class="xref std std-term ODSAterm">Huffman code</em></a> based on the
position of the associated node.
A Huffman coding tree is an example of a binary <a class="reference internal" href="#term-trie"><em class="xref std std-term ODSAterm">trie</em></a>.</dd>
<dt id="term-huffman-tree">Huffman tree</dt>
<dd>Shorter form of the term <a class="reference internal" href="#term-huffman-coding-tree"><em class="xref std std-term ODSAterm">Huffman coding tree</em></a>.</dd>
<dt id="term-i-o-head">I/O head</dt>
<dd>On a <a class="reference internal" href="#term-disk-drive"><em class="xref std std-term ODSAterm">disk drive</em></a> (or similar device), the part of the
machinery that actually reads data from the disk.</dd>
<dt id="term-image-space-decomposition">image space decomposition</dt>
<dd>A from of <a class="reference internal" href="#term-key-space-decomposition"><em class="xref std std-term ODSAterm">key space decomposition</em></a> where the
<a class="reference internal" href="#term-key-space"><em class="xref std std-term ODSAterm">key space</em></a> splitting points is predetermined (typically
by splitting in half).
For example, a <a class="reference internal" href="#term-huffman-coding-tree"><em class="xref std std-term ODSAterm">Huffman coding tree</em></a> splits the letters
being coded into those with codes that start with 0 on the left
side, and those with codes that start with 1 on the right side.
This regular decomposition of the key space is the basis for a
<a class="reference internal" href="#term-trie"><em class="xref std std-term ODSAterm">trie</em></a> data structure.
An image space decomposition is in opposition to an
<a class="reference internal" href="#term-object-space-decomposition"><em class="xref std std-term ODSAterm">object space decomposition</em></a>.</dd>
<dt id="term-in-degree">in degree</dt>
<dd>In <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> terminology, the in degree for a <a class="reference internal" href="#term-vertex"><em class="xref std std-term ODSAterm">vertex</em></a> is
the number of edges directed into the vertex.</dd>
<dt id="term-incident">incident</dt>
<dd>In <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> terminology,
an edge connecting two vertices is said to be incident with
those vertices.
The two vertices are said to be <a class="reference internal" href="#term-adjacent"><em class="xref std std-term ODSAterm">adjacent</em></a>.</dd>
<dt id="term-index-file">index file</dt>
<dd>A file whose records consist of
<a class="reference internal" href="#term-key-value-pair"><em class="xref std std-term ODSAterm">key-value pairs</em></a> where the
pointers are referencing the complete records stored in another
file.</dd>
<dt id="term-indexing">indexing</dt>
<dd>The process of associating a <a class="reference internal" href="#term-search-key"><em class="xref std std-term ODSAterm">search key</em></a> with the
location of a corresponding data record.
The two defining points to the concept of an index is the
association of a key with a record, and the fact that the index
does not actually store the record itself but rather it stores a
<a class="reference internal" href="#term-reference"><em class="xref std std-term ODSAterm">reference</em></a> to the record.
In this way, a collection of records can be supported by
multiple indices, typically a separate index for each key field
in the record.</dd>
<dt id="term-induction-hypothesis">induction hypothesis</dt>
<dd>The key assumption used in a <a class="reference internal" href="#term-proof-by-induction"><em class="xref std std-term ODSAterm">proof by induction</em></a>,
that the theorem to be proved holds for smaller instances of the
theorem.
The induction hypothesis is equivalent to the
<a class="reference internal" href="#term-recursion"><em class="xref std std-term ODSAterm">recursive</em></a>
call in a recursive function.</dd>
<dt id="term-induction-step">induction step</dt>
<dd>Part of a <a class="reference internal" href="#term-proof-by-induction"><em class="xref std std-term ODSAterm">proof by induction</em></a>.
In its simplest form, this is a proof of the implication that if
the theorem holds for $n-1$, then it holds for $n$.
As an alternative, see <a class="reference internal" href="#term-strong-induction"><em class="xref std std-term ODSAterm">strong induction</em></a>.</dd>
<dt id="term-induction-variable">induction variable</dt>
<dd>The variable used to parameterize the theorem being proved by
induction.
For example, if we seek to prove that the sum of the integers
from 1 to $n$ is $n(n+1)/2$, then $n$ is the induction
variable.
An induction variable must be an integer.</dd>
<dt id="term-information-theoretic-lower-bound">information theoretic lower bound</dt>
<dd>A <a class="reference internal" href="#term-lower-bound"><em class="xref std std-term ODSAterm">lower bound</em></a> on the amount of resources needed to solve
a <a class="reference internal" href="#term-problem"><em class="xref std std-term ODSAterm">problem</em></a> based on the number of bits of information
needed to uniquely specify the answer.
Sometimes referred to as a &quot;Shannon theoretic lower bound&quot; due
to Shannon's work on information theory and entropy.
An example is that sorting has a lower bound of
<span class="math">\(\Omega(\log_2 n!)\)</span> because there are <span class="math">\(n!\)</span> possible
orderings for <span class="math">\(n\)</span> values.
This observation alone does not make the lower bound tight,
because it is possible that no algorithm could actually reach
the information theory lower limit.</dd>
<dt id="term-inherit">inherit</dt>
<dd>In <a class="reference internal" href="#term-object-oriented-programming-paradigm"><em class="xref std std-term ODSAterm">object-oriented programming</em></a>,
the process by which a <a class="reference internal" href="#term-subclass"><em class="xref std std-term ODSAterm">subclass</em></a> gains
<a class="reference internal" href="#term-data-member"><em class="xref std std-term ODSAterm">data members</em></a> and <a class="reference internal" href="#term-method"><em class="xref std std-term ODSAterm">methods</em></a>
from a <a class="reference internal" href="#term-base-class"><em class="xref std std-term ODSAterm">base class</em></a>.</dd>
<dt id="term-inode">inode</dt>
<dd>Short for &quot;index node&quot;.
In UNIX-style file systems, specific disk <a class="reference internal" href="#term-sector"><em class="xref std std-term ODSAterm">sectors</em></a>
that hold indexing information to define the layout of the file
system.</dd>
<dt id="term-inorder-traversal">inorder traversal</dt>
<dd>In a <a class="reference internal" href="#term-binary-tree"><em class="xref std std-term ODSAterm">binary tree</em></a>, a <a class="reference internal" href="#term-traversal"><em class="xref std std-term ODSAterm">traversal</em></a> that first
<a class="reference internal" href="#term-recursion"><em class="xref std std-term ODSAterm">recursively</em></a> <a class="reference internal" href="#term-visit"><em class="xref std std-term ODSAterm">visits</em></a> the left
<a class="reference internal" href="#term-child"><em class="xref std std-term ODSAterm">child</em></a>, then visits the <a class="reference internal" href="#term-root"><em class="xref std std-term ODSAterm">root</em></a>,
an then recursively visits the right child.
In a <a class="reference internal" href="#term-binary-search-tree"><em class="xref std std-term ODSAterm">binary search tree</em></a>, this traversal will
<a class="reference internal" href="#term-enumeration"><em class="xref std std-term ODSAterm">enumerate</em></a> the nodes in sorted order.</dd>
<dt id="term-insertion-sort">Insertion Sort</dt>
<dd>A sorting algorithm with <span class="math">\(\Theta(n^2)\)</span>
:term`average &lt;average case&gt;` and <a class="reference internal" href="#term-worst-case"><em class="xref std std-term ODSAterm">worst case</em></a> cost,
and <span class="math">\(Theta(n)\)</span> <a class="reference internal" href="#term-best-case"><em class="xref std std-term ODSAterm">best case</em></a> cost.
This best case cost makes it useful when we have reason to
expect the input to be nearly sorted.</dd>
<dt id="term-instance-variable">instance variable</dt>
<dd>In <a class="reference internal" href="#term-object-oriented-programming-paradigm"><em class="xref std std-term ODSAterm">object-oriented programming</em></a>,
a synonym for <a class="reference internal" href="#term-data-member"><em class="xref std std-term ODSAterm">data member</em></a>.</dd>
<dt id="term-inter-sector-gap">inter-sector gap</dt>
<dd>On a disk drive, a physical gap in the data that occurs between
the <a class="reference internal" href="#term-sector"><em class="xref std std-term ODSAterm">sectors</em></a>.
This allows the <a class="reference internal" href="#term-i-o-head"><em class="xref std std-term ODSAterm">I/O head</em></a> detect the end of the sector.</dd>
<dt id="term-internal-fragmentation">internal fragmentation</dt>
<dd>A condition that occurs when more than <span class="math">\(m\)</span> bytes
are allocated to service a <a class="reference internal" href="#term-memory-request"><em class="xref std std-term ODSAterm">memory request</em></a> for <span class="math">\(m\)</span>
bytes, wasting free storage.
This is often done to simplify
<a class="reference internal" href="#term-memory-manager"><em class="xref std std-term ODSAterm">memory management</em></a>.</dd>
<dt id="term-internal-node">internal node</dt>
<dd>In a tree, any node that has at least one non-empty
<a class="reference internal" href="#term-child"><em class="xref std std-term ODSAterm">child</em></a> is an  internal node.</dd>
<dt id="term-internal-sort">internal sort</dt>
<dd>A sorting algorithm that is applied to data stored in
<a class="reference internal" href="#term-main-memory"><em class="xref std std-term ODSAterm">main memory</em></a>.
This is in contrast to an <a class="reference internal" href="#term-external-sort"><em class="xref std std-term ODSAterm">external sort</em></a> that is meant to
work on data stored in
<a class="reference internal" href="#term-peripheral-storage"><em class="xref std std-term ODSAterm">peripheral storage</em></a> such as on a <a class="reference internal" href="#term-disk-drive"><em class="xref std std-term ODSAterm">disk drive</em></a>.</dd>
<dt id="term-inversion">inversion</dt>
<dd>A measure of how disordered a series of values is. For each
element <span class="math">\(X\)</span> in the series, count one inversion for each
element to left of <span class="math">\(X\)</span> that is greater than the value of
<span class="math">\(X\)</span> (and so must ultimately be moved to the right of
<span class="math">\(X\)</span> during a sorting process).</dd>
<dt id="term-inverted-file">inverted file</dt>
<dd>Synonym for <a class="reference internal" href="#term-inverted-list"><em class="xref std std-term ODSAterm">inverted list</em></a> when the inverted list is
stored in a disk file.</dd>
<dt id="term-inverted-list">inverted list</dt>
<dd>An <a class="reference internal" href="#term-indexing"><em class="xref std std-term ODSAterm">index</em></a> which links
<a class="reference internal" href="#term-secondary-key"><em class="xref std std-term ODSAterm">secondary keys</em></a> to either the associated
<a class="reference internal" href="#term-primary-key"><em class="xref std std-term ODSAterm">primary key</em></a> or the actual record in the database.</dd>
<dt id="term-irreflexive">irreflexive</dt>
<dd>In set notation, binary relation <span class="math">\(R\)</span> on set <span class="math">\(S\)</span> is
irreflexive if <span class="math">\(aRa\)</span> is never in the relation for
any <span class="math">\(a \in \mathbf{S}\)</span>.</dd>
<dt id="term-isam">ISAM</dt>
<dd>Indexed Sequential Access Method: an obsolete method for
indexing data for (at the time) fast retrieval. More generally,
the term is used also to generically refer to an
<a class="reference internal" href="#term-indexing"><em class="xref std std-term ODSAterm">index</em></a> that supports both sequential and
<a class="reference internal" href="#term-key"><em class="xref std std-term ODSAterm">keyed</em></a> access to data records.
Today, that would nearly always be implemented using a
<a class="reference internal" href="#term-37"><em class="xref std std-term ODSAterm">B-Tree</em></a>.</dd>
<dt id="term-iterator">iterator</dt>
<dd>In a <a class="reference internal" href="#term-container"><em class="xref std std-term ODSAterm">container</em></a> such as a List, a separate class that
indicates position within the container, with support for
<a class="reference internal" href="#term-traversal"><em class="xref std std-term ODSAterm">traversing</em></a> through all
<a class="reference internal" href="#term-element"><em class="xref std std-term ODSAterm">elements</em></a> in the container.</dd>
<dt id="term-job">job</dt>
<dd>Common name for processes or tasks to be run by an operating
system.
They typically need to be processed in order of
importance, and so are kept organized by a
<a class="reference internal" href="#term-priority-queue"><em class="xref std std-term ODSAterm">priority queue</em></a>.
Another common use for this term is for a collection of tasks to
be ordered by a <a class="reference internal" href="#term-topological-sort"><em class="xref std std-term ODSAterm">topological sort</em></a>.</dd>
<dt id="term-k-ary-tree">K-ary tree</dt>
<dd>A type of <a class="reference internal" href="#term-full-tree"><em class="xref std std-term ODSAterm">full tree</em></a> where every internal node has
exactly <span class="math">\(K\)</span> <a class="reference internal" href="#term-child"><em class="xref std std-term ODSAterm">children</em></a>.</dd>
<dt id="term-k-path">k-path</dt>
<dd>In <a class="reference internal" href="#term-floyd-s-algorithm"><em class="xref std std-term ODSAterm">Floyd's algorithm</em></a>, a k-path is a path between two
vertices <span class="math">\(i\)</span> and <span class="math">\(j\)</span> that can only go through
vertices with an index value less than or equal to <span class="math">\(k\)</span>.</dd>
<dt id="term-kd-tree">kd tree</dt>
<dd>A <a class="reference internal" href="#term-spatial-data-structure"><em class="xref std std-term ODSAterm">spatial data structure</em></a> that uses a binary tree to
store a collection of data records based on their (point)
location in space.
It uses the concept of a <a class="reference internal" href="#term-discriminator"><em class="xref std std-term ODSAterm">discriminator</em></a> at each level to
decide which single component of the
<a class="reference internal" href="#term-multi-dimensional-search-key"><em class="xref std std-term ODSAterm">multi-dimensional search key</em></a> to branch on at that level.
It uses a <a class="reference internal" href="#term-key-space-decomposition"><em class="xref std std-term ODSAterm">key space decomposition</em></a>, meaning that all data
records in the left subtree of a node have a value on the
corresponding discriminator that is less than that of the node,
while all data records in the right subtree have a greater
value.
The <a class="reference internal" href="#term-bintree"><em class="xref std std-term ODSAterm">bintree</em></a> is the <a class="reference internal" href="#term-image-space-decomposition"><em class="xref std std-term ODSAterm">image space decomposition</em></a>
analog of the kd tree.</dd>
<dt id="term-key">key</dt>
<dd>A field or part of a larger record used to represent that record
for the purpose of searching or comparing.
Another term for <a class="reference internal" href="#term-search-key"><em class="xref std std-term ODSAterm">search key</em></a>.</dd>
<dt id="term-key-sort">key sort</dt>
<dd>Any sorting opertation applied to a collection of
<a class="reference internal" href="#term-key-value-pair"><em class="xref std std-term ODSAterm">key-value pairs</em></a> where the value in this
case is a reference to a complete record (that is, a pointer to
the record in memory or a position for a record on disk).
This is in contrast to a sorting operation that works directly
on a collection of records.
The intention is that the collection of key-value pairs is far
smaller than the collection of records themselves.
As such, this might allow for an <a class="reference internal" href="#term-internal-sort"><em class="xref std std-term ODSAterm">internal sort</em></a> when
sorting the records directly would require an <a class="reference internal" href="#term-external-sort"><em class="xref std std-term ODSAterm">external
sort</em></a>.
The collection of key-value pairs can also act as an
<a class="reference internal" href="#term-indexing"><em class="xref std std-term ODSAterm">index</em></a>.</dd>
<dt id="term-key-space">key space</dt>
<dd>The range of values that a <a class="reference internal" href="#term-key"><em class="xref std std-term ODSAterm">key</em></a> value may take on.</dd>
<dt id="term-key-space-decomposition">key space decomposition</dt>
<dd>The idea that the range for a <a class="reference internal" href="#term-search-key"><em class="xref std std-term ODSAterm">search key</em></a> will be split
into pieces.
There are two general approaches to this:
<a class="reference internal" href="#term-object-space-decomposition"><em class="xref std std-term ODSAterm">object space decomposition</em></a> and
<a class="reference internal" href="#term-image-space-decomposition"><em class="xref std std-term ODSAterm">image space decomposition</em></a>.</dd>
<dt id="term-key-value-pair">key-value pair</dt>
<dd>A standard solution for solving the problem of how to relate a
<a class="reference internal" href="#term-key"><em class="xref std std-term ODSAterm">key</em></a> value to a record (or how to find the key for a
given record) within the context of a particular
<a class="reference internal" href="#term-indexing"><em class="xref std std-term ODSAterm">index</em></a>.
The idea is to simply store as records in the index pairs of
keys and records.
Specifically, the index will typically store a copy of the key
along with a reference to the record.
The other standard solution to this problem is to pass a
<a class="reference internal" href="#term-comparator"><em class="xref std std-term ODSAterm">comparator</em></a> function to the index.</dd>
<dt id="term-kruskal-s-algorithm">Kruskal's algorithm</dt>
<dd>An algorithm for computing the <a class="reference internal" href="#term-mcst"><em class="xref std std-term ODSAterm">MCST</em></a> of a
<a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a>.
During processing, it makes use of the <a class="reference internal" href="#term-union-find"><em class="xref std std-term ODSAterm">UNION/FIND</em></a>
process to efficiently determine of two vertices are within the
same <a class="reference internal" href="#term-subgraph"><em class="xref std std-term ODSAterm">subgraph</em></a>.</dd>
<dt id="term-labeled-graph">labeled graph</dt>
<dd>A <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> with labels associated with the
<a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">nodes</em></a>.</dd>
<dt id="term-las-vegas-algorithms">Las Vegas algorithms</dt>
<dd>A form of <a class="reference internal" href="#term-randomized-algorithm"><em class="xref std std-term ODSAterm">randomized algorithm</em></a>.
We always find the maximum value, and &quot;usually&quot; we find it fast.
Such algorithms have a guaranteed result, but do not guarantee fast
running time.</dd>
<dt id="term-leaf-node">leaf node</dt>
<dd>In a <a class="reference internal" href="#term-binary-tree"><em class="xref std std-term ODSAterm">binary tree</em></a>, leaf node is any node that has two
empty <a class="reference internal" href="#term-child"><em class="xref std std-term ODSAterm">children</em></a>.
(Note that a binary tree is defined so that every
node has two children, and that is why the leaf node has to have
two empty children, rather than no children.)
In a general tree, any node is a leaf node if it has no children.</dd>
<dt id="term-least-frequently-used">least frequently used</dt>
<dd>Abbreviated <a class="reference internal" href="#term-lfu"><em class="xref std std-term ODSAterm">LFU</em></a>, it is a <a class="reference internal" href="#term-heuristic"><em class="xref std std-term ODSAterm">heuristic</em></a> that can be
used to decide which <a class="reference internal" href="#term-buffer"><em class="xref std std-term ODSAterm">buffer</em></a> in a <a class="reference internal" href="#term-buffer-pool"><em class="xref std std-term ODSAterm">buffer pool</em></a>
to <a class="reference internal" href="#term-209"><em class="xref std std-term ODSAterm">flush</em></a> when data in the buffer pool must be
replaced by new data being read into a
<a class="reference internal" href="#term-caching"><em class="xref std std-term ODSAterm">cache</em></a>.
However, <a class="reference internal" href="#term-least-recently-used"><em class="xref std std-term ODSAterm">least recently used</em></a> is more popular than LFU.
Analogous to the <a class="reference internal" href="#term-frequency-count"><em class="xref std std-term ODSAterm">frequency count</em></a> heuristic for
maintaining a <a class="reference internal" href="#term-self-organizing-list"><em class="xref std std-term ODSAterm">self-organizing list</em></a>.</dd>
<dt id="term-least-recently-used">least recently used</dt>
<dd>Abbreviated <a class="reference internal" href="#term-lru"><em class="xref std std-term ODSAterm">LRU</em></a>, it is a popular <a class="reference internal" href="#term-heuristic"><em class="xref std std-term ODSAterm">heuristic</em></a> to
use for deciding which <a class="reference internal" href="#term-buffer"><em class="xref std std-term ODSAterm">buffer</em></a> in a <a class="reference internal" href="#term-buffer-pool"><em class="xref std std-term ODSAterm">buffer pool</em></a>
to <a class="reference internal" href="#term-209"><em class="xref std std-term ODSAterm">flush</em></a> when data in the buffer pool must be
replaced by new data being read into a <a class="reference internal" href="#term-caching"><em class="xref std std-term ODSAterm">cache</em></a>.
Analogous to the <a class="reference internal" href="#term-move-to-front"><em class="xref std std-term ODSAterm">move-to-front</em></a> heuristic for
maintaining a <a class="reference internal" href="#term-self-organizing-list"><em class="xref std std-term ODSAterm">self-organizing list</em></a>.</dd>
<dt id="term-length">length</dt>
<dd>In a <a class="reference internal" href="#term-list"><em class="xref std std-term ODSAterm">list</em></a>, the number of elements. In a string, the
number of characters.</dd>
<dt id="term-level">level</dt>
<dd>In a tree, all nodes of <a class="reference internal" href="#term-depth"><em class="xref std std-term ODSAterm">depth</em></a> <span class="math">\(d\)</span> are at
level <span class="math">\(d\)</span> in the tree.
The root is the only node at level 0, and its depth is 0.</dd>
<dt id="term-lexical-scoping">lexical scoping</dt>
<dd>Lexical scoping, also known as static scoping, of a variable so
that it may only referenced in the block of code in which the
variable is defined.</dd>
<dt id="term-lfu">LFU</dt>
<dd>Abbreviation for <a class="reference internal" href="#term-least-frequently-used"><em class="xref std std-term ODSAterm">least frequently used</em></a>.</dd>
<dt id="term-lifetime">lifetime</dt>
<dd>For a variable, lifetime is the amount of time it will exist
before it is destroyed.</dd>
<dt id="term-lifo">LIFO</dt>
<dd>Abbreviation for &quot;Last-In, First-Out&quot;.
This is the access paradigm for a <a class="reference internal" href="#term-stack"><em class="xref std std-term ODSAterm">stack</em></a>,
and an old terminolgy for the stack is &quot;LIFO list&quot;.</dd>
<dt id="term-linear-growth-rate">linear growth rate</dt>
<dd>For input size <span class="math">\(n\)</span>, a growth rate of <span class="math">\(cn\)</span> (for
<span class="math">\(c\)</span> any positive constant).
In other words, the cost of
the associated function is linear on the input size.</dd>
<dt id="term-linear-index">linear index</dt>
<dd>A form of <a class="reference internal" href="#term-indexing"><em class="xref std std-term ODSAterm">indexing</em></a> that stores
<a class="reference internal" href="#term-key-value-pair"><em class="xref std std-term ODSAterm">key-value pairs</em></a> in a sorted array.
Typically this is used for an index to a large collection of
records stored on disk, where the linear index itself might be
on disk or in <a class="reference internal" href="#term-main-memory"><em class="xref std std-term ODSAterm">main memory</em></a>.
It allows for efficient search (including for
<a class="reference internal" href="#term-range-query"><em class="xref std std-term ODSAterm">range queries</em></a>), but it is not good for
inserting and deleting entries in the array.
Therefore, it is an ideal indexing structure when the system
needs to do range queries but the collection of records never
changes once the linear index has been created.</dd>
<dt id="term-linear-order">linear order</dt>
<dd>Another term for <a class="reference internal" href="#term-total-order"><em class="xref std std-term ODSAterm">total order</em></a>.</dd>
<dt id="term-linear-probing">linear probing</dt>
<dd>In <a class="reference internal" href="#term-hashing"><em class="xref std std-term ODSAterm">hashing</em></a>, this is the simplest
<a class="reference internal" href="#term-collision-resolution"><em class="xref std std-term ODSAterm">collision resolution</em></a> method.
Term <span class="math">\(i\)</span> of the <a class="reference internal" href="#term-probe-sequence"><em class="xref std std-term ODSAterm">probe sequence</em></a> is simply
<span class="math">\(i\)</span>, meaning that collision resolution works by moving
sequentially through the hash table from the <a class="reference internal" href="#term-home-slot"><em class="xref std std-term ODSAterm">home slot</em></a>.
While simple, it is also inefficient, since it quickly leads to
certain free <a class="reference internal" href="#term-slot"><em class="xref std std-term ODSAterm">slots</em></a> in the hash table having
higher probability of being selected during insertion or
search.</dd>
<dt id="term-linear-probing-by-steps">linear probing by steps</dt>
<dd>In <a class="reference internal" href="#term-hashing"><em class="xref std std-term ODSAterm">hashing</em></a>, this <a class="reference internal" href="#term-collision-resolution"><em class="xref std std-term ODSAterm">collision resolution</em></a> method is
a variation on simple <a class="reference internal" href="#term-linear-probing"><em class="xref std std-term ODSAterm">linear probing</em></a>.
Some constant <span class="math">\(c\)</span> is defined such that
term <span class="math">\(i\)</span> of the <a class="reference internal" href="#term-probe-sequence"><em class="xref std std-term ODSAterm">probe sequence</em></a> is
<span class="math">\(ci\)</span>.
This  means that collision resolution works by moving
sequentially through the hash table from the <a class="reference internal" href="#term-home-slot"><em class="xref std std-term ODSAterm">home slot</em></a>
in steps of size <span class="math">\(c\)</span>.
While not much improvement on linear probing, it forms the basis
of another collision resolution method called
<a class="reference internal" href="#term-double-hashing"><em class="xref std std-term ODSAterm">double hashing</em></a>, where each key uses a value for
<span class="math">\(c\)</span> defined by a second <a class="reference internal" href="#term-hash-function"><em class="xref std std-term ODSAterm">hash function</em></a>.</dd>
<dt id="term-linear-search">linear search</dt>
<dd>Another name for <a class="reference internal" href="#term-sequential-search"><em class="xref std std-term ODSAterm">sequential search</em></a>.</dd>
<dt id="term-link-node">link node</dt>
<dd>A widely used supporting object that forms the basic
building block for a <a class="reference internal" href="#term-linked-list"><em class="xref std std-term ODSAterm">linked list</em></a> and similar
<a class="reference internal" href="#term-data-structure"><em class="xref std std-term ODSAterm">data structures</em></a>.
A link node contains one or more fields that store data, and a
<a class="reference internal" href="#term-pointer"><em class="xref std std-term ODSAterm">pointer</em></a> or <a class="reference internal" href="#term-reference"><em class="xref std std-term ODSAterm">reference</em></a> to another link node.</dd>
<dt id="term-linked-list">linked list</dt>
<dd>An implementation for the list ADT that uses
<a class="reference internal" href="#term-dynamic-allocation"><em class="xref std std-term ODSAterm">dynamic allocation</em></a>
of <a class="reference internal" href="#term-link-node"><em class="xref std std-term ODSAterm">link nodes</em></a> to store the list elements.
Common variants are the <a class="reference internal" href="#term-singly-linked-list"><em class="xref std std-term ODSAterm">singly linked list</em></a>,
<a class="reference internal" href="#term-doubly-linked-list"><em class="xref std std-term ODSAterm">doubly linked list</em></a> and <a class="reference internal" href="#term-circular-list"><em class="xref std std-term ODSAterm">circular list</em></a>.
The <a class="reference internal" href="#term-overhead"><em class="xref std std-term ODSAterm">overhead</em></a> required is the pointers in each link node.</dd>
<dt id="term-linked-stack">linked stack</dt>
<dd>Analogous to a <a class="reference internal" href="#term-linked-list"><em class="xref std std-term ODSAterm">linked list</em></a>, this uses
<a class="reference internal" href="#term-dynamic-allocation"><em class="xref std std-term ODSAterm">dynamic allocation</em></a> of nodes to
store the elements when implementing the stack ADT.</dd>
<dt id="term-list">list</dt>
<dd>A finite, ordered sequence of data items known as
<a class="reference internal" href="#term-element"><em class="xref std std-term ODSAterm">elements</em></a>.
This is close to the mathematical concept of a <a class="reference internal" href="#term-sequence"><em class="xref std std-term ODSAterm">sequence</em></a>.
Note that &quot;ordered&quot; in this definition means that the list
elements have position.
It does not refer to the relationship
between <a class="reference internal" href="#term-key"><em class="xref std std-term ODSAterm">key</em></a> values for the list elements (that is,
&quot;ordered&quot; does not mean &quot;sorted&quot;).</dd>
<dt id="term-load-factor">load factor</dt>
<dd>In <a class="reference internal" href="#term-hashing"><em class="xref std std-term ODSAterm">hashing</em></a> this is the fraction of the <a class="reference internal" href="#term-hash-table"><em class="xref std std-term ODSAterm">hash
table</em></a> <a class="reference internal" href="#term-slot"><em class="xref std std-term ODSAterm">slots</em></a> that contain a record.
Hash systems usually try to keep the load factor below 50%.</dd>
<dt id="term-local-storage">local storage</dt>
<dd>local storage.</dd>
<dt id="term-local-variable"><span id="term-local-variables"></span>local variable<br />local variables</dt>
<dd>A variable declared within a function or method.
It exists only from the time when the function is called to when
the function exits.
When a function is suspended (due to calling another function),
the function's local variables are stored in an
<a class="reference internal" href="#term-activation-record"><em class="xref std std-term ODSAterm">activation record</em></a> on the <a class="reference internal" href="#term-runtime-stack"><em class="xref std std-term ODSAterm">runtime stack</em></a>.</dd>
<dt id="term-locality-of-reference">locality of reference</dt>
<dd>The concept that accesses within a collection of records is not
evenly distributed.
This can express itself as some small fraction of the records
receiving the bulk of the accesses (<a class="reference internal" href="#term-rule"><em class="xref std std-term ODSAterm">80/20 rule</em></a>).
Alternatively, it can express itself as an increased probability
that the next or future accesses will come close to the most
recent access.
This is the fundamental property for success of <a class="reference internal" href="#term-caching"><em class="xref std std-term ODSAterm">caching</em></a>.</dd>
<dt id="term-logarithm">logarithm</dt>
<dd>The <cite>logarithm</cite> of base <span class="math">\(b\)</span> for value <span class="math">\(y\)</span> is the power
to which <span class="math">\(b\)</span> is raised to get <span class="math">\(y\)</span>.</dd>
<dt id="term-logical-file">logical file</dt>
<dd>In <a class="reference internal" href="#term-file-processing"><em class="xref std std-term ODSAterm">file processing</em></a>, the programmer's view of a
<a class="reference internal" href="#term-random-access"><em class="xref std std-term ODSAterm">random access</em></a> file stored on <a class="reference internal" href="#term-disk-drive"><em class="xref std std-term ODSAterm">disk</em></a>
as a contiguous series of bytes, with those bytes possibly
combining to form data records.
This is in contrast to the <a class="reference internal" href="#term-physical-file"><em class="xref std std-term ODSAterm">physical file</em></a>.</dd>
<dt id="term-logical-form">logical form</dt>
<dd>The definition for a data type in terms of an ADT. Contrast to
the <a class="reference internal" href="#term-physical-form"><em class="xref std std-term ODSAterm">physical form</em></a> for the data type.</dd>
<dt id="term-lookup-table">lookup table</dt>
<dd>A table of pre-calculated values, used to speed up processing
time when the values are going to be viewed many times. The
costs to this approach are the space required for the table and
the time required to compute the table. This is an example of a
<a class="reference internal" href="#term-space-time-tradeoff"><em class="xref std std-term ODSAterm">space/time tradeoff</em></a>.</dd>
<dt id="term-lower-bound">lower bound</dt>
<dd>In <a class="reference internal" href="#term-algorithm-analysis"><em class="xref std std-term ODSAterm">algorithm analysis</em></a>, a <a class="reference internal" href="#term-growth-rate"><em class="xref std std-term ODSAterm">growth rate</em></a> that is
always less than or equal to the that of the
<a class="reference internal" href="#term-algorithm"><em class="xref std std-term ODSAterm">algorithm</em></a> in question.
In practice, this is the fastest-growing function that we know
grows no faster than all but a constant number of inputs.
It could be a gross under-estimate of the truth.
Since the lower bound for the algorithm can be very different
for different situations (such as the <a class="reference internal" href="#term-best-case"><em class="xref std std-term ODSAterm">best case</em></a> or
<a class="reference internal" href="#term-worst-case"><em class="xref std std-term ODSAterm">worst case</em></a>), we typically have to specify which
situation we are referring to.</dd>
<dt id="term-lower-bounds-proof">lower bounds proof</dt>
<dd>A proof regarding the lower bound, with this term most typically
referring to the lower bound for any possible algorithm to solve
a given <a class="reference internal" href="#term-problem"><em class="xref std std-term ODSAterm">problem</em></a>.
Many problems have a simple lower bound based on the concept
that the minimum amount of processing is related to looking at
all of the problem's input.
However, some problems have a higher lower bound than that.
For example, the lower bound for the problem of sorting
(<span class="math">\(\Omega(n \log n)\)</span>) is greater than the input size to
sorting (<span class="math">\(n\)</span>).
Proving such &quot;non-trivial&quot; lower bounds for problems is
notoriously difficult.</dd>
<dt id="term-lru">LRU</dt>
<dd>Abbreviation for <a class="reference internal" href="#term-least-recently-used"><em class="xref std std-term ODSAterm">least recently used</em></a>.</dd>
<dt id="term-main-memory">main memory</dt>
<dd>A synonym for <a class="reference internal" href="#term-primary-storage"><em class="xref std std-term ODSAterm">primary storage</em></a>.
In a computer, typically this will be <a class="reference internal" href="#term-ram"><em class="xref std std-term ODSAterm">RAM</em></a>.</dd>
<dt id="term-map">map</dt>
<dd>A <a class="reference internal" href="#term-data-structure"><em class="xref std std-term ODSAterm">data structure</em></a> that relates a <a class="reference internal" href="#term-key"><em class="xref std std-term ODSAterm">key</em></a> to a
<a class="reference internal" href="#term-record"><em class="xref std std-term ODSAterm">record</em></a>.</dd>
<dt id="term-mapping">mapping</dt>
<dd>A <a class="reference internal" href="#term-function"><em class="xref std std-term ODSAterm">function</em></a> that maps every element of a given
<a class="reference internal" href="#term-set"><em class="xref std std-term ODSAterm">set</em></a> to a unique element of another set; a
correspondence.</dd>
<dt id="term-mark-array">mark array</dt>
<dd>It is typical in <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> algorithms that there is a need
to track which nodes have been visited at some point in the
algorithm.
An array of bits or values called the <a class="reference internal" href="#term-mark-array"><em class="xref std std-term ODSAterm">mark array</em></a> is
often maintained for this purpose.</dd>
<dt id="term-mark-sweep-algorithm">mark/sweep algorithm</dt>
<dd>An algorithm for <a class="reference internal" href="#term-garbage-collection"><em class="xref std std-term ODSAterm">garbage collection</em></a>.
All accessible variables, and any space that is reachable by a
chain of pointers from any accessible variable, is &quot;marked&quot;.
Then a sequential sweep of all memory in the pool is made.
Any unmarked memory locations are assumed to not be needed by
the program and can be considered as free to be reused.</dd>
<dt id="term-master-theorem">master theorem</dt>
<dd>A theorem that makes it easy to solve
<a class="reference internal" href="#term-divide-and-conquer-recurrences"><em class="xref std std-term ODSAterm">divide-and-conquer recurrences</em></a>.</dd>
<dt id="term-max-heap">max heap</dt>
<dd>A <a class="reference internal" href="#term-heap"><em class="xref std std-term ODSAterm">heap</em></a> where every <a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">node</em></a> has a <a class="reference internal" href="#term-key"><em class="xref std std-term ODSAterm">key</em></a> value
greater than its <a class="reference internal" href="#term-child"><em class="xref std std-term ODSAterm">children</em></a>.
As a consequence, the node with maximum key value is
at the <a class="reference internal" href="#term-root"><em class="xref std std-term ODSAterm">root</em></a>.</dd>
<dt id="term-maximum-lower-bound">maximum lower bound</dt>
<dd>The <a class="reference internal" href="#term-lower-bound"><em class="xref std std-term ODSAterm">lower bound</em></a> for the <a class="reference internal" href="#term-problem"><em class="xref std std-term ODSAterm">problem</em></a> of finding the
maximum value in an unsorted list is <span class="math">\(\Omega(n)\)</span>.</dd>
<dt id="term-mcst"><span id="term-mst"></span>MCST<br />MST</dt>
<dd>Abbreviation for <a class="reference internal" href="#term-minimal-cost-spanning-tree"><em class="xref std std-term ODSAterm">minimal-cost spanning tree</em></a>.</dd>
<dt id="term-measure-of-cost">measure of cost</dt>
<dd>When comparing two things, such as two algorithms, some event or
unit must be used as the basic unit of comparison.
It might be number of milliseconds needed or machine instructions
expended by a program, but it is usually desirable to have a way
to do comparison between two algorithms without writing a
program.
Thus, some other measure of cost might be used as a basis for
comparison between the algorithms.
For example, when comparing two sorting algorthms it is
traditional to use as a measure of cost the number of
<a class="reference internal" href="#term-comparison"><em class="xref std std-term ODSAterm">comparisons</em></a> made between the key values of
record pairs.</dd>
<dt id="term-member">member</dt>
<dd>In set notation, this is a synonym for <a class="reference internal" href="#term-element"><em class="xref std std-term ODSAterm">element</em></a>.
In abstract design, a <a class="reference internal" href="#term-data-item"><em class="xref std std-term ODSAterm">data item</em></a> is a member of a <a class="reference internal" href="#term-type"><em class="xref std std-term ODSAterm">type</em></a>.
In an object-oriented language,
<a class="reference internal" href="#term-data-member"><em class="xref std std-term ODSAterm">data members</em></a> are data fields in an
object.</dd>
<dt id="term-member-function">member function</dt>
<dd>Each operation associated with the ADT is implemented by a
member function or <a class="reference internal" href="#term-method"><em class="xref std std-term ODSAterm">method</em></a>.</dd>
<dt id="term-memory-allocation">memory allocation</dt>
<dd>In a <a class="reference internal" href="#term-memory-manager"><em class="xref std std-term ODSAterm">memory manager</em></a>, the act of honoring a request for
memory.</dd>
<dt id="term-memory-deallocation">memory deallocation</dt>
<dd>In a <a class="reference internal" href="#term-memory-manager"><em class="xref std std-term ODSAterm">memory manager</em></a>, the act of freeing a block of
memory, which should create or add to a <a class="reference internal" href="#term-free-block"><em class="xref std std-term ODSAterm">free block</em></a>.</dd>
<dt id="term-memory-hierarchy">memory hierarchy</dt>
<dd>The concept that a computer system stores data in a range of
storage types that range from fast but expensive
(<a class="reference internal" href="#term-primary-storage"><em class="xref std std-term ODSAterm">primary storage</em></a>) to slow but cheap
(<a class="reference internal" href="#term-secondary-storage"><em class="xref std std-term ODSAterm">secondary storage</em></a>).
When there is too much data to store in <a class="reference internal" href="#term-primary-storage"><em class="xref std std-term ODSAterm">primary storage</em></a>,
the goal is to have the data that is needed soon or
most often in the primary storage as much as possible,
by using <a class="reference internal" href="#term-caching"><em class="xref std std-term ODSAterm">caching</em></a> techniques.</dd>
<dt id="term-memory-leak">memory leak</dt>
<dd>In programming, the act of creating <a class="reference internal" href="#term-garbage"><em class="xref std std-term ODSAterm">garbage</em></a>.
In languages such as C and C++ that do not support
<a class="reference internal" href="#term-garbage-collection"><em class="xref std std-term ODSAterm">garbage collection</em></a>, repeated memory leaks will evenually
cause the program to terminate.</dd>
<dt id="term-memory-manager">memory manager</dt>
<dd>Functionality for managing a <a class="reference internal" href="#term-memory-pool"><em class="xref std std-term ODSAterm">memory pool</em></a>.
Typically, the memory pool is viewed as an array of bytes by the
memory manager.
The <a class="reference internal" href="#term-client"><em class="xref std std-term ODSAterm">client</em></a> of the memory manager will request a
collection of (adjacent) bytes of some size, and release the
bytes for reuse when the space is no longer needed.
The memory manager should not know anything about the
interpretation of the data that is being stored by the client
into the memory pool.
Depending on the precise implementation, the client might pass
in the data to be stored, in which case the memory manager will
deal with the actual copy of the data into the memory pool.
The memory manager will return to the client a <a class="reference internal" href="#term-handle"><em class="xref std std-term ODSAterm">handle</em></a>
that can later be used by the client to retrieve the data.</dd>
<dt id="term-memory-pool">memory pool</dt>
<dd>Memory (usually in <a class="reference internal" href="#term-ram"><em class="xref std std-term ODSAterm">RAM</em></a> but possibly on disk or
<a class="reference internal" href="#term-peripheral-storage"><em class="xref std std-term ODSAterm">peripheral storage</em></a> device) that is logically viewed as
an array of memory positions.
A memory pool is usually managed by a <a class="reference internal" href="#term-memory-manager"><em class="xref std std-term ODSAterm">memory manager</em></a>.</dd>
<dt id="term-memory-request">memory request</dt>
<dd>In a <a class="reference internal" href="#term-memory-manager"><em class="xref std std-term ODSAterm">memory manager</em></a>, a request from some <a class="reference internal" href="#term-client"><em class="xref std std-term ODSAterm">client</em></a>
to the memory manager to reserve a block of memory and store
some bytes there.</dd>
<dt id="term-mergesort">Mergesort</dt>
<dd>A sorting algorithm that requires <span class="math">\(\Theta(n \log n)\)</span> in
the <a class="reference internal" href="#term-best-case"><em class="xref std std-term ODSAterm">best</em></a>, <a class="reference internal" href="#term-average-case"><em class="xref std std-term ODSAterm">average</em></a>,
and <a class="reference internal" href="#term-worst-case"><em class="xref std std-term ODSAterm">worst</em></a> cases.
Conceptually it is simple:
Split the list in half, sort the halves, then merge them
together.
It is a bit complicated to implement effiently on an array.</dd>
<dt id="term-message">message</dt>
<dd>In a <a class="reference internal" href="#term-memory-manager"><em class="xref std std-term ODSAterm">memory manager</em></a> implementation
(particularly a memory manager implemented with a
<a class="reference internal" href="#term-message-passing"><em class="xref std std-term ODSAterm">message passing</em></a> style of
interface), the message is the data that the <a class="reference internal" href="#term-client"><em class="xref std std-term ODSAterm">client</em></a> of
the memory manager wishes to have stored in the
<a class="reference internal" href="#term-memory-pool"><em class="xref std std-term ODSAterm">memory pool</em></a>.
The memory manager will reply to the client by returning a
<a class="reference internal" href="#term-handle"><em class="xref std std-term ODSAterm">handle</em></a> that defines the location and size of the message
as stored in the memory pool.
The client can later recover the message by passing the handle
back to the memory manager.</dd>
<dt id="term-message-passing">message passing</dt>
<dd>A common approach to implementing the <a class="reference internal" href="#term-adt"><em class="xref std std-term ODSAterm">ADT</em></a> for a
<a class="reference internal" href="#term-memory-manager"><em class="xref std std-term ODSAterm">memory manager</em></a> or <a class="reference internal" href="#term-buffer-pool"><em class="xref std std-term ODSAterm">buffer pool</em></a>, where the
contents of a <a class="reference internal" href="#term-message"><em class="xref std std-term ODSAterm">message</em></a> to be stored is explicitly
passed between the client and the memory manager.
This is in contrast to a <a class="reference internal" href="#term-buffer-passing"><em class="xref std std-term ODSAterm">buffer passing</em></a> approach.</dd>
<dt id="term-metaphor">metaphor</dt>
<dd>Humans deal with complexity by assigning a label to an assembly of
objects or concepts and then manipulating the label in place of the
assembly. Cognitive psychologists call such a label a
metaphor.</dd>
<dt id="term-method">method</dt>
<dd>In the <a class="reference internal" href="#term-object-oriented-programming-paradigm"><em class="xref std std-term ODSAterm">object-oriented programming paradigm</em></a>,
a method is an operation on a <a class="reference internal" href="#term-class"><em class="xref std std-term ODSAterm">class</em></a>.
A synonym for <a class="reference internal" href="#term-member-function"><em class="xref std std-term ODSAterm">member function</em></a>.</dd>
<dt id="term-mid-square-method">mid-square method</dt>
<dd>In <a class="reference internal" href="#term-hashing"><em class="xref std std-term ODSAterm">hashing</em></a>, an approach to implementing a
<a class="reference internal" href="#term-hash-function"><em class="xref std std-term ODSAterm">hash function</em></a>.
The key value is squared, and some number of bits from the
middle of the resulting value are extracted as the hash code.
Some care must be taken to extract bits that tend to actually be
in the middle of the resulting value, which requires some
understanding of the typical key values.
When done correctly, this has the advantage of having the hash
code be affected by all bits of the key</dd>
<dt id="term-min-heap">min heap</dt>
<dd>A <a class="reference internal" href="#term-heap"><em class="xref std std-term ODSAterm">heap</em></a> where every <a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">node</em></a> has a <a class="reference internal" href="#term-key"><em class="xref std std-term ODSAterm">key</em></a> value
less than its <a class="reference internal" href="#term-child"><em class="xref std std-term ODSAterm">children</em></a>.
As a consequence, the node with minimum key value is
at the <a class="reference internal" href="#term-root"><em class="xref std std-term ODSAterm">root</em></a>.</dd>
<dt id="term-minimal-cost-spanning-tree">minimal-cost spanning tree</dt>
<dd>Abbreviated as MCST, or sometimes as MST.
Derived from a <a class="reference internal" href="#term-weighted-graph"><em class="xref std std-term ODSAterm">weighted graph</em></a>, the MCST is the
<a class="reference internal" href="#term-subset"><em class="xref std std-term ODSAterm">subset</em></a> of the graph's <a class="reference internal" href="#term-edge"><em class="xref std std-term ODSAterm">edges</em></a> that
maintains the connectivitiy of the graph while having lowest
total cost (as defined by the sum of the
<a class="reference internal" href="#term-weight"><em class="xref std std-term ODSAterm">weights</em></a> of the edges in the MCST).
The result is referred to as a <a class="reference internal" href="#term-577"><em class="xref std std-term ODSAterm">tree</em></a> because it would
never have a <a class="reference internal" href="#term-cycle"><em class="xref std std-term ODSAterm">cycle</em></a> (since an edge could be removed from
the cycle and still preserve connectivity).
Two algorithms to solve this problem are
<a class="reference internal" href="#term-prim-s-algorithm"><em class="xref std std-term ODSAterm">Prim's algorithm</em></a> and <a class="reference internal" href="#term-kruskal-s-algorithm"><em class="xref std std-term ODSAterm">Kruskal's algorithm</em></a>.</dd>
<dt id="term-minimum-external-path-weight">minimum external path weight</dt>
<dd>Given a collection of objects, each associated with a
<a class="reference internal" href="#term-leaf-node"><em class="xref std std-term ODSAterm">leaf node</em></a> in a tree, the binary tree with minimum
external path weight is the one with the minimum sum of
<a class="reference internal" href="#term-weighted-path-length"><em class="xref std std-term ODSAterm">weighted path lengths</em></a> for the
given set of leaves.
This concept is used to create a <a class="reference internal" href="#term-huffman-coding-tree"><em class="xref std std-term ODSAterm">Huffman coding tree</em></a>,
where a letter with high weight should have low depth, so that
it will count the least against the total path length.
As a result, another letter might be pushed deeper in the tree
if it has less weight.</dd>
<dt id="term-mod">mod</dt>
<dd>Abbreviation for the <a class="reference internal" href="#term-modulus"><em class="xref std std-term ODSAterm">modulus</em></a> function.</dd>
<dt id="term-model">model</dt>
<dd>A simplification of reality that preserves only the essential
elements.
With a model, we can more easily focus on and reason about these
essentials.
In <a class="reference internal" href="#term-algorithm-analysis"><em class="xref std std-term ODSAterm">algorithm analysis</em></a>, we are especially concerned with
the <a class="reference internal" href="#term-cost-model"><em class="xref std std-term ODSAterm">cost model</em></a> for measuring the cost of an algorithm.</dd>
<dt id="term-modulus">modulus</dt>
<dd>The modulus function returns the
remainder of an integer division.
Sometimes written <span class="math">\(n \bmod m\)</span> in mathematical expressions,
the syntax in many programming languages is <code class="docutils literal"><span class="pre">n</span> <span class="pre">%</span> <span class="pre">m</span></code>.</dd>
<dt id="term-monte-carlo-algorithms">Monte Carlo algorithms</dt>
<dd>A form of <a class="reference internal" href="#term-randomized-algorithm"><em class="xref std std-term ODSAterm">randomized algorithm</em></a>.
We find the maximum value fast, or we don't get an answer at all
(but fast).
While such algorithms have good running time, their result is not
guaranteed.</dd>
<dt id="term-move-to-front">move-to-front</dt>
<dd>A <a class="reference internal" href="#term-heuristic"><em class="xref std std-term ODSAterm">heuristic</em></a> used to maintain a
<a class="reference internal" href="#term-self-organizing-list"><em class="xref std std-term ODSAterm">self-organizing list</em></a>.
Under this heuristic, whenever a record is accessed it is moved
to the front of the list.
Analogous to the <a class="reference internal" href="#term-least-recently-used"><em class="xref std std-term ODSAterm">least recently used</em></a> heuristic for
maintaining a <a class="reference internal" href="#term-buffer-pool"><em class="xref std std-term ODSAterm">buffer pool</em></a>.</dd>
<dt id="term-multi-dimensional-search-key">multi-dimensional search key</dt>
<dd>A search key containing multiple parts, that works in
conjunction with a <a class="reference internal" href="#term-multi-dimensional-search-structure"><em class="xref std std-term ODSAterm">multi-dimensional search structure</em></a>.
Most typically, a <a class="reference internal" href="#term-spatial"><em class="xref std std-term ODSAterm">spatial</em></a> search key representing a
position in multi-dimensional (2 or 3 dimensions) space.
But a multi-dimensional key could be used to organize data within
non-spatial dimensions, such as temperature and time.</dd>
<dt id="term-multi-dimensional-search-structure">multi-dimensional search structure</dt>
<dd>A data structure used to support efficient search on a
<a class="reference internal" href="#term-multi-dimensional-search-key"><em class="xref std std-term ODSAterm">multi-dimensional search key</em></a>.
The main concept here is that a multi-dimensional search
structure works more efficiently by considering the multiple
parts of the search key as a whole, rather than making
independent searches on each one-dimensional component of the
key.
A primary example is a <a class="reference internal" href="#term-spatial-data-structure"><em class="xref std std-term ODSAterm">spatial data structure</em></a> that can
efficiently represent and search for records in
multi-dimensional space.</dd>
<dt id="term-multilist">multilist</dt>
<dd>A list that may contain sublists.
This term is sometimes used as a synonym to the term
<a class="reference internal" href="#term-bag"><em class="xref std std-term ODSAterm">bag</em></a>.</dd>
<dt id="term-necessary-fallacy">necessary fallacy</dt>
<dd>A common mistake in a
<a class="reference internal" href="#term-lower-bounds-proof"><em class="xref std std-term ODSAterm">lower bounds proof</em></a> for a problem, where the proof makes
an inappropriate assumption that any algorithm must operate in
some manner (typically in the way that some known algorithm
behaves).</dd>
<dt id="term-neighbor">neighbor</dt>
<dd>In a <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a>, a <a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">node</em></a> <span class="math">\(w\)</span> is said to be a
neighbor of <a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">node</em></a> <span class="math">\(v\)</span> if there is an <a class="reference internal" href="#term-edge"><em class="xref std std-term ODSAterm">edge</em></a>
from <span class="math">\(v\)</span> to <span class="math">\(w\)</span>.</dd>
<dt id="term-node">node</dt>
<dd>The objects that make up a linked structure such as a linked
list or binary tree.
Typically, nodes are allocated using
<a class="reference internal" href="#term-dynamic-memory-allocation"><em class="xref std std-term ODSAterm">dynamic memory allocation</em></a>.
In <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> terminology, the nodes are more commonly called
<a class="reference internal" href="#term-vertex"><em class="xref std std-term ODSAterm">vertices</em></a>.</dd>
<dt id="term-non-deterministic-algorithm">non-deterministic algorithm</dt>
<dd>An algorithm that may operate using a
<a class="reference internal" href="#term-non-deterministic-choice"><em class="xref std std-term ODSAterm">non-deterministic choice</em></a> operation.</dd>
<dt id="term-non-deterministic-choice">non-deterministic choice</dt>
<dd>An operation that captures the concept of nondeterminism.
A nondeterministic choice can be viewed as either
&quot;correctly guessing&quot; between a set of choices, or implementing
each of the choices in parallel.
In the parallel view, the nondeterminism was successful if at
least one of the choices leads to a correct answer.</dd>
<dt id="term-non-deterministic-polynomial-time-algorithm">non-deterministic polynomial time algorithm</dt>
<dd>An algorithm that runs in polynomial time, and which may
(or might not) use <a class="reference internal" href="#term-non-deterministic-choice"><em class="xref std std-term ODSAterm">non-deterministic choice</em></a>.</dd>
<dt id="term-non-strict-partial-order">non-strict partial order</dt>
<dd>In set notation, a relation that is <a class="reference internal" href="#term-reflexive"><em class="xref std std-term ODSAterm">reflexive</em></a>,
<a class="reference internal" href="#term-antisymmetric"><em class="xref std std-term ODSAterm">antisymmetric</em></a>, and <a class="reference internal" href="#term-transitive"><em class="xref std std-term ODSAterm">transitive</em></a>.</dd>
<dt id="term-np">NP</dt>
<dd>An abbreviation for
<a class="reference internal" href="#term-non-deterministic-polynomial-time-algorithm"><em class="xref std std-term ODSAterm">non-deterministic polynomial</em></a>.</dd>
<dt id="term-np-complete">NP-Complete</dt>
<dd>A class of problems that are related to each other in this way:
If ever one such problem is proved to be solvable in
polynomial time, or proved to require exponential time,
then all other NP-Complete problems will cost likewise.
Since so many real-world problems have been proved to be
NP-Complete, it would be extremely useful to determine if they
have polynomial or exponential cost. But so far, nobody has
been able to determine the truth of the situation.
A more technical definition is that a problem is NP-Complete if
it is in NP and is NP-hard.</dd>
<dt id="term-np-completeness-proof">NP-Completeness proof</dt>
<dd>A type of <a class="reference internal" href="#term-reduction"><em class="xref std std-term ODSAterm">reduction</em></a> used to demonstrate that a
particular <a class="reference internal" href="#term-problem"><em class="xref std std-term ODSAterm">problem</em></a> is <a class="reference internal" href="#term-np-complete"><em class="xref std std-term ODSAterm">NP-complete</em></a>.
Specifically, an NP-Completeness proof must first show that the
problem is in class <a class="reference internal" href="#term-np"><em class="xref std std-term ODSAterm">NP</em></a>, and then show (by using a
reduction to another NP-Complete problem) that the problem is
<a class="reference internal" href="#term-np-hard"><em class="xref std std-term ODSAterm">NP-hard</em></a>.</dd>
<dt id="term-np-hard">NP-hard</dt>
<dd>A problem that is &quot;as hard as&quot; any other problem in <a class="reference internal" href="#term-np"><em class="xref std std-term ODSAterm">NP</em></a>.
That is, Problem X is NP-hard if any algorithm in NP can be
<a class="reference internal" href="#term-reduction"><em class="xref std std-term ODSAterm">reduced</em></a> to X in polynomial time.</dd>
<dt id="term-object">object</dt>
<dd>An instance of a class, that is, something that is created and
takes up storage during the execution of a computer program.
In the <a class="reference internal" href="#term-object-oriented-programming-paradigm"><em class="xref std std-term ODSAterm">object-oriented programming paradigm</em></a>, objects
are the basic units of operation.
Objects have state in the form of <a class="reference internal" href="#term-data-member"><em class="xref std std-term ODSAterm">data members</em></a>,
and they know how to perform certain actions
(<a class="reference internal" href="#term-method"><em class="xref std std-term ODSAterm">methods</em></a>).</dd>
<dt id="term-object-space-decomposition">object space decomposition</dt>
<dd>A from of <a class="reference internal" href="#term-key-space-decomposition"><em class="xref std std-term ODSAterm">key space decomposition</em></a> where the
<a class="reference internal" href="#term-key-space"><em class="xref std std-term ODSAterm">key space</em></a> is determined
by the actual values of keys that are found.
For example, a <a class="reference internal" href="#term-bst"><em class="xref std std-term ODSAterm">BST</em></a> stores a key value in its root,
and all other values in the tree with lesser value are in the
left <a class="reference internal" href="#term-subtree"><em class="xref std std-term ODSAterm">subtree</em></a>.
Thus, the root value has split (or decomposed) the
<a class="reference internal" href="#term-key-space"><em class="xref std std-term ODSAterm">key space</em></a> for that key based on its value into left
and right parts.
An object space decomposition is in opposition to an
<a class="reference internal" href="#term-image-space-decomposition"><em class="xref std std-term ODSAterm">image space decomposition</em></a>.</dd>
<dt id="term-object-oriented-programming-paradigm">object-oriented programming paradigm</dt>
<dd>An approach to problem-solving where all computations are
carried out using <a class="reference internal" href="#term-object"><em class="xref std std-term ODSAterm">objects</em></a>.</dd>
<dt id="term-omega-notation">Omega notation</dt>
<dd>In <a class="reference internal" href="#term-algorithm-analysis"><em class="xref std std-term ODSAterm">algorithm analysis</em></a>,
<span class="math">\(\Omega\)</span> notation is used to describe a <a class="reference internal" href="#term-lower-bound"><em class="xref std std-term ODSAterm">lower bound</em></a>.
Roughly (but not completely) analogous to
<a class="reference internal" href="#term-big-oh-notation"><em class="xref std std-term ODSAterm">big-Oh notation</em></a> used to define an <a class="reference internal" href="#term-upper-bound"><em class="xref std std-term ODSAterm">upper bound</em></a>.</dd>
<dt id="term-one-way-list">one-way list</dt>
<dd>A synonym for a <a class="reference internal" href="#term-singly-linked-list"><em class="xref std std-term ODSAterm">singly linked list</em></a>.</dd>
<dt id="term-open-addressing">open addressing</dt>
<dd>A synonym for <a class="reference internal" href="#term-closed-hash-system"><em class="xref std std-term ODSAterm">closed hashing</em></a>.</dd>
<dt id="term-open-hash-system">open hash system</dt>
<dd>A <a class="reference internal" href="#term-hash-system"><em class="xref std std-term ODSAterm">hash system</em></a> where multiple records might be associated
with the same slot of a <a class="reference internal" href="#term-hash-table"><em class="xref std std-term ODSAterm">hash table</em></a>.
Typically this is done using a linked list to store the records.
This is in contrast to a <a class="reference internal" href="#term-closed-hash-system"><em class="xref std std-term ODSAterm">closed hash system</em></a>.</dd>
<dt id="term-operating-system">operating system</dt>
<dd>The control program for a computer.
Its purpose is to control hardware, manage resources, and
present a standard interface to these to other software
components.</dd>
<dt id="term-optimal-static-ordering">optimal static ordering</dt>
<dd>A theoretical construct defining the best static (non-changing)
order in which to place a collection of records so as to
minimize the number of records <a class="reference internal" href="#term-visit"><em class="xref std std-term ODSAterm">visited</em></a> by a
series of sequential searches.
It is a useful concept for the purpose of defining a theoretical
optimum against which to compare the performance for a
<a class="reference internal" href="#term-self-organizing-list-heuristic"><em class="xref std std-term ODSAterm">self-organizing list heuristic</em></a>.</dd>
<dt id="term-out-degree">out degree</dt>
<dd>In <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> terminology, the out degree for a <a class="reference internal" href="#term-vertex"><em class="xref std std-term ODSAterm">vertex</em></a> is
the number of edges directed out of the vertex.</dd>
<dt id="term-overflow">overflow</dt>
<dd>The condition where the amount of data stored in an entity has
exceeded its capacity.
For example, a node in a <a class="reference internal" href="#term-37"><em class="xref std std-term ODSAterm">B-tree</em></a> can store a certain
number of records.
If a record is attempted to be inserted into a node that is
full, then something has to be done to handle this case.</dd>
<dt id="term-overflow-bucket">overflow bucket</dt>
<dd>In <a class="reference internal" href="#term-bucket-hashing"><em class="xref std std-term ODSAterm">bucket hashing</em></a>, this is the <a class="reference internal" href="#term-bucket"><em class="xref std std-term ODSAterm">bucket</em></a> into which
a record is placed if the bucket containing the record's
<a class="reference internal" href="#term-home-slot"><em class="xref std std-term ODSAterm">home slot</em></a> is full.
The overflow bucket is logically considered to have infinite
capacity, though in practice search and insert will become
relatively expensive if many records are stored in the overflow
bucket.</dd>
<dt id="term-overhead">overhead</dt>
<dd>All information stored by a data structure aside from the actual
data.
For example, the pointer fields in a <a class="reference internal" href="#term-linked-list"><em class="xref std std-term ODSAterm">linked list</em></a> or
<a class="reference internal" href="#term-bst"><em class="xref std std-term ODSAterm">BST</em></a>, or the unused positions in an
<a class="reference internal" href="#term-array-based-list"><em class="xref std std-term ODSAterm">array-based list</em></a>.</dd>
<dt id="term-page">page</dt>
<dd>A term often used to refer to the contents of a single
<a class="reference internal" href="#term-buffer"><em class="xref std std-term ODSAterm">buffer</em></a> within a <a class="reference internal" href="#term-buffer-pool"><em class="xref std std-term ODSAterm">buffer pool</em></a> or other
<a class="reference internal" href="#term-virtual-memory"><em class="xref std std-term ODSAterm">virtual memory</em></a>.
This corresponds to a single <a class="reference internal" href="#term-block"><em class="xref std std-term ODSAterm">block</em></a> or <a class="reference internal" href="#term-sector"><em class="xref std std-term ODSAterm">sector</em></a> of
data from <a class="reference internal" href="#term-backing-storage"><em class="xref std std-term ODSAterm">backing storage</em></a>, which is the fundamental unit
of I/O.</dd>
<dt id="term-parameter">parameter</dt>
<dd>The values making up an input to a <a class="reference internal" href="#term-function"><em class="xref std std-term ODSAterm">function</em></a>.</dd>
<dt id="term-parent">parent</dt>
<dd>In a tree, the <a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">node</em></a> <span class="math">\(P\)</span> that directly links to a
node <span class="math">\(A\)</span> is the parent of <span class="math">\(A\)</span>. <span class="math">\(A\)</span> is the
<a class="reference internal" href="#term-child"><em class="xref std std-term ODSAterm">child</em></a> of <span class="math">\(P\)</span>.</dd>
<dt id="term-parent-pointer-representation">parent pointer representation</dt>
<dd>For <a class="reference internal" href="#term-577"><em class="xref std std-term ODSAterm">trees</em></a>, a <a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">node</em></a> implementation where
each node stores only a pointer to its <a class="reference internal" href="#term-parent"><em class="xref std std-term ODSAterm">parent</em></a>, rather
than to its <a class="reference internal" href="#term-child"><em class="xref std std-term ODSAterm">children</em></a>.
This makes it easy to go up the tree toward the <a class="reference internal" href="#term-root"><em class="xref std std-term ODSAterm">root</em></a>,
but not down the tree toward the <a class="reference internal" href="#term-leaf-node"><em class="xref std std-term ODSAterm">leaves</em></a>.
This is most appropriate for solving the
<a class="reference internal" href="#term-union-find"><em class="xref std std-term ODSAterm">UNION/FIND</em></a> problem.</dd>
<dt id="term-parity">parity</dt>
<dd>The concept of matching even-ness or odd-ness, the basic idea
behind using a <a class="reference internal" href="#term-parity-bit"><em class="xref std std-term ODSAterm">parity bit</em></a> for error detection.</dd>
<dt id="term-parity-bit">parity bit</dt>
<dd>A common method for checking if transmission of a
sequence of bits has been performed correctly.
The idea is to count the number of 1 bits in the sequence, and
set the parity bit to 1 if this number is odd, and 0 if it is
even.
Then, the transmitted sequence of bits can be checked to see if
its parity matches the value of the parity bit.
This will catch certain types of errors, in particular if the
value for a single bit has been reversed.
This was used, for example, in early versions of
<a class="reference internal" href="#term-ascii-character-coding"><em class="xref std std-term ODSAterm">ASCII character coding</em></a>.</dd>
<dt id="term-partial-order">partial order</dt>
<dd>In set notation, a binary relation is called a partial order if
it is <a class="reference internal" href="#term-antisymmetric"><em class="xref std std-term ODSAterm">antisymmetric</em></a> and <a class="reference internal" href="#term-transitive"><em class="xref std std-term ODSAterm">transitive</em></a>.
If the relation is also <a class="reference internal" href="#term-reflexive"><em class="xref std std-term ODSAterm">reflexive</em></a>, then it is a
<a class="reference internal" href="#term-non-strict-partial-order"><em class="xref std std-term ODSAterm">non-strict partial order</em></a>.
Alternatively, if the relation is also <a class="reference internal" href="#term-irreflexive"><em class="xref std std-term ODSAterm">irreflexive</em></a>, then
it is a <a class="reference internal" href="#term-strict-partial-order"><em class="xref std std-term ODSAterm">strict partial order</em></a>.</dd>
<dt id="term-partially-ordered-set">partially ordered set</dt>
<dd>The set on which a <a class="reference internal" href="#term-partial-order"><em class="xref std std-term ODSAterm">partial order</em></a> is defined is called a
partially ordered set.</dd>
<dt id="term-partition">partition</dt>
<dd>In <a class="reference internal" href="#term-quicksort"><em class="xref std std-term ODSAterm">Quicksort</em></a>, the process of splitting a list into two
sublists, such that one sublist has values less than the
<a class="reference internal" href="#term-pivot"><em class="xref std std-term ODSAterm">pivot</em></a> value, and the other with values greater than the
pivot. This process takes <span class="math">\(\Theta(i)\)</span> time on a sublist of
length <span class="math">\(i\)</span>.</dd>
<dt id="term-pass-by-reference">pass by reference</dt>
<dd>A reference to the variable is passed to the called
function. So, any modifications will affect the original
variable.</dd>
<dt id="term-pass-by-value">pass by value</dt>
<dd>A copy of a variable is passed to the called function. So, any
modifications will not affect the original variable.</dd>
<dt id="term-path">path</dt>
<dd>In <a class="reference internal" href="#term-577"><em class="xref std std-term ODSAterm">tree</em></a> or <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> terminology,
a sequence of <a class="reference internal" href="#term-vertex"><em class="xref std std-term ODSAterm">vertices</em></a>
<span class="math">\(v_1, v_2, ..., v_n\)</span>
forms a path of length <span class="math">\(n-1\)</span> if there exist edges from
<span class="math">\(v_i\)</span> to <span class="math">\(v_{i+1}\)</span> for <span class="math">\(1 \leq i &lt; n\)</span>.</dd>
<dt id="term-path-compression">path compression</dt>
<dd>When implementing the <a class="reference internal" href="#term-union-find"><em class="xref std std-term ODSAterm">UNION/FIND</em></a> algorithm, path
compression is a local optimization step that can be performed
during the FIND step.
Once the root of the tree for the current object has been found,
the path to the root can be traced a second time, with all
objects in the tree made to point directly to the root.
This reduces the depth of the tree from typically
<span class="math">\(\Theta(\log n)\)</span> to nearly constant.</dd>
<dt id="term-peripheral-storage">peripheral storage</dt>
<dd>Any storage device that is not part of the core processing
of the computer (that is, <a class="reference internal" href="#term-ram"><em class="xref std std-term ODSAterm">RAM</em></a>).
A typical example is a <a class="reference internal" href="#term-disk-drive"><em class="xref std std-term ODSAterm">disk drive</em></a>.</dd>
<dt id="term-permutation">permutation</dt>
<dd>A permutation of a sequence <span class="math">\(\mathbf{S}\)</span>
is the <a class="reference internal" href="#term-element"><em class="xref std std-term ODSAterm">elements</em></a> of <span class="math">\(\mathbf{S}\)</span> arranged
in some order.</dd>
<dt id="term-persistent">persistent</dt>
<dd>In the context of computer memory, this refers to a memory that
does not lose its stored information when the power is turned
off.</dd>
<dt id="term-physical-file">physical file</dt>
<dd>The collection of sectors that comprise a file on a
<a class="reference internal" href="#term-disk-drive"><em class="xref std std-term ODSAterm">disk drive</em></a>.
This is in contrast to the <a class="reference internal" href="#term-logical-file"><em class="xref std std-term ODSAterm">logical file</em></a>.</dd>
<dt id="term-physical-form">physical form</dt>
<dd>The implementation of a data type as a data structure.
Contrast to the <a class="reference internal" href="#term-physical-form"><em class="xref std std-term ODSAterm">physical form</em></a> for the data type.</dd>
<dt id="term-pigeonhole-principle">Pigeonhole Principle</dt>
<dd>A commonly used lemma in Mathematics. A typical variant states:
When <span class="math">\(n+1\)</span> objects are stored in <span class="math">\(n\)</span> locations, at
least one of the locations must store two or more of the objects.</dd>
<dt id="term-pivot">pivot</dt>
<dd>In <a class="reference internal" href="#term-quicksort"><em class="xref std std-term ODSAterm">Quicksort</em></a>, the value that is used to split the list
into sublists, one with lesser values than the pivot, the other
with greater values than the pivot.</dd>
<dt id="term-platter">platter</dt>
<dd>In a <a class="reference internal" href="#term-disk-drive"><em class="xref std std-term ODSAterm">disk drive</em></a>, one of a series of flat disks that
comprise the storage space for the drive.
Typically, each surface (top and bottom) of each platter stores
data, and each surface has its own <a class="reference internal" href="#term-i-o-head"><em class="xref std std-term ODSAterm">I/O head</em></a>.</dd>
<dt id="term-point-quadtree">point quadtree</dt>
<dd>A <cite>term:`spatial data structure</cite> for storing point data.
It is similar to a <a class="reference internal" href="#term-pr-quadtree"><em class="xref std std-term ODSAterm">PR quadtree</em></a> in that it (in two
dimensions) splits the world into four parts.
However, it splits using an <a class="reference internal" href="#term-object-space-decomposition"><em class="xref std std-term ODSAterm">object space decomposition</em></a>.
That is, quadrant containing the point is split into four parts
at the point.
It is similar to the <a class="reference internal" href="#term-kd-tree"><em class="xref std std-term ODSAterm">kd tree</em></a> which splits alternately in
each dimension, except that it splits in all dimensions at once.</dd>
<dt id="term-point-region-quadtree">point-region quadtree</dt>
<dd>Formal name for what is commonly referred to as a
<a class="reference internal" href="#term-pr-quadtree"><em class="xref std std-term ODSAterm">PR quadtree</em></a>.</dd>
<dt id="term-pointee">pointee</dt>
<dd>The term pointee refers to anything that is pointed to by a
<a class="reference internal" href="#term-pointer"><em class="xref std std-term ODSAterm">pointer</em></a> or <a class="reference internal" href="#term-reference"><em class="xref std std-term ODSAterm">reference</em></a>.</dd>
<dt id="term-pointer">pointer</dt>
<dd>A variable whose value is the <a class="reference internal" href="#term-address"><em class="xref std std-term ODSAterm">address</em></a> of another variable; a link.</dd>
<dt id="term-pointer-based-implementation-for-binary-tree-nodes">pointer-based implementation for binary tree nodes</dt>
<dd>A common way to implement <a class="reference internal" href="#term-binary-tree"><em class="xref std std-term ODSAterm">binary tree</em></a> <a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">nodes</em></a>.
Each node stores a data value (or a reference to a data value),
and pointers to the left and right children.
If either or both of the children does not exist, then a null
pointer is stored.</dd>
<dt id="term-polymorphism">polymorphism</dt>
<dd>An <a class="reference internal" href="#term-object-oriented-programming-paradigm"><em class="xref std std-term ODSAterm">object-oriented programming</em></a>
term meaning <em>one name, many forms</em>.
It describes the ability of software to change its behavior
dynamically.  Two basic forms exist:
<a class="reference internal" href="#term-run-time-polymorphism"><em class="xref std std-term ODSAterm">run-time polymorphism</em></a> and <a class="reference internal" href="#term-compile-time-polymorphism"><em class="xref std std-term ODSAterm">compile-time polymorphism</em></a>.</dd>
<dt id="term-pop">pop</dt>
<dd>A specialized term used to indicate removing an <a class="reference internal" href="#term-element"><em class="xref std std-term ODSAterm">element</em></a>
from a <a class="reference internal" href="#term-stack"><em class="xref std std-term ODSAterm">stack</em></a>.</dd>
<dt id="term-poset">poset</dt>
<dd>Another name for a <a class="reference internal" href="#term-partially-ordered-set"><em class="xref std std-term ODSAterm">partially ordered set</em></a>.</dd>
<dt id="term-position">position</dt>
<dd>The defining property of the list ADT, this is the concept that
list elements are in a position. Many list ADTs support access
by position.</dd>
<dt id="term-postorder-traversal">postorder traversal</dt>
<dd>In a <a class="reference internal" href="#term-binary-tree"><em class="xref std std-term ODSAterm">binary tree</em></a>, a <a class="reference internal" href="#term-traversal"><em class="xref std std-term ODSAterm">traversal</em></a> that first
<a class="reference internal" href="#term-recursion"><em class="xref std std-term ODSAterm">recursively</em></a> <a class="reference internal" href="#term-visit"><em class="xref std std-term ODSAterm">visits</em></a> the left
<a class="reference internal" href="#term-child"><em class="xref std std-term ODSAterm">child</em></a>,
then recursively visits the right child, and then visits the
<a class="reference internal" href="#term-root"><em class="xref std std-term ODSAterm">root</em></a>.</dd>
<dt id="term-potential">potential</dt>
<dd>A concept related to <a class="reference internal" href="#term-amortized-analysis"><em class="xref std std-term ODSAterm">amortized analysis</em></a>.
Potential is the total or currently available amount of work
that can be done.</dd>
<dt id="term-powerset">powerset</dt>
<dd>For a <a class="reference internal" href="#term-set"><em class="xref std std-term ODSAterm">set</em></a> <span class="math">\(\mathbf{S}\)</span>, the power set is the set
of all possible <a class="reference internal" href="#term-subset"><em class="xref std std-term ODSAterm">subsets</em></a> for <span class="math">\(\mathbf{S}\)</span>.</dd>
<dt id="term-pr-quadtree">PR quadtree</dt>
<dd>A type of <a class="reference internal" href="#term-quadtree"><em class="xref std std-term ODSAterm">quadtree</em></a> that stores point data in two
dimensions.
The root of the PR quadtree represents some square region of 2d
space.
If that space stores more than one data point, then the region
is decomposed into four equal subquadrants, each represented
<a class="reference internal" href="#term-recursion"><em class="xref std std-term ODSAterm">recursively</em></a> by a subtree of the PR quadtree.
Since many leaf nodes of the PR quadtree will contain no data
points, implementation often makes use of the <a class="reference internal" href="#term-flyweight"><em class="xref std std-term ODSAterm">Flyweight</em></a>
<a class="reference internal" href="#term-design-pattern"><em class="xref std std-term ODSAterm">design pattern</em></a>.
Related to the <a class="reference internal" href="#term-bintree"><em class="xref std std-term ODSAterm">bintree</em></a>.</dd>
<dt id="term-prefix-property">prefix property</dt>
<dd>Given a collection of strings, the collection has the prefix
property if no string in the collection is a prefix for another
string in the collection.
The significance is that, given a long string composed of
members of the collection, it can be uniquely decomposed into
the constituent members.
An example of such a collection of strings with the prefix
property is a set of <a class="reference internal" href="#term-huffman-codes"><em class="xref std std-term ODSAterm">Huffman codes</em></a>.</dd>
<dt id="term-preorder-traversal">preorder traversal</dt>
<dd>In a <a class="reference internal" href="#term-binary-tree"><em class="xref std std-term ODSAterm">binary tree</em></a>, a <a class="reference internal" href="#term-traversal"><em class="xref std std-term ODSAterm">traversal</em></a> that first
<a class="reference internal" href="#term-visit"><em class="xref std std-term ODSAterm">visits</em></a> the <a class="reference internal" href="#term-root"><em class="xref std std-term ODSAterm">root</em></a>, then
<a class="reference internal" href="#term-recursion"><em class="xref std std-term ODSAterm">recursively</em></a> visits the left <a class="reference internal" href="#term-child"><em class="xref std std-term ODSAterm">child</em></a>,
then recursively visits the right child.</dd>
<dt id="term-prim-s-algorithm">Prim's algorithm</dt>
<dd>A <a class="reference internal" href="#term-greedy-algorithm"><em class="xref std std-term ODSAterm">greedy algorithm</em></a> for computing the <a class="reference internal" href="#term-mcst"><em class="xref std std-term ODSAterm">MCST</em></a> of a
<a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a>.
It is nearly identical to <a class="reference internal" href="#term-dijkstra-s-algorithm"><em class="xref std std-term ODSAterm">Dijkstra's algorithm</em></a> for
solving the <a class="reference internal" href="#term-single-source-shortest-paths-problem"><em class="xref std std-term ODSAterm">single-source shortest paths problem</em></a>,
with the only difference being the calculation done to update
the best-known distance.</dd>
<dt id="term-primary-clustering">primary clustering</dt>
<dd>In <a class="reference internal" href="#term-hashing"><em class="xref std std-term ODSAterm">hashing</em></a>, the tendency in certain
<a class="reference internal" href="#term-collision-resolution"><em class="xref std std-term ODSAterm">collision resolution</em></a>
methods to create clustering in sections of the hash table.
The classic example is <a class="reference internal" href="#term-linear-probing"><em class="xref std std-term ODSAterm">linear probing</em></a>.
This tends to happen when a group of keys follow the same
:term`probe sequence` during collision resolution.</dd>
<dt id="term-primary-index">primary index</dt>
<dd>Synonym for <a class="reference internal" href="#term-primary-key-index"><em class="xref std std-term ODSAterm">primary key index</em></a>.</dd>
<dt id="term-primary-key">primary key</dt>
<dd>A unique identifier for a <a class="reference internal" href="#term-record"><em class="xref std std-term ODSAterm">record</em></a>.</dd>
<dt id="term-primary-key-index">primary key index</dt>
<dd>Relates each <a class="reference internal" href="#term-primary-key"><em class="xref std std-term ODSAterm">primary key</em></a> value with a pointer to the
actual record on disk.</dd>
<dt id="term-primary-storage">primary storage</dt>
<dd>The faster but more expensive memory in a computer, most often
<a class="reference internal" href="#term-ram"><em class="xref std std-term ODSAterm">RAM</em></a> in modern computers.
This is in contrast to <a class="reference internal" href="#term-secondary-storage"><em class="xref std std-term ODSAterm">secondary storage</em></a>, which together
with primary storage devices make up the computer's
<a class="reference internal" href="#term-memory-hierarchy"><em class="xref std std-term ODSAterm">memory hierarchy</em></a>.</dd>
<dt id="term-primitive-data-type">primitive data type</dt>
<dd>In Java, one of a particular group of
<a class="reference internal" href="#term-simple-type"><em class="xref std std-term ODSAterm">simple types</em></a> that are not implemented as
objects.
An example is an <code class="docutils literal"><span class="pre">int</span></code>.</dd>
<dt id="term-primitive-element">primitive element</dt>
<dd>In set notation, this is a single element that is a member of
the base type for the set. This is as opposed to an element of
the set being another set.</dd>
<dt id="term-priority">priority</dt>
<dd>A quantity assigned to each of a collection of
<a class="reference internal" href="#term-job"><em class="xref std std-term ODSAterm">jobs</em></a> or tasks that indicate importance for order
of processing.
For example, in an operating system, there could be a collection
of processes (jobs) ready to run.
The operating system must select the next task to execute,
based on their priorities.</dd>
<dt id="term-priority-queue">priority queue</dt>
<dd>An ADT whose primary operations of insert of records, and
deletion of the greatest (or, in an alternative implementation,
the least) valued record.
Most often implemented using the <a class="reference internal" href="#term-heap"><em class="xref std std-term ODSAterm">heap</em></a> data structure.
The name comes from a common application where the records being
stored represent tasks, with the ordering values based on the
<a class="reference internal" href="#term-priority"><em class="xref std std-term ODSAterm">priorities</em></a> of the tasks.</dd>
<dt id="term-probabilistic-algorithm">probabilistic algorithm</dt>
<dd>A form of <a class="reference internal" href="#term-randomized-algorithm"><em class="xref std std-term ODSAterm">randomized algorithm</em></a> that might yield an
incorrect result, or that might fail to produce a result.</dd>
<dt id="term-probabilistic-data-structure">probabilistic data structure</dt>
<dd>Any data structure that uses
<a class="reference internal" href="#term-probabilistic-algorithm"><em class="xref std std-term ODSAterm">probabilistic algorithms</em></a> to
perform its operations.
A good example is the <a class="reference internal" href="#term-skip-list"><em class="xref std std-term ODSAterm">skip list</em></a>.</dd>
<dt id="term-probe-function">probe function</dt>
<dd>In <a class="reference internal" href="#term-hashing"><em class="xref std std-term ODSAterm">hashing</em></a>, the function used by a
<a class="reference internal" href="#term-collision-resolution"><em class="xref std std-term ODSAterm">collision resolution</em></a> method to calculate where to look
next in the <a class="reference internal" href="#term-hash-table"><em class="xref std std-term ODSAterm">hash table</em></a>.</dd>
<dt id="term-probe-sequence">probe sequence</dt>
<dd>In <a class="reference internal" href="#term-hashing"><em class="xref std std-term ODSAterm">hashing</em></a>, the series of <a class="reference internal" href="#term-slot"><em class="xref std std-term ODSAterm">slots</em></a> visited
by the <a class="reference internal" href="#term-probe-function"><em class="xref std std-term ODSAterm">probe function</em></a> during
<a class="reference internal" href="#term-collision-resolution"><em class="xref std std-term ODSAterm">collision resolution</em></a>.</dd>
<dt id="term-problem">problem</dt>
<dd>A task to be performed.
It is best thought of as a <a class="reference internal" href="#term-function"><em class="xref std std-term ODSAterm">function</em></a> or a mapping of
inputs to outputs.</dd>
<dt id="term-problem-instance">problem instance</dt>
<dd>A specific selection of values for the parameters to a problem.
In other words, a specific set of inputs to a problem.
A given problem instance has a size under some
<a class="reference internal" href="#term-cost-model"><em class="xref std std-term ODSAterm">cost model</em></a>.</dd>
<dt id="term-problem-lower-bound">problem lower bound</dt>
<dd>In <a class="reference internal" href="#term-algorithm-analysis"><em class="xref std std-term ODSAterm">algorithm analysis</em></a>, the tightest <a class="reference internal" href="#term-lower-bound"><em class="xref std std-term ODSAterm">lower bound</em></a>
that we can prove over all <a class="reference internal" href="#term-algorithm"><em class="xref std std-term ODSAterm">algorithms</em></a>
for that <a class="reference internal" href="#term-problem"><em class="xref std std-term ODSAterm">problem</em></a>.
This is often much harder to determine than the
<cite>:term:`problem upper bound</cite>.
Since the lower bound for the algorithm can be very different
for different situations (such as the <a class="reference internal" href="#term-best-case"><em class="xref std std-term ODSAterm">best case</em></a> or
<a class="reference internal" href="#term-worst-case"><em class="xref std std-term ODSAterm">worst case</em></a>), we typically have to specify which
situation we are referring to.</dd>
<dt id="term-problem-upper-bound">problem upper bound</dt>
<dd>In <a class="reference internal" href="#term-algorithm-analysis"><em class="xref std std-term ODSAterm">algorithm analysis</em></a>, the <a class="reference internal" href="#term-upper-bound"><em class="xref std std-term ODSAterm">upper bound</em></a> for the
best <a class="reference internal" href="#term-algorithm"><em class="xref std std-term ODSAterm">algorithm</em></a> that we know for the <a class="reference internal" href="#term-problem"><em class="xref std std-term ODSAterm">problem</em></a>.
Since the upper bound for the algorithm can be very different
for different situations (such as the <a class="reference internal" href="#term-best-case"><em class="xref std std-term ODSAterm">best case</em></a> or
<a class="reference internal" href="#term-worst-case"><em class="xref std std-term ODSAterm">worst case</em></a>), we typically have to specify which
situation we are referring to.</dd>
<dt id="term-procedural">procedural</dt>
<dd>Typically referring to the
<a class="reference internal" href="#term-procedural-programming-paradigm"><em class="xref std std-term ODSAterm">procedural programming paradigm</em></a>, in contrast to the
<a class="reference internal" href="#term-object-oriented-programming-paradigm"><em class="xref std std-term ODSAterm">object-oriented programming paradigm</em></a>.</dd>
<dt id="term-procedural-programming-paradigm">procedural programming paradigm</dt>
<dd>Procedural programming uses a list of instructions (and
procedure calls) that define a series of computational steps to
be carried out.
This is in contrast to the
<a class="reference internal" href="#term-object-oriented-programming-paradigm"><em class="xref std std-term ODSAterm">object-oriented programming paradigm</em></a>.</dd>
<dt id="term-program">program</dt>
<dd>An instance, or concrete representation, of an algorithm in some
programming language.</dd>
<dt id="term-promotion">promotion</dt>
<dd>In the context of certain <a class="reference internal" href="#term-balanced-tree"><em class="xref std std-term ODSAterm">balanced tree</em></a> structures such
as the :term:2-3 tree`, a promotion takes place when an
insertion causes the node to <a class="reference internal" href="#term-overflow"><em class="xref std std-term ODSAterm">overflow</em></a>.
In the case of the 2-3 tree, the <a class="reference internal" href="#term-key"><em class="xref std std-term ODSAterm">key</em></a> with the middlemost
value is sent to be stored in the parent.</dd>
<dt id="term-proof">proof</dt>
<dd>The establishment of the truth of anything, a demonstration.</dd>
<dt id="term-proof-by-contradiction">proof by contradiction</dt>
<dd>A mathematical proof technique that proves a theorem by first
assuming that the theorem is false, and then uses a chain of
reasoning to reach a logical contradiction.
Since when the theorem is false a logical contradiction arises,
the conclusion is that the theorem must be true.</dd>
<dt id="term-proof-by-induction">proof by induction</dt>
<dd>A mathematical proof technique similar to <a class="reference internal" href="#term-recursion"><em class="xref std std-term ODSAterm">recursion</em></a>.
It is used to prove a parameterized theorem $S(n)$, that is,
a theorem where there is a <a class="reference internal" href="#term-induction-variable"><em class="xref std std-term ODSAterm">induction variable</em></a> involved
(such as the sum of the numbers from 1 to $n$).
One first proves that the theorem holds true for a
<a class="reference internal" href="#term-base-case"><em class="xref std std-term ODSAterm">base case</em></a>, then one proves the implication that
whenever $S(n)$ is true then $S(n+1)$ is also true.
Another variation is <a class="reference internal" href="#term-strong-induction"><em class="xref std std-term ODSAterm">strong induction</em></a>.</dd>
<dt id="term-proving-the-contrapositive">proving the contrapositive</dt>
<dd>We can prove that <span class="math">\(P \Rightarrow Q\)</span> by proving
<span class="math">\((\mathrm{not}\ Q) \Rightarrow (\mathrm{not}\ P)\)</span>.</dd>
<dt id="term-pseudo-random-probing">pseudo-random probing</dt>
<dd>In <a class="reference internal" href="#term-hashing"><em class="xref std std-term ODSAterm">hashing</em></a>, this is a <a class="reference internal" href="#term-collision-resolution"><em class="xref std std-term ODSAterm">collision resolution</em></a>
method that stores a random permutation of the values 1 through
the size of the <a class="reference internal" href="#term-hash-table"><em class="xref std std-term ODSAterm">hash table</em></a>.
Term <span class="math">\(i\)</span> of the <a class="reference internal" href="#term-probe-sequence"><em class="xref std std-term ODSAterm">probe sequence</em></a> is simply the value
of position <span class="math">\(i\)</span> in the permuation.</dd>
<dt id="term-push">push</dt>
<dd>A specialized term used to indicate inserting an <a class="reference internal" href="#term-element"><em class="xref std std-term ODSAterm">element</em></a>
onto a <a class="reference internal" href="#term-stack"><em class="xref std std-term ODSAterm">stack</em></a>.</dd>
<dt id="term-quadratic-growth-rate">quadratic growth rate</dt>
<dd>A growth rate function of the form <span class="math">\(cn^2\)</span> where <span class="math">\(n\)</span>
is the input size and <span class="math">\(c\)</span> is a constant.</dd>
<dt id="term-quadratic-probing">quadratic probing</dt>
<dd>In <a class="reference internal" href="#term-hashing"><em class="xref std std-term ODSAterm">hashing</em></a>, this is a <a class="reference internal" href="#term-collision-resolution"><em class="xref std std-term ODSAterm">collision resolution</em></a>
method that computes term <span class="math">\(i\)</span> of the
<a class="reference internal" href="#term-probe-sequence"><em class="xref std std-term ODSAterm">probe sequence</em></a> using some quadratic equation
<span class="math">\(ai^2 _ bi + c\)</span> for suitable constants <span class="math">\(a, b, c\)</span>.
The simplest form is simply to use <span class="math">\(i^2\)</span> as term <span class="math">\(i\)</span>
of the probe sequence.</dd>
<dt id="term-quadtree">quadtree</dt>
<dd>A <a class="reference internal" href="#term-full-tree"><em class="xref std std-term ODSAterm">full tree</em></a> where each internal node has four children.
Most typically used to store two dimensional
<a class="reference internal" href="#term-spatial-data"><em class="xref std std-term ODSAterm">spatial data</em></a>.
Related to the <a class="reference internal" href="#term-bintree"><em class="xref std std-term ODSAterm">bintree</em></a>.
The difference is that the quadtree splits all dimensions
simultaneously, while the bintree splits one dimension at each
level.
Thus, to extend the quadtree concept to more dimensions requires
a rapid increase in the number of splits (for example, 8 in
three dimensions).</dd>
<dt id="term-queue">queue</dt>
<dd>A list-like structure in which elements are inserted only at one
end, and removed only from the other one end.</dd>
<dt id="term-quicksort">Quicksort</dt>
<dd>A sort that is <span class="math">\(\Theta(n \log n)\)</span> in the
<a class="reference internal" href="#term-best-case"><em class="xref std std-term ODSAterm">best</em></a> and <a class="reference internal" href="#term-average-case"><em class="xref std std-term ODSAterm">average</em></a>
cases, though <span class="math">\(\Theta(n^2)\)</span> in the <a class="reference internal" href="#term-worst-case"><em class="xref std std-term ODSAterm">worst case</em></a>.
However, a reasonable implmentation will make the worst case
occur under exceedingly rare circumstances.
Due to its tight inner loop, it tends to run better than any
other known sort in general cases.
Thus, it is a popular sort to use in code libraries.
It works by divide and conquer, by selecting a <a class="reference internal" href="#term-pivot"><em class="xref std std-term ODSAterm">pivot</em></a>
value,
splitting the list into parts that are either less than or
greater than the pivot, and then sorting the two parts.</dd>
<dt id="term-radix">radix</dt>
<dd>Synonym for <a class="reference internal" href="#term-base"><em class="xref std std-term ODSAterm">base</em></a>. The number of digits in a number
representation. For example, we typically represent numbers in
base (or radix) 10. Hexidecimal is base (or radix) 16.</dd>
<dt id="term-radix-sort">radix sort</dt>
<dd>A sorting algorithm that works by processing records with
<span class="math">\(k\)</span> digit keys in <span class="math">\(k\)</span> passes, where each pass sorts
the records according to the current digit. At the end of the
process, the records will be sorted. This can be efficient if
the number of digits is small compared to the number of
records. However, if the <span class="math">\(n\)</span> records all have unique key
valuse, than at least <span class="math">\(\Omega(\log n)\)</span> digits are required,
leading to an <span class="math">\(\Omega(n \log n)\)</span> sorting algorithm that
tends to be much slower than other sorting algorithms like
<a class="reference internal" href="#term-quicksort"><em class="xref std std-term ODSAterm">Quicksort</em></a> or <a class="reference internal" href="#term-mergesort"><em class="xref std std-term ODSAterm">mergesort</em></a>.</dd>
<dt id="term-ram">RAM</dt>
<dd>Abbreviation for <a class="reference internal" href="#term-random-access-memory"><em class="xref std std-term ODSAterm">Random Access Memory</em></a>.</dd>
<dt id="term-random-access">random access</dt>
<dd>In <a class="reference internal" href="#term-file-processing"><em class="xref std std-term ODSAterm">file processing</em></a> terminology, a <a class="reference internal" href="#term-disk-access"><em class="xref std std-term ODSAterm">disk access</em></a> to
a random position within the file.
More generally, the ability to access an arbitrary record in the
file.</dd>
<dt id="term-random-access-memory">random access memory</dt>
<dd>Abbreviated <a class="reference internal" href="#term-ram"><em class="xref std std-term ODSAterm">RAM</em></a>, this is the principle example of
<a class="reference internal" href="#term-primary-storage"><em class="xref std std-term ODSAterm">primary storage</em></a> in a modern computer.
Data access times are typically measured in billionths of a
second (microseconds), which is roughly a million times faster
than data access from a disk drive.
RAM is where data are held for immediate processing, since
access times are so much faster than for
<a class="reference internal" href="#term-secondary-storage"><em class="xref std std-term ODSAterm">secondary storage</em></a>.
RAM is a typical part of a computer's <a class="reference internal" href="#term-memory-hierarchy"><em class="xref std std-term ODSAterm">memory hierarchy</em></a>.</dd>
<dt id="term-random-permutation">random permutation</dt>
<dd>One of the <span class="math">\(n!\)</span> possible permutations for a set of
<span class="math">\(n\)</span> element is selected in such a way that each
permutation has equal probability of being selected.</dd>
<dt id="term-randomized-algorithm">randomized algorithm</dt>
<dd>An algorithm that involves some form of randomness to control
its behavior.
The ultimate goal of a randomized algorithm is to improve
performance over a deterministic algorithm to solve the same
problem.
There are a number of variations on this theme.
A &quot;Las Vegas algorithm&quot; returns a correct result,
but the amount of time required might or might not improve over
a <a class="reference internal" href="#term-deterministic-algorithm"><em class="xref std std-term ODSAterm">deterministic algorithm</em></a>.
A &quot;Monte Carlo algorithm&quot; is a form of
<a class="reference internal" href="#term-probabilistic-algorithm"><em class="xref std std-term ODSAterm">probabilistic algorithm</em></a> that is not guarenteed to return
a correct result, but will return a result relatively quickly.</dd>
<dt id="term-range">range</dt>
<dd>The set of possible outputs for a function.</dd>
<dt id="term-range-query">range query</dt>
<dd>Records are returned if their relevant key value falls with a
specified range.</dd>
<dt id="term-read-write-head">read/write head</dt>
<dd>Synonym for <a class="reference internal" href="#term-i-o-head"><em class="xref std std-term ODSAterm">I/O head</em></a>.</dd>
<dt id="term-rebalancing-operation">rebalancing operation</dt>
<dd>An operation performed on balanced search trees, such as the
<a class="reference internal" href="#term-avl-tree"><em class="xref std std-term ODSAterm">AVL Tree</em></a> or <a class="reference internal" href="#term-splay-tree"><em class="xref std std-term ODSAterm">Splay Tree</em></a>, for the purpose of
keeping the tree <a class="reference internal" href="#term-height-balanced"><em class="xref std std-term ODSAterm">height balanced</em></a>.</dd>
<dt id="term-record">record</dt>
<dd>A collection of information, typically implemented as an
<a class="reference internal" href="#term-object"><em class="xref std std-term ODSAterm">object</em></a> in an
<a class="reference internal" href="#term-object-oriented-programming-paradigm"><em class="xref std std-term ODSAterm">object-oriented programming language</em></a>.
Many data structures are organized containers for a collection
of records.</dd>
<dt id="term-recurrence-relation">recurrence relation</dt>
<dd>A <a class="reference internal" href="#term-recurrence-relation"><em class="xref std std-term ODSAterm">recurrence relation</em></a> (or less formally,
recurrence) defines a function by means of an
expression that includes one or more (smaller) instances of
itself.
A classic example is the <a class="reference internal" href="#term-recursion"><em class="xref std std-term ODSAterm">recursive</em></a>
definition for the
factorial function, <span class="math">\(F(n) = n*F(n-1)\)</span>.</dd>
<dt id="term-recurrence-with-full-history">recurrence with full history</dt>
<dd>A special form of <a class="reference internal" href="#term-recurrence-relation"><em class="xref std std-term ODSAterm">recurrence relation</em></a> that includes a
summation with a copy of the recurrence inside.
The recurrence that represents the average case cost for
<a class="reference internal" href="#term-quicksort"><em class="xref std std-term ODSAterm">Quicksort</em></a> is an example.
This internal summation can typically be removed with simple
techniques to simplify solving the recurrence.</dd>
<dt id="term-recursion">recursion</dt>
<dd>The process of using recursive calls.
An algorithm is recursive if it calls itself to do part of
its work.
See <a class="reference internal" href="#term-recursion"><em class="xref std std-term ODSAterm">recursion</em></a>.</dd>
<dt id="term-recursive-call">recursive call</dt>
<dd>Within a <a class="reference internal" href="#term-recursive-function"><em class="xref std std-term ODSAterm">recursive function</em></a>, it is a call that the
function makes to itself.</dd>
<dt id="term-recursive-data-structure">recursive data structure</dt>
<dd>A data structure that is partially
composed of smaller or simpler instances of the same data structure.
For example, <a class="reference internal" href="#term-linked-list"><em class="xref std std-term ODSAterm">linked lists</em></a> and
<a class="reference internal" href="#term-binary-tree"><em class="xref std std-term ODSAterm">binary trees</em></a> can be viewed as recursive
data structures.</dd>
<dt id="term-recursive-function">recursive function</dt>
<dd>A function that includes a <a class="reference internal" href="#term-recursive-call"><em class="xref std std-term ODSAterm">recursive call</em></a>.</dd>
<dt id="term-red-black-tree">Red-Black Tree</dt>
<dd>A balanced variation on a <a class="reference internal" href="#term-bst"><em class="xref std std-term ODSAterm">BST</em></a>.</dd>
<dt id="term-reduction">reduction</dt>
<dd>In <a class="reference internal" href="#term-algorithm-analysis"><em class="xref std std-term ODSAterm">algorithm analysis</em></a>, the process of deriving
<a class="reference internal" href="#term-asymptotic-analysis"><em class="xref std std-term ODSAterm">asymptotic bounds</em></a>
for one <a class="reference internal" href="#term-problem"><em class="xref std std-term ODSAterm">problem</em></a> from the asymptotic bounds of another.
In particular, if problem A can be used to solve problem B, and
problem A is proved to be in <span class="math">\(O(f(n))\)</span>, then problem B
must also be in <span class="math">\(O(f(n))\)</span>.
Reductions are often used to show that certain problems are at
least as expensive as sorting, or that certain problems are
<a class="reference internal" href="#term-np-complete"><em class="xref std std-term ODSAterm">NP-Complete</em></a>.</dd>
<dt id="term-reference">reference</dt>
<dd>A value that enables a program to directly access some
particular data item.
An example might be a byte position within a file where the
record is stored, or a pointer to a record in memory.
(Note that Java makes a distinction between a reference and the
concept of a pointer, since it does not define a reference to
necessarily be a byte position in memory.)</dd>
<dt id="term-reference-count-algorithm">reference count algorithm</dt>
<dd>An algorithm for <a class="reference internal" href="#term-garbage-collection"><em class="xref std std-term ODSAterm">garbage collection</em></a>.
Whenever a reference is made from a variable to some memory
location, a counter associated with that memory location is
incremented.
Whenever the reference is changed or deleted, the reference
count is decremented.
If this count goes to zero, then the memory is considered free
for reuse.
This approach can fail if there is a cycle in the chain of
references.</dd>
<dt id="term-reference-parameter">reference parameter</dt>
<dd>A <a class="reference internal" href="#term-parameter"><em class="xref std std-term ODSAterm">parameter</em></a> that has been
<a class="reference internal" href="#term-pass-by-reference"><em class="xref std std-term ODSAterm">passed by reference</em></a>.
Such a parameter can be modified inside the function or method.</dd>
<dt id="term-reflexive">reflexive</dt>
<dd>In set notation, binary relation <span class="math">\(R\)</span> on set <span class="math">\(S\)</span> is
reflexive if <span class="math">\(aRa\)</span> for all <span class="math">\(a \in \mathbf{S}\)</span>.</dd>
<dt id="term-relation">relation</dt>
<dd>In set notation, a relation <span class="math">\(R\)</span> over set
<span class="math">\(\mathbf{S}\)</span> is a set of ordered pairs from
<span class="math">\(\mathbf{S}\)</span>.</dd>
<dt id="term-replacement-selection">replacement selection</dt>
<dd>A variant of <a class="reference internal" href="#term-heapsort"><em class="xref std std-term ODSAterm">Heapsort</em></a> most often used as one phase of an
<a class="reference internal" href="#term-external-sort"><em class="xref std std-term ODSAterm">external sort</em></a>.
Given a collection of records stored in an array, and a stream
of additional records too large to fit into
<a class="reference internal" href="#term-working-memory"><em class="xref std std-term ODSAterm">working memory</em></a>, replacement selection will unload the
<a class="reference internal" href="#term-heap"><em class="xref std std-term ODSAterm">heap</em></a> by sending records to an output stream, and seek to
bring new records into the heap from the input stream in
preference to shrinking the heap size whenever possible.</dd>
<dt id="term-reserved-block">reserved block</dt>
<dd>In a <a class="reference internal" href="#term-memory-manager"><em class="xref std std-term ODSAterm">memory manager</em></a>, this refers to space in the
<a class="reference internal" href="#term-memory-pool"><em class="xref std std-term ODSAterm">memory pool</em></a> that has been allocated to store data
received from the <a class="reference internal" href="#term-client"><em class="xref std std-term ODSAterm">client</em></a>.
This is in contrast to the <a class="reference internal" href="#term-free-block"><em class="xref std std-term ODSAterm">free blocks</em></a> that
represent space in the memory pool that is not allocated to
storing client data.</dd>
<dt id="term-resource-constraints">resource constraints</dt>
<dd>Examples of resource constraints include the total space
available to store the data (possibly divided into separate
main memory and disk space constraints) and the time
allowed to perform each subtask.</dd>
<dt id="term-root">root</dt>
<dd>In a <a class="reference internal" href="#term-577"><em class="xref std std-term ODSAterm">tree</em></a>, the topmost <a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">node</em></a> of the tree.
All other nodes in the tree are <a class="reference internal" href="#term-descendant"><em class="xref std std-term ODSAterm">descendants</em></a>
of the root.</dd>
<dt id="term-rotation">rotation</dt>
<dd>In the <a class="reference internal" href="#term-avl-tree"><em class="xref std std-term ODSAterm">AVL Tree</em></a> and <a class="reference internal" href="#term-splay-tree"><em class="xref std std-term ODSAterm">Splay Tree</em></a>, a rotation is a
local operation performed on a node, its children, and its
grandchildren that can result in reordering their relationship.
The goal of performing a rotation is to make the tree more
<a class="reference internal" href="#term-balanced-tree"><em class="xref std std-term ODSAterm">balanced</em></a>.</dd>
<dt id="term-rotational-delay">rotational delay</dt>
<dd>When processing a <a class="reference internal" href="#term-disk-access"><em class="xref std std-term ODSAterm">disk access</em></a>, the time that it takes
for the first byte of the desired data to move to under the
<a class="reference internal" href="#term-i-o-head"><em class="xref std std-term ODSAterm">I/O head</em></a>.
On average, this will take one half of a disk rotation, and so
constitutes a substantial portion of the time required for the
disk access.</dd>
<dt id="term-rotational-latency">rotational latency</dt>
<dd>A synonym for <a class="reference internal" href="#term-rotational-delay"><em class="xref std std-term ODSAterm">rotational delay</em></a>.</dd>
<dt id="term-run">run</dt>
<dd>A series of sorted records.
Most often this refers to a (sorted) subset of records that are
being sorted by means of an <a class="reference internal" href="#term-external-sort"><em class="xref std std-term ODSAterm">external sort</em></a>.</dd>
<dt id="term-run-file">run file</dt>
<dd>A temporary file that is created during the operation of an
<a class="reference internal" href="#term-external-sort"><em class="xref std std-term ODSAterm">external sort</em></a>, the run file contains a collection of
<a class="reference internal" href="#term-run"><em class="xref std std-term ODSAterm">runs</em></a>.
A common structure for an external sort is to first create a
series of runs (stored in a run file), followed by merging the
runs together.</dd>
<dt id="term-run-time-polymorphism">run-time polymorphism</dt>
<dd>A form of <a class="reference internal" href="#term-polymorphism"><em class="xref std std-term ODSAterm">polymorphism</em></a> known as Overriding.
Overridden methods are those which implement a new method
with the same signature as a method inherited from its
base class.
Compare to <a class="reference internal" href="#term-compile-time-polymorphism"><em class="xref std std-term ODSAterm">compile-time polymorphism</em></a>.</dd>
<dt id="term-runtime-environment">runtime environment</dt>
<dd>The environment in which a program (of a particular programming
language) executes.
The runtime environment handles such activities as managing the
<a class="reference internal" href="#term-runtime-stack"><em class="xref std std-term ODSAterm">runtime stack</em></a>, the <a class="reference internal" href="#term-free-store"><em class="xref std std-term ODSAterm">free store</em></a>, and the
<a class="reference internal" href="#term-garbage-collection"><em class="xref std std-term ODSAterm">garbage collector</em></a>,
and it conducts the execution of the program.</dd>
<dt id="term-runtime-stack">runtime stack</dt>
<dd>The place where an <a class="reference internal" href="#term-activation-record"><em class="xref std std-term ODSAterm">activation record</em></a> is stored when a
subroutine is called during a program's runtime.</dd>
<dt id="term-scope">scope</dt>
<dd>The parts of a program that can see and access a variable.</dd>
<dt id="term-search-key">search key</dt>
<dd>A field or part of a record that is used to represent the record
when searching. For example, in a database of customer records,
we might want to search by name.
In this case the name field is used as the search key.</dd>
<dt id="term-search-lower-bound">search lower bound</dt>
<dd>The problem of searching in an array has provable lower bounds
for specific variations of the problem.
For an unsorted array, it is <span class="math">\(\Omega(n)\)</span>
<a class="reference internal" href="#term-comparison"><em class="xref std std-term ODSAterm">comparisons</em></a> in the <a class="reference internal" href="#term-worst-case"><em class="xref std std-term ODSAterm">worst case</em></a>,
typically proved using an <a class="reference internal" href="#term-adversary-argument"><em class="xref std std-term ODSAterm">adversary argument</em></a>.
For a sorted array, it is <span class="math">\(\Omega(\log n)\)</span> in the worst
case, typically proved using an argument similar to the
<a class="reference internal" href="#term-sorting-lower-bound"><em class="xref std std-term ODSAterm">sorting lower bound</em></a> proof.
However, it is possible to search a sorted array in the average
case in <span class="math">\(O(\log \log n)\)</span> time.</dd>
<dt id="term-search-tree">search tree</dt>
<dd>A <a class="reference internal" href="#term-577"><em class="xref std std-term ODSAterm">tree</em></a> data structure that makes search by <a class="reference internal" href="#term-key"><em class="xref std std-term ODSAterm">key</em></a>
value more efficient.
A type of <a class="reference internal" href="#term-container"><em class="xref std std-term ODSAterm">container</em></a>, it is common to implement an
<a class="reference internal" href="#term-indexing"><em class="xref std std-term ODSAterm">index</em></a> using a search tree.
A good search tree implementation will guarentee that insertion,
deletion, and search operations are all <span class="math">\(\Theta(\log n)\)</span>.</dd>
<dt id="term-search-trie">search trie</dt>
<dd>Any <a class="reference internal" href="#term-search-tree"><em class="xref std std-term ODSAterm">search tree</em></a> that is a <a class="reference internal" href="#term-trie"><em class="xref std std-term ODSAterm">trie</em></a>.</dd>
<dt id="term-secondary-clustering">secondary clustering</dt>
<dd>In <a class="reference internal" href="#term-hashing"><em class="xref std std-term ODSAterm">hashing</em></a>, the tendency in certain
<a class="reference internal" href="#term-collision-resolution"><em class="xref std std-term ODSAterm">collision resolution</em></a>
methods to create clustering in sections of the hash table.
In <a class="reference internal" href="#term-primary-clustering"><em class="xref std std-term ODSAterm">primary clustering</em></a>, this is caused by a cluster of
keys that don't necessarily hash to the same slot but which
following significant portions of the same
<a class="reference internal" href="#term-probe-sequence"><em class="xref std std-term ODSAterm">probe sequence</em></a> during collision resolution.
Secondary clustering results from the keys hashing to the same
slot of the table (and so a collision resolution method that is
not affected by the key value must use the same probe sequence
for all such keys).
This problem can be resolved by <a class="reference internal" href="#term-double-hashing"><em class="xref std std-term ODSAterm">double hashing</em></a> since its
probe sequence is determined in part by a second hash function.</dd>
<dt id="term-secondary-index">secondary index</dt>
<dd>Synonym for <a class="reference internal" href="#term-secondary-key-index"><em class="xref std std-term ODSAterm">secondary key index</em></a>.</dd>
<dt id="term-secondary-key">secondary key</dt>
<dd>A key field in a record such as salary, where a particular key
value might be duplicated in multiple records. A secondary key
is more likely to be used by a user as a search key than is the
record's <a class="reference internal" href="#term-primary-key"><em class="xref std std-term ODSAterm">primary key</em></a>.</dd>
<dt id="term-secondary-key-index">secondary key index</dt>
<dd>Associates a <a class="reference internal" href="#term-secondary-key"><em class="xref std std-term ODSAterm">secondary key</em></a> value with the
<a class="reference internal" href="#term-primary-key"><em class="xref std std-term ODSAterm">primary key</em></a> of each record having that secondary key
value.</dd>
<dt id="term-secondary-storage">secondary storage</dt>
<dd>Refers to slower but cheaper means of storing data.
Typical examples include a <a class="reference internal" href="#term-disk-drive"><em class="xref std std-term ODSAterm">disk drive</em></a>, a USB memory
stick, or a solid state drive.</dd>
<dt id="term-sector">sector</dt>
<dd>A unit of space on a <a class="reference internal" href="#term-disk-drive"><em class="xref std std-term ODSAterm">disk drive</em></a> that is the amount of
data that will be read or written at one time by the disk drive
hardware.
This is typically 512 bytes.</dd>
<dt id="term-sector-header">sector header</dt>
<dd>On a disk drive, a piece of information at the start of a
<a class="reference internal" href="#term-sector"><em class="xref std std-term ODSAterm">sector</em></a> that allows the <a class="reference internal" href="#term-i-o-head"><em class="xref std std-term ODSAterm">I/O head</em></a> to recognize the
identity (or equivalently, the address) of the current sector.</dd>
<dt id="term-seek">seek</dt>
<dd>On a <a class="reference internal" href="#term-disk-drive"><em class="xref std std-term ODSAterm">disk drive</em></a>, the act of moving the <a class="reference internal" href="#term-i-o-head"><em class="xref std std-term ODSAterm">I/O head</em></a>
from one <a class="reference internal" href="#term-track"><em class="xref std std-term ODSAterm">track</em></a> to another.
This is usually considered the most expensive step during a
<a class="reference internal" href="#term-disk-access"><em class="xref std std-term ODSAterm">disk access</em></a>.</dd>
<dt id="term-selection-sort">selection sort</dt>
<dd>While this sort requires <span class="math">\(\Theta(n^2)\)</span> time in the
<a class="reference internal" href="#term-best-case"><em class="xref std std-term ODSAterm">best</em></a>, <a class="reference internal" href="#term-average-case"><em class="xref std std-term ODSAterm">average</em></a>,
and <a class="reference internal" href="#term-worst-case"><em class="xref std std-term ODSAterm">worst</em></a> cases, it requires only
<span class="math">\(\Theta(n)\)</span> swap operations.
Thus, it does relatively well in applications where swaps are
expensive.
It can be viewed as an optimization on <a class="reference internal" href="#term-bubble-sort"><em class="xref std std-term ODSAterm">bubble sort</em></a>,
where a swap is deferred until the end of each iteration.</dd>
<dt id="term-self-organizing-list">self-organizing list</dt>
<dd>A list that, over a series of search operations, will make
use of some <a class="reference internal" href="#term-heuristic"><em class="xref std std-term ODSAterm">heuristic</em></a> to re-order its elements in an
effort to improve search times.
Generally speaking, search is done sequentially from the
beginning, but the self-organizing heuristic will attempt to put
the records that are most likely to be searched for at or near
the front of the list.
While typically not as efficient as <a class="reference internal" href="#term-binary-search"><em class="xref std std-term ODSAterm">binary search</em></a> on a
sorted list, self-organizing lists do not require that the list
be sorted (and so do not pay the cost of doing the sorting
operation).</dd>
<dt id="term-self-organizing-list-heuristic">self-organizing list heuristic</dt>
<dd>A <a class="reference internal" href="#term-heuristic"><em class="xref std std-term ODSAterm">heuristic</em></a> to use for the purpose of maintaining a
<a class="reference internal" href="#term-self-organizing-list"><em class="xref std std-term ODSAterm">self-organizing list</em></a>.
Commonly used heuristics include
<a class="reference internal" href="#term-move-to-front"><em class="xref std std-term ODSAterm">move-to-front</em></a> and <a class="reference internal" href="#term-transpose"><em class="xref std std-term ODSAterm">transpose</em></a>.</dd>
<dt id="term-separate-chaining">separate chaining</dt>
<dd>In <a class="reference internal" href="#term-hashing"><em class="xref std std-term ODSAterm">hashing</em></a>, a synonym for
<a class="reference internal" href="#term-open-hash-system"><em class="xref std std-term ODSAterm">open hashing</em></a></dd>
<dt id="term-sequence">sequence</dt>
<dd>In set notation, a collection of elements with an order, and
which may contain duplicate-valued elements.
A sequence is also sometimes called a <a class="reference internal" href="#term-tuple"><em class="xref std std-term ODSAterm">tuple</em></a> or a
<a class="reference internal" href="#term-vector"><em class="xref std std-term ODSAterm">vector</em></a>.</dd>
<dt id="term-sequential-access">sequential access</dt>
<dd>In <a class="reference internal" href="#term-file-processing"><em class="xref std std-term ODSAterm">file processing</em></a> terminology, the requirement that all
records in a file are accessed in sequential order.
Alternatively, a storage device that can only access data
sequentially, such as a tape drive.</dd>
<dt id="term-sequential-fit">sequential fit</dt>
<dd>In a <a class="reference internal" href="#term-memory-manager"><em class="xref std std-term ODSAterm">memory manager</em></a>, the process of searching the
<a class="reference internal" href="#term-memory-pool"><em class="xref std std-term ODSAterm">memory pool</em></a> for a <a class="reference internal" href="#term-free-block"><em class="xref std std-term ODSAterm">free block</em></a> large enough to
service a <a class="reference internal" href="#term-memory-request"><em class="xref std std-term ODSAterm">memory request</em></a>, possibly reserving the
remaining space as a free block.
Examples are <a class="reference internal" href="#term-first-fit"><em class="xref std std-term ODSAterm">first fit</em></a>, <a class="reference internal" href="#term-circular-first-fit"><em class="xref std std-term ODSAterm">circular first fit</em></a>,
<a class="reference internal" href="#term-best-fit"><em class="xref std std-term ODSAterm">best fit</em></a>, and <a class="reference internal" href="#term-worst-fit"><em class="xref std std-term ODSAterm">worst fit</em></a>.</dd>
<dt id="term-sequential-search">sequential search</dt>
<dd>The simplest search algorithm: In an array, simply look at the
array elements in the order that they appear.</dd>
<dt id="term-sequential-tree-representation">sequential tree representation</dt>
<dd>A representation that stores a series of node values with the
minimum information needed to reconstruct the tree structure.
This is a technique for <a class="reference internal" href="#term-serialization"><em class="xref std std-term ODSAterm">serializing</em></a> a
tree.</dd>
<dt id="term-serialization">serialization</dt>
<dd>The process of taking a data structure in memory and
representing it as a sequence of bytes.
This is sometimes done in order to transmit the data structure
across a network or store the data structure in a
<a class="reference internal" href="#term-stream"><em class="xref std std-term ODSAterm">stream</em></a>, such as on disk.
<a class="reference internal" href="#term-deserialization"><em class="xref std std-term ODSAterm">Deserialization</em></a> reconstructs the
original data structure from the serialized representation.</dd>
<dt id="term-set">set</dt>
<dd>A collection of distinguishable <a class="reference internal" href="#term-member"><em class="xref std std-term ODSAterm">members</em></a> or
<a class="reference internal" href="#term-element"><em class="xref std std-term ODSAterm">elements</em></a>.</dd>
<dt id="term-set-product">set product</dt>
<dd>Written <span class="math">\(\mathbf{Q} \times \mathbf{P}\)</span>, the set product is
a set of ordered pairs such that ordered pair <span class="math">\((a, b)\)</span> is
in the product whenever <span class="math">\(a \in \mathbf{P}\)</span> and
<span class="math">\(b \in \mathbf{Q}\)</span>.
For example, when <span class="math">\(\mathbf{P} = \{2, 3, 5\}\)</span> and
<span class="math">\(\mathbf{Q} = \{5, 10\}\)</span>,
<span class="math">\(\mathbf{Q} \times \mathbf{P} =
\{(2, 5),\ (2, 10),\ (3, 5),\ (3, 10),\ (5, 5),\ (5, 10)\}\)</span>.</dd>
<dt id="term-shallow-copy">shallow copy</dt>
<dd>Copying the <a class="reference internal" href="#term-reference"><em class="xref std std-term ODSAterm">reference</em></a> or <a class="reference internal" href="#term-pointer"><em class="xref std std-term ODSAterm">pointer</em></a>
value without copying the actual content.</dd>
<dt id="term-shellsort">Shellsort</dt>
<dd>A sort that relies on the best-case cost of
<a class="reference internal" href="#term-insertion-sort"><em class="xref std std-term ODSAterm">insertion sort</em></a> to improve over <span class="math">\(\Theta(n^2)\)</span>
<a class="reference internal" href="#term-worst-case"><em class="xref std std-term ODSAterm">worst case</em></a> cost.</dd>
<dt id="term-shifting-method">shifting method</dt>
<dd>A technique for finding a <a class="reference internal" href="#term-closed-form-solution"><em class="xref std std-term ODSAterm">closed-form solution</em></a> to a
<a class="reference internal" href="#term-summation"><em class="xref std std-term ODSAterm">summation</em></a> or <a class="reference internal" href="#term-recurrence-relation"><em class="xref std std-term ODSAterm">recurrence relation</em></a>.</dd>
<dt id="term-shortest-path">shortest path</dt>
<dd>Given a <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> with distances or <a class="reference internal" href="#term-weight"><em class="xref std std-term ODSAterm">weights</em></a>
on the <a class="reference internal" href="#term-edge"><em class="xref std std-term ODSAterm">edges</em></a>, the shortest path between two nodes
is the path with least total distance or weight.
Examples of the shortest paths problems are the
<a class="reference internal" href="#term-single-source-shortest-paths-problem"><em class="xref std std-term ODSAterm">single-source shortest paths problem</em></a> and the
<a class="reference internal" href="#term-all-pairs-shortest-paths-problem"><em class="xref std std-term ODSAterm">all-pairs shortest paths problem</em></a>.</dd>
<dt id="term-sibling">sibling</dt>
<dd>In a <a class="reference internal" href="#term-577"><em class="xref std std-term ODSAterm">tree</em></a>, a sibling of <a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">node</em></a> <span class="math">\(A\)</span> is any
other node with the same <a class="reference internal" href="#term-parent"><em class="xref std std-term ODSAterm">parent</em></a> as <span class="math">\(A\)</span>.</dd>
<dt id="term-signature">signature</dt>
<dd>In a programming language, the signature for a function is its
return type and its list of parameters and their types.</dd>
<dt id="term-simple-cycle">simple cycle</dt>
<dd>In <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> terminology, a <a class="reference internal" href="#term-cycle"><em class="xref std std-term ODSAterm">cycle</em></a> is simple if its
corresponding <a class="reference internal" href="#term-path"><em class="xref std std-term ODSAterm">path</em></a> is simple, except that the first and
last <a class="reference internal" href="#term-vertex"><em class="xref std std-term ODSAterm">vertices</em></a> of the cycle are the same.</dd>
<dt id="term-simple-path">simple path</dt>
<dd>In <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> terminology, a <a class="reference internal" href="#term-path"><em class="xref std std-term ODSAterm">path</em></a> is simple if all
vertices on the path are distinct.</dd>
<dt id="term-simple-type">simple type</dt>
<dd>A <a class="reference internal" href="#term-data-type"><em class="xref std std-term ODSAterm">data type</em></a> whose values contain no subparts.
An example is the integers.</dd>
<dt id="term-simulating-recursion">simulating recursion</dt>
<dd>If a programming language does not support <a class="reference internal" href="#term-recursion"><em class="xref std std-term ODSAterm">recursion</em></a>,
or if you want to implement the effects of recursion more
efficiently, you can use a <a class="reference internal" href="#term-stack"><em class="xref std std-term ODSAterm">stack</em></a> to maintain the
collection of subproblems that
would be waiting for completion during the recursive process.
Using a loop, whenever a recursive call would have been made,
simply add the necessary program state to the stack.
When a return would have been made from the recursive call, pop
the previous program state off of the stack.</dd>
<dt id="term-single-rotation">single rotation</dt>
<dd>A type of <a class="reference internal" href="#term-rebalancing-operation"><em class="xref std std-term ODSAterm">rebalancing operation</em></a> used by the
<a class="reference internal" href="#term-splay-tree"><em class="xref std std-term ODSAterm">Splay Tree</em></a> and <a class="reference internal" href="#term-avl-tree"><em class="xref std std-term ODSAterm">AVL Tree</em></a>.</dd>
<dt id="term-single-source-shortest-paths-problem">single-source shortest paths problem</dt>
<dd>Given a <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> with <a class="reference internal" href="#term-weight"><em class="xref std std-term ODSAterm">weights</em></a> or
distances on the <a class="reference internal" href="#term-edge"><em class="xref std std-term ODSAterm">edges</em></a>, and a designated start
<a class="reference internal" href="#term-vertex"><em class="xref std std-term ODSAterm">vertex</em></a> <span class="math">\(s\)</span>, find the shortest path from <span class="math">\(s\)</span>
to every other vertex in the graph.
One algorithm to solve this problem is <a class="reference internal" href="#term-dijkstra-s-algorithm"><em class="xref std std-term ODSAterm">Dijkstra's algorithm</em></a>.</dd>
<dt id="term-singly-linked-list">singly linked list</dt>
<dd>A <a class="reference internal" href="#term-linked-list"><em class="xref std std-term ODSAterm">linked list</em></a> implementation variant where each list
node contains access an pointer only to the next element in the list.</dd>
<dt id="term-skip-list">skip list</dt>
<dd>A form of <a class="reference internal" href="#term-linked-list"><em class="xref std std-term ODSAterm">linked list</em></a> that adds additional links to
improve the cost of fundamental operations like insert, delete,
and search.
It is a <a class="reference internal" href="#term-probabilistic-data-structure"><em class="xref std std-term ODSAterm">probabilistic data structure</em></a> since it adds the
additional links using a <a class="reference internal" href="#term-probabilistic-algorithm"><em class="xref std std-term ODSAterm">probabilistic algorithm</em></a>.
It can implement a <a class="reference internal" href="#term-dictionary"><em class="xref std std-term ODSAterm">dictionary</em></a> more efficiently than a
<a class="reference internal" href="#term-bst"><em class="xref std std-term ODSAterm">BST</em></a>, and is roughly as difficult to implement.</dd>
<dt id="term-slot">slot</dt>
<dd>In <a class="reference internal" href="#term-hashing"><em class="xref std std-term ODSAterm">hashing</em></a>, a position in a <a class="reference internal" href="#term-hash-table"><em class="xref std std-term ODSAterm">hash table</em></a>.</dd>
<dt id="term-snowplow-argument">snowplow argument</dt>
<dd>An analogy used to give intuition for why <a class="reference internal" href="#term-replacement-selection"><em class="xref std std-term ODSAterm">replacement
selection</em></a> will generate <a class="reference internal" href="#term-run"><em class="xref std std-term ODSAterm">runs</em></a> that are on average
twice the size of working memory.
Records coming from the input stream have key values that might
be of any size, whose size is related to the position of a
falling snowflake.
The replacement selection process is analogous to a snowplow
that moves around a circular track picking up snow.
In steady state, given a certain amount of snow equivalent to
<a class="reference internal" href="#term-working-memory"><em class="xref std std-term ODSAterm">working memory</em></a> size <span class="math">\(M\)</span>, an amount of snow
(incoming records from the input stream) is expected to fall
ahead of the plow as the size of the working memory during one
cycle of the plow (analogously, one run of the replacement
selection algorithm).
Thus, the snowplow is expected in one pass (one run of
replacement selection) to pick up <span class="math">\(2M\)</span> snow.</dd>
<dt id="term-software-engineering">software engineering</dt>
<dd>The study and application of engineering to the design,
development, and maintenance of software.</dd>
<dt id="term-software-reuse">software reuse</dt>
<dd>In <a class="reference internal" href="#term-software-engineering"><em class="xref std std-term ODSAterm">software engineering</em></a>, the concept of reusing a piece
of software.
In particular, using an existing piece of software (such as a
function or library) when creating new software.</dd>
<dt id="term-sorted-list">sorted list</dt>
<dd>A <a class="reference internal" href="#term-list"><em class="xref std std-term ODSAterm">list</em></a> where the records stored in the list are arranged
so that their <a class="reference internal" href="#term-key"><em class="xref std std-term ODSAterm">key</em></a> values are in ascending order.
If the list uses an <a class="reference internal" href="#term-array-based-list"><em class="xref std std-term ODSAterm">array-based list</em></a> implementation,
then it can use <a class="reference internal" href="#term-binary-search"><em class="xref std std-term ODSAterm">binary search</em></a> for a cost of
<span class="math">\(\Theta(\log n)\)</span>.
But both insertion and deletion will be require
<span class="math">\(\Theta(n)\)</span> time.</dd>
<dt id="term-sorting-lower-bound">sorting lower bound</dt>
<dd>The lower bound for the <a class="reference internal" href="#term-problem"><em class="xref std std-term ODSAterm">problem</em></a> of
:term:sorting &lt;sorting problem&gt;` is <span class="math">\(\Omega(n \log n)\)</span>.
This is traditionally proved using a <a class="reference internal" href="#term-decision-tree"><em class="xref std std-term ODSAterm">decision tree</em></a> model
for sorting algorithms, and recognizing that the minimum depth
of the decision tree for any sorting algorithm is
<span class="math">\(\Omega(n \log n)\)</span> since there are <span class="math">\(n!\)</span> permutations
of the <span class="math">\(n\)</span> input records to distinguish between during the
sorting process.</dd>
<dt id="term-sorting-problem">sorting problem</dt>
<dd>Given a set of records <span class="math">\(r_1\)</span>, <span class="math">\(r_2\)</span>, ..., <span class="math">\(r_n\)</span>
with <a class="reference internal" href="#term-key"><em class="xref std std-term ODSAterm">key</em></a> values <span class="math">\(k_1\)</span>, <span class="math">\(k_2\)</span>, ..., <span class="math">\(k_n\)</span>,
the sorting problem is to arrange the records into any order
<span class="math">\(s\)</span> such that records
<span class="math">\(r_{s_1}\)</span>, <span class="math">\(r_{s_2}\)</span>, ..., <span class="math">\(r_{s_n}\)</span>
have keys obeying the property
<span class="math">\(k_{s_1} \leq k_{s_2} \leq ... \leq k_{s_n}\)</span>.
In other words, the sorting problem is to arrange a set of
records so that the values of their key fields are in
non-decreasing order.</dd>
<dt id="term-space-time-tradeoff">space/time tradeoff</dt>
<dd>Many programs can be designed to either speed processing at the
cost of additional storage, or reduce storage at the cost of
additional processing time.</dd>
<dt id="term-sparse-graph">sparse graph</dt>
<dd>A <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> where the actual number of <a class="reference internal" href="#term-edge"><em class="xref std std-term ODSAterm">edges</em></a>
is much less than the possible number of edges.
Generally, this is interpreted to mean that the <a class="reference internal" href="#term-degree"><em class="xref std std-term ODSAterm">degree</em></a>
for any <a class="reference internal" href="#term-vertex"><em class="xref std std-term ODSAterm">vertex</em></a> in the graph is relatively low.</dd>
<dt id="term-sparse-matrix">sparse matrix</dt>
<dd>A matrix whose values are mostly zero.
There are a number of data structures that have been developed
to store sparse matrices, with the goal of reducing the amount
of space required to represent it as compared to simply using a
regular matrix representation that stores a value for every
matrix position.</dd>
<dt id="term-spatial">spatial</dt>
<dd>Referring to a position in space.</dd>
<dt id="term-spatial-application">spatial application</dt>
<dd>An application what has spatial aspects.
In particular, an application that stores records that need to
be searched by location.</dd>
<dt id="term-spatial-attribute">spatial attribute</dt>
<dd>An attribute of a record that has a position in space, such as
the coordinate.
This is typically in two or more dimensions.</dd>
<dt id="term-spatial-data">spatial data</dt>
<dd>Any object or record that has a position (in space).</dd>
<dt id="term-spatial-data-structure">spatial data structure</dt>
<dd>A <a class="reference internal" href="#term-data-structure"><em class="xref std std-term ODSAterm">data structure</em></a> designed to support efficient
processing when a
<a class="reference internal" href="#term-spatial-attribute"><em class="xref std std-term ODSAterm">spatial attribute</em></a> is used as the key.
In particular, a data structure that supports efficient search
by location, or finds all records within a given region in two
or more dimensions.
Examples of spatial data structures to store point data include
the <a class="reference internal" href="#term-bintree"><em class="xref std std-term ODSAterm">bintree</em></a>, the <a class="reference internal" href="#term-pr-quadtree"><em class="xref std std-term ODSAterm">PR quadtree</em></a> and the
<a class="reference internal" href="#term-kd-tree"><em class="xref std std-term ODSAterm">kd tree</em></a>.</dd>
<dt id="term-spindle">spindle</dt>
<dd>The center of a <a class="reference internal" href="#term-disk-drive"><em class="xref std std-term ODSAterm">disk drive</em></a> that holds the
<a class="reference internal" href="#term-platter"><em class="xref std std-term ODSAterm">platters</em></a> in place.</dd>
<dt id="term-splay-tree">Splay Tree</dt>
<dd>A variant implementation for the <a class="reference internal" href="#term-bst"><em class="xref std std-term ODSAterm">BST</em></a>, which differs from
the standard BST in that it uses modified insert and remove
methods in order to keep the tree
<a class="reference internal" href="#term-balanced-tree"><em class="xref std std-term ODSAterm">balanced</em></a>.
Similar to an <a class="reference internal" href="#term-avl-tree"><em class="xref std std-term ODSAterm">AVL Tree</em></a> in that it uses the concept of
<a class="reference internal" href="#term-rotation"><em class="xref std std-term ODSAterm">rotations</em></a> in the insert and remove operations.
While a Splay Tree does not guarentee that the tree is balanced,
it does guarentee that a series of <span class="math">\(n\)</span> operations on the
tree will have a total cost of <span class="math">\(\Theta(n \log n)\)</span> cost,
meaning that any given operation can be viewed as having
<a class="reference internal" href="#term-amortized-cost"><em class="xref std std-term ODSAterm">amortized cost</em></a> of <span class="math">\(\Theta(\log n)\)</span>.</dd>
<dt id="term-splaying">splaying</dt>
<dd>The act of performing an <a class="reference internal" href="#term-rebalancing-operation"><em class="xref std std-term ODSAterm">rebalancing operation</em></a> on a
<a class="reference internal" href="#term-splay-tree"><em class="xref std std-term ODSAterm">Splay Tree</em></a>.</dd>
<dt id="term-stable">stable</dt>
<dd>A sorting algorithm is said to be stable if it does not
change the relative ordering of records with identical
<a class="reference internal" href="#term-key"><em class="xref std std-term ODSAterm">key</em></a> values.</dd>
<dt id="term-stack">stack</dt>
<dd>A list-like structure in which elements may be inserted or
removed from only one end.</dd>
<dt id="term-stack-frame">stack frame</dt>
<dd>Frame of data that pushed into and poped from call stack</dd>
<dt id="term-stack-variable">stack variable</dt>
<dd>Another name for a <a class="reference internal" href="#term-local-variable"><em class="xref std std-term ODSAterm">local variable</em></a>.</dd>
<dt id="term-stale-pointer">stale pointer</dt>
<dd>Within the context of a <a class="reference internal" href="#term-buffer-pool"><em class="xref std std-term ODSAterm">buffer pool</em></a> or
<a class="reference internal" href="#term-memory-manager"><em class="xref std std-term ODSAterm">memory manager</em></a>, this refers to a reference to a
<a class="reference internal" href="#term-buffer"><em class="xref std std-term ODSAterm">buffer</em></a> or memory location that is no longer valid.
For example, a program might make a memory request to a buffer
pool, and be given a reference to the buffer holding the
requested data.
Over time, due to inactivity, the contents of this buffer might
be flushed.
If the program holding the buffer reference then tries to access
the contents of that buffer again, then the data contents will
have changed.
The possibility for this to occur depends on the design of the
interface to the buffer pool system.
Some designs make this impossible to occur.
Other designs make it possible in an attempt to deliver greater
performance.</dd>
<dt id="term-static">static</dt>
<dd>Something that is not changing (in contrast to <a class="reference internal" href="#term-dynamic"><em class="xref std std-term ODSAterm">dynamic</em></a>).
In computer programming, static normally refers to something
that happens at compile time.
For example, static analysis is analysis of the program's text
or structure, as opposed to its run-time behavior.
Static binding or static memory allocation occurs at compile time.</dd>
<dt id="term-strassen-s-algorithm">Strassen's algorithm</dt>
<dd>A <a class="reference internal" href="#term-recursion"><em class="xref std std-term ODSAterm">recursive</em></a> algorithm for matrix
multiplication.
When multiplying two <span class="math">\(n \times n\)</span> matrices,
this algorithm runs faster than the <span class="math">\(\Theta(n^3)\)</span> time
required by the standard matrix multiplication algorithm.
Specifically, Strassen's algorithm requires time
<span class="math">\(Theta(n^{\log_2 7})\)</span> time.
This is achieved by refactoring the sub-matrix multiplication
and addition operations so as to need only 7 sub-matrix
multiplications instead of 8, at a cost of additional sub-matrix
addition operations.
Thus, while the asymptotic cost is lower, the constant factor in
the growth rate equation is higher.
This makes Strassen's algorithm inefficient in practice unless
the arrays being multiplied are rather large.
Variations on Strassen's algorithm exist that reduce the number
of sub-matrix multiplications even futher at a cost of even more
sub-matrix additions.</dd>
<dt id="term-strategy">strategy</dt>
<dd>An approach to accomplish a task, often encapsulated as an
algorithm.
Also the name for a <a class="reference internal" href="#term-design-pattern"><em class="xref std std-term ODSAterm">design pattern</em></a> that separates the
algorithm for performing a task from the control for applying
that task to each member of a collection.
A good example is a generic sorting function that takes a
collection of records (such as an array) and a &quot;strategy&quot; in the
form of an algorithm that knows how to extract the key from a
record in the array.
Only subtly different from the <a class="reference internal" href="#term-visitor"><em class="xref std std-term ODSAterm">visitor</em></a> design pattern,
where the difference is primarily one of intent rather than
syntax.
The strategy design pattern is focused on encapsulating an
activity that is part of a larger process, so that different
ways of performing that activity can be substituted.
The visitor design pattern is focused on encapsulating an
activity that will be performed on all members of a collection
so that completely different activities can be substituted
within a generic method that accesses all of the collection
members.</dd>
<dt id="term-stream">stream</dt>
<dd>The process of delivering content in a
<a class="reference internal" href="#term-serialization"><em class="xref std std-term ODSAterm">serialized</em></a> form.</dd>
<dt id="term-strict-partial-order">strict partial order</dt>
<dd>In set notation, a relation that is <a class="reference internal" href="#term-irreflexive"><em class="xref std std-term ODSAterm">irreflexive</em></a>,
<a class="reference internal" href="#term-antisymmetric"><em class="xref std std-term ODSAterm">antisymmetric</em></a>, and <a class="reference internal" href="#term-transitive"><em class="xref std std-term ODSAterm">transitive</em></a>.</dd>
<dt id="term-strong-induction">strong induction</dt>
<dd>An alternative formulation for the <a class="reference internal" href="#term-induction-step"><em class="xref std std-term ODSAterm">induction step</em></a> in a
<a class="reference internal" href="#term-proof-by-induction"><em class="xref std std-term ODSAterm">proof by induction</em></a>.
The induction step for strong induction is:
If <strong>Thrm</strong> holds for all <span class="math">\(k, c \leq k &lt; n\)</span>, then
<strong>Thrm</strong> holds for <span class="math">\(n\)</span>.</dd>
<dt id="term-subclass">subclass</dt>
<dd>In <a class="reference internal" href="#term-object-oriented-programming-paradigm"><em class="xref std std-term ODSAterm">object-oriented programming</em></a>,
any class within a <a class="reference internal" href="#term-class-hierarchy"><em class="xref std std-term ODSAterm">class hierarchy</em></a> that
<a class="reference internal" href="#term-inherit"><em class="xref std std-term ODSAterm">inherits</em></a> from some other class.</dd>
<dt id="term-subgraph">subgraph</dt>
<dd>A subgraph <span class="math">\(\mathbf{S}\)</span> is formed from <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a>
<span class="math">\(\mathbf{G}\)</span> by selecting a <a class="reference internal" href="#term-subset"><em class="xref std std-term ODSAterm">subset</em></a>
<span class="math">\(\mathbf{V}_s\)</span> of <span class="math">\(\mathbf{G}\)</span>'s <a class="reference internal" href="#term-vertex"><em class="xref std std-term ODSAterm">vertices</em></a> and a subset <span class="math">\(\mathbf{E}_s\)</span> of
<span class="math">\(\mathbf{G}\)</span>'s <a class="reference internal" href="#term-edge"><em class="xref std std-term ODSAterm">edges</em></a> such that for every
edge <span class="math">\(e \in \mathbf{E}_s\)</span>,
both vertices of <span class="math">\(e\)</span> are in <span class="math">\(\mathbf{V}_s\)</span>.</dd>
<dt id="term-subset">subset</dt>
<dd>In set theory, a set <span class="math">\(A\)</span> is a subset of a set
<span class="math">\(B\)</span>, or equivalently <span class="math">\(B\)</span> is a <a class="reference internal" href="#term-superset"><em class="xref std std-term ODSAterm">superset</em></a> of
<span class="math">\(A\)</span>, if all elements of <span class="math">\(A\)</span> are also elements of
<span class="math">\(B\)</span>.</dd>
<dt id="term-subtract-and-guess">subtract-and-guess</dt>
<dd>A technique for finding a <a class="reference internal" href="#term-closed-form-solution"><em class="xref std std-term ODSAterm">closed-form solution</em></a> to a
<a class="reference internal" href="#term-summation"><em class="xref std std-term ODSAterm">summation</em></a> or <a class="reference internal" href="#term-recurrence-relation"><em class="xref std std-term ODSAterm">recurrence relation</em></a>.</dd>
<dt id="term-subtree">subtree</dt>
<dd>A subtree is a <a class="reference internal" href="#term-subset"><em class="xref std std-term ODSAterm">subset</em></a> of the nodes of a binary tree that
includes some node <span class="math">\(R\)</span> of the tree as the subtree
<a class="reference internal" href="#term-root"><em class="xref std std-term ODSAterm">root</em></a> along with all the <a class="reference internal" href="#term-descendant"><em class="xref std std-term ODSAterm">descendants</em></a>
of <span class="math">\(R\)</span>.</dd>
<dt id="term-successful-search">successful search</dt>
<dd>When searching for a <a class="reference internal" href="#term-key"><em class="xref std std-term ODSAterm">key</em></a> value in a collection of
records, we might find it.
If so, we call this a successful search.
The alternative is an <a class="reference internal" href="#term-unsuccessful-search"><em class="xref std std-term ODSAterm">unsuccessful search</em></a>.</dd>
<dt id="term-summation">summation</dt>
<dd>The sum of costs for some <a class="reference internal" href="#term-function"><em class="xref std std-term ODSAterm">function</em></a> applied to a
range of parameter values.
Often written using Sigma notation.
For example, the sum of the integers from 1 to <span class="math">\(n\)</span> can be
written as <span class="math">\(\sum_{i=1}^{n} i\)</span>.</dd>
<dt id="term-superset">superset</dt>
<dd>In set theory, a set <span class="math">\(A\)</span> is a <a class="reference internal" href="#term-subset"><em class="xref std std-term ODSAterm">subset</em></a> of a
<a class="reference internal" href="#term-set"><em class="xref std std-term ODSAterm">set</em></a> <span class="math">\(B\)</span>, or equivalently <span class="math">\(B\)</span> is a
<a class="reference internal" href="#term-superset"><em class="xref std std-term ODSAterm">superset</em></a> of <span class="math">\(A\)</span>, if all <a class="reference internal" href="#term-element"><em class="xref std std-term ODSAterm">elements</em></a>
of <span class="math">\(A\)</span> are also elements of <span class="math">\(B\)</span>.</dd>
<dt id="term-symmetric">symmetric</dt>
<dd>In set notation, relation <span class="math">\(R\)</span> is symmetric if whenever
<span class="math">\(aRb\)</span>, then <span class="math">\(bRa\)</span>, for all <span class="math">\(a, b \in \mathbf{S}\)</span>.</dd>
<dt id="term-symmetric-matrix">symmetric matrix</dt>
<dd>A square matrix that is equal to its <a class="reference internal" href="#term-transpose"><em class="xref std std-term ODSAterm">transpose</em></a>.
Equivalently, for a <span class="math">\(n \times n\)</span> matrix <span class="math">\(A\)</span>,
for all <span class="math">\(i,j &lt; n\)</span>, <span class="math">\(A[i, j] = A[j, i]\)</span>.</dd>
<dt id="term-tail">tail</dt>
<dd>The end of a <a class="reference internal" href="#term-list"><em class="xref std std-term ODSAterm">list</em></a>.</dd>
<dt id="term-theta-notation">Theta notation</dt>
<dd>In <a class="reference internal" href="#term-algorithm-analysis"><em class="xref std std-term ODSAterm">algorithm analysis</em></a>, <span class="math">\(\Theta\)</span> notation is used
to indicate that the
<a class="reference internal" href="#term-upper-bound"><em class="xref std std-term ODSAterm">upper bound</em></a> and <a class="reference internal" href="#term-lower-bound"><em class="xref std std-term ODSAterm">lower bound</em></a> for an
<a class="reference internal" href="#term-algorithm"><em class="xref std std-term ODSAterm">algorithm</em></a> or <a class="reference internal" href="#term-problem"><em class="xref std std-term ODSAterm">problem</em></a> match.</dd>
<dt id="term-tombstone">tombstone</dt>
<dd>In <a class="reference internal" href="#term-hashing"><em class="xref std std-term ODSAterm">hashing</em></a>, a tombstone is used to mark a <a class="reference internal" href="#term-slot"><em class="xref std std-term ODSAterm">slot</em></a>
in the <a class="reference internal" href="#term-hash-table"><em class="xref std std-term ODSAterm">hash table</em></a> where a record has been deleted.
Its purpose is to allow the <a class="reference internal" href="#term-collision-resolution"><em class="xref std std-term ODSAterm">collision resolution</em></a> process
to probe through that slot (so that records further down the
<a class="reference internal" href="#term-probe-sequence"><em class="xref std std-term ODSAterm">probe sequence</em></a> are not unreachable after deleting the
record), while also allowing the slot to be reused by a future
insert operation.</dd>
<dt id="term-topological-sort">topological sort</dt>
<dd>The process of laying out the <a class="reference internal" href="#term-vertex"><em class="xref std std-term ODSAterm">vertices</em></a> of a
<a class="reference internal" href="#term-dag"><em class="xref std std-term ODSAterm">DAG</em></a> in a <a class="reference internal" href="#term-linear-order"><em class="xref std std-term ODSAterm">linear order</em></a> such that no vertex
<span class="math">\(A\)</span> in the order is preceded by a vertex that can be
reached by a (directed) <a class="reference internal" href="#term-path"><em class="xref std std-term ODSAterm">path</em></a> from <span class="math">\(A\)</span>.
Usually the (directed) edges in the graph define a
prerequisite system, and the goal of the topological sort is
to list the vertices in an order such that no prerequisites are
violated.</dd>
<dt id="term-total-order">total order</dt>
<dd>A binary relation on a set where every pair of distinct elements
in the set are <a class="reference internal" href="#term-comparable"><em class="xref std std-term ODSAterm">comparable</em></a> (that is, one can determine
which of the pair is greater than the other).</dd>
<dt id="term-towers-of-hanoi-problem">Towers of Hanoi problem</dt>
<dd>A standard example of a recursive algorithm.
The problem starts with a stack of disks (each with unique size)
stacked decreasing order on the left pole, and two additional
poles.
The problem is to move the disks to the right pole, with the
constraints that only one disk can be moved at a time and a
disk may never be on top of a smaller disk.
For <span class="math">\(n\)</span> disks, this problem requires <span class="math">\(\Theta(2^n)\)</span>
moves.
The standard solution is to move <span class="math">\(n-1\)</span> disks to the middle
pole, move the bottom disk to the right pole, and then move the
<span class="math">\(n-1\)</span> disks on the middle pole to the right pole.</dd>
<dt id="term-track">track</dt>
<dd>On a <a class="reference internal" href="#term-disk-drive"><em class="xref std std-term ODSAterm">disk drive</em></a>, a concentric circle representing all of
the <a class="reference internal" href="#term-sector"><em class="xref std std-term ODSAterm">sectors</em></a> that can be viewed by the
<a class="reference internal" href="#term-i-o-head"><em class="xref std std-term ODSAterm">I/O head</em></a> as the disk rotates.
The significance is that, for a given placement of the I/O head,
the sectors on the track can be read without performing a
(relatively expensive) <a class="reference internal" href="#term-seek"><em class="xref std std-term ODSAterm">seek</em></a> operation.</dd>
<dt id="term-track-to-track-seek-time">track-to-track seek time</dt>
<dd>Expected (average) time to perform a <a class="reference internal" href="#term-seek"><em class="xref std std-term ODSAterm">seek</em></a> operation from
a random <a class="reference internal" href="#term-track"><em class="xref std std-term ODSAterm">track</em></a> to an adjacent track.
Thus, this can be viewed as the minimum possible seek time for the
<a class="reference internal" href="#term-disk-drive"><em class="xref std std-term ODSAterm">disk drive</em></a>.
This is one of two metrics commonly provided by disk drive
vendors for disk drive performance, with the other being
<a class="reference internal" href="#term-average-seek-time"><em class="xref std std-term ODSAterm">average seek time</em></a>.</dd>
<dt id="term-trailer-node">trailer node</dt>
<dd>Commonly used in implementations for a <a class="reference internal" href="#term-linked-list"><em class="xref std std-term ODSAterm">linked list</em></a> or
related structure, this <a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">node</em></a> follows the last element
of the list.
Its purpose is to simplify the code implementation by
reducing the number of special cases that must be programmed
for.</dd>
<dt id="term-transitive">transitive</dt>
<dd>In set notation, relation <span class="math">\(R\)</span> is transitive if whenever
<span class="math">\(aRb\)</span> and <span class="math">\(bRc\)</span>, then <span class="math">\(aRc\)</span>, for all
<span class="math">\(a, b, c \in \mathbf{S}\)</span>.</dd>
<dt id="term-transpose">transpose</dt>
<dd>In the context of linear algebra,
the transpose of a matrix <span class="math">\(A\)</span> is
another matrix <span class="math">\(A^T\)</span> created by writing the rows of
<span class="math">\(A\)</span> as the columns of <span class="math">\(A^T\)</span>.
In the context of a <a class="reference internal" href="#term-self-organizing-list"><em class="xref std std-term ODSAterm">self-organizing list</em></a>,
transpose is a <a class="reference internal" href="#term-heuristic"><em class="xref std std-term ODSAterm">heuristic</em></a> used to maintain the list.
Under this heuristic, whenever a record is accessed it is moved
one position closer to the front of the list.</dd>
<dt id="term-traversal">traversal</dt>
<dd>Any process for visiting all of the objects in a collection
(such as a <a class="reference internal" href="#term-577"><em class="xref std std-term ODSAterm">tree</em></a> or <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a>) in some order.</dd>
<dt id="term-577">tree</dt>
<dd>A tree <span class="math">\(\mathbf{T}\)</span> is a finite set of one or more
<a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">nodes</em></a> such that there is one designated node
<span class="math">\(R\)</span>, called the <a class="reference internal" href="#term-root"><em class="xref std std-term ODSAterm">root</em></a> of <span class="math">\(\mathbf{T}\)</span>.
If the set <span class="math">\((\mathbf{T} -\{R\})\)</span> is not empty, these
nodes are partitioned into <span class="math">\(n &gt; 0\)</span>
<a class="reference internal" href="#term-disjoint-sets"><em class="xref std std-term ODSAterm">disjoint sets</em></a> <span class="math">\(\mathbf{T}_0\)</span>,
<span class="math">\(\mathbf{T}_1\)</span>, ..., <span class="math">\(\mathbf{T}_{n-1}\)</span>,
each of which is a tree, and whose <a class="reference internal" href="#term-root"><em class="xref std std-term ODSAterm">roots</em></a>
<span class="math">\(R_1, R_2, ..., R_n\)</span>,
respectively, are <a class="reference internal" href="#term-child"><em class="xref std std-term ODSAterm">children</em></a> of <span class="math">\(R\)</span>.</dd>
<dt id="term-tree-traversal">tree traversal</dt>
<dd>A <a class="reference internal" href="#term-traversal"><em class="xref std std-term ODSAterm">traversal</em></a> performed on a tree.
Traditional tree traversals include
<a class="reference internal" href="#term-preorder-traversal"><em class="xref std std-term ODSAterm">preorder</em></a> and
<a class="reference internal" href="#term-postorder-traversal"><em class="xref std std-term ODSAterm">postorder</em></a> traversals for both
<a class="reference internal" href="#term-binary-tree"><em class="xref std std-term ODSAterm">binary</em></a> and <a class="reference internal" href="#term-general-tree"><em class="xref std std-term ODSAterm">general</em></a>
trees, and :term`inorder traversal` that is most
appropriate for a <a class="reference internal" href="#term-bst"><em class="xref std std-term ODSAterm">BST</em></a>.</dd>
<dt id="term-trie">trie</dt>
<dd>A form of <a class="reference internal" href="#term-search-tree"><em class="xref std std-term ODSAterm">search tree</em></a> where an internal node represents
a split in the <a class="reference internal" href="#term-key-space"><em class="xref std std-term ODSAterm">key space</em></a> at a predetermined location,
rather than split based on the actual <a class="reference internal" href="#term-key"><em class="xref std std-term ODSAterm">key</em></a> values seen.
For example, a simple binary search trie for key values in the
range 0 to 1023 would store all records with key values less
than 512 on the left side of the tree, and all records with key
values equal to or greater than 512 on the right side of the
tree.
A trie is always a <a class="reference internal" href="#term-full-tree"><em class="xref std std-term ODSAterm">full tree</em></a>.
Folklore has it that the term comes from &quot;retrieval&quot;, and should
be pronounced as &quot;try&quot; (in contrast to &quot;tree&quot;, to distinguish
the differences in the space decomposition method of a search
tree versus a search trie).
The term &quot;trie&quot; is also sometimes used as a synonym for the
<a class="reference internal" href="#term-alphabet-trie"><em class="xref std std-term ODSAterm">alphabet trie</em></a>.</dd>
<dt id="term-truth-table">truth table</dt>
<dd>In symbolic logic, a table that contains as rows all possible
combinations of the boolean variables, with a column that shows
the outcome (true or false) for the expression when given that
row's truth assignment for the boolean variables.</dd>
<dt id="term-tuple">tuple</dt>
<dd>In set notation, another term for a <a class="reference internal" href="#term-sequence"><em class="xref std std-term ODSAterm">sequence</em></a>.</dd>
<dt id="term-two-coloring">two-coloring</dt>
<dd>An assignment from two colors to regions in an image
such that no two regions sharing a side have the same color.</dd>
<dt id="term-type">type</dt>
<dd>A collection of values.</dd>
<dt id="term-underflow">underflow</dt>
<dd>The condition where the amount of data stored in an entity has
dropped below some minimum threshold.
For example, a node in a <a class="reference internal" href="#term-37"><em class="xref std std-term ODSAterm">B-tree</em></a> is required to be at
least half full.
If a record deletion causes the node to be less than half full,
then it is in a condition of underflow, and something has to be
done to correct this.</dd>
<dt id="term-undirected-edge">undirected edge</dt>
<dd>An <a class="reference internal" href="#term-edge"><em class="xref std std-term ODSAterm">edge</em></a> that connects two <a class="reference internal" href="#term-vertex"><em class="xref std std-term ODSAterm">vertices</em></a> with
no direction between them.
Many graph representations will represent such an edge
with two <a class="reference internal" href="#term-directed-edge"><em class="xref std std-term ODSAterm">directed edges</em></a>.</dd>
<dt id="term-undirected-graph">undirected graph</dt>
<dd>A <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> whose <a class="reference internal" href="#term-edge"><em class="xref std std-term ODSAterm">edges</em></a> do not have a direction.</dd>
<dt id="term-uninitialized">uninitialized</dt>
<dd>uninitialized variable means it has no initial value.</dd>
<dt id="term-union">UNION</dt>
<dd>One half of the <a class="reference internal" href="#term-union-find"><em class="xref std std-term ODSAterm">UNION/FIND</em></a> algorithm for managing
<a class="reference internal" href="#term-disjoint-sets"><em class="xref std std-term ODSAterm">disjoint sets</em></a>. It is the process of merging two trees
that are represented using the
<a class="reference internal" href="#term-parent-pointer-representation"><em class="xref std std-term ODSAterm">parent pointer representation</em></a> by making the root for one
of the trees set its parent pointer to the root of the other
tree.</dd>
<dt id="term-union-find">UNION/FIND</dt>
<dd>A process for mainining a collection of disjoint sets.
The <a class="reference internal" href="#term-find"><em class="xref std std-term ODSAterm">FIND</em></a> operation determines which disjoint set a given
object resides in, and the <a class="reference internal" href="#term-union"><em class="xref std std-term ODSAterm">UNION</em></a> operation combines two
disjoint sets when it is determined that they are members of the
same <a class="reference internal" href="#term-equivalence-class"><em class="xref std std-term ODSAterm">equivalence class</em></a> under some
<a class="reference internal" href="#term-equivalence-relation"><em class="xref std std-term ODSAterm">equivalence relation</em></a>.</dd>
<dt id="term-unsolveable-problem">unsolveable problem</dt>
<dd>A problem that can proved impossible to solve on a computer.
The classic example is the <a class="reference internal" href="#term-halting-problem"><em class="xref std std-term ODSAterm">halting problem</em></a>.</dd>
<dt id="term-unsorted-list">unsorted list</dt>
<dd>A <a class="reference internal" href="#term-list"><em class="xref std std-term ODSAterm">list</em></a> where the records stored in the list can appear
in any order (as opposed to a <a class="reference internal" href="#term-sorted-list"><em class="xref std std-term ODSAterm">sorted list</em></a>).
An unsorted list can support efficient (<span class="math">\(\Theta(1)\)</span>)
insertion time (since you can put the record anywhere
convenient), but requires <span class="math">\(\Theta(n)\)</span> time for both search
and and deletion.</dd>
<dt id="term-unsuccessful-search">unsuccessful search</dt>
<dd>When searching for a <a class="reference internal" href="#term-key"><em class="xref std std-term ODSAterm">key</em></a> value in a collection of
records, we might not find it.
If so, we call this an unsuccessful search.
Usually we require that this means that no record in the
collection actually has that key value
(though a <a class="reference internal" href="#term-probabilistic-algorithm"><em class="xref std std-term ODSAterm">probabilistic algorithm</em></a> for search might not
require this to be true).
The alternative to an unsuccessful search is a
<a class="reference internal" href="#term-successful-search"><em class="xref std std-term ODSAterm">successful search</em></a>.</dd>
<dt id="term-unvisited">unvisited</dt>
<dd>In <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> algorithms, this refers to a node that has not
been processed at the current point in the algorithm.
This information is typically maintained by using a
<a class="reference internal" href="#term-mark-array"><em class="xref std std-term ODSAterm">mark array</em></a>.</dd>
<dt id="term-upper-bound">upper bound</dt>
<dd>In <a class="reference internal" href="#term-algorithm-analysis"><em class="xref std std-term ODSAterm">algorithm analysis</em></a>, a <a class="reference internal" href="#term-growth-rate"><em class="xref std std-term ODSAterm">growth rate</em></a> that is
always greater than or equal to the that of the
<a class="reference internal" href="#term-algorithm"><em class="xref std std-term ODSAterm">algorithm</em></a> in question.
In practice, this is the slowest-growing function that we know
grows at least as fast as all but a constant number of inputs.
It could be a gross over-estimate of the truth.
Since the upper bound for the algorithm can be very different
for different situations (such as the <a class="reference internal" href="#term-best-case"><em class="xref std std-term ODSAterm">best case</em></a> or
<a class="reference internal" href="#term-worst-case"><em class="xref std std-term ODSAterm">worst case</em></a>), we typically have to specify which
situation we are referring to.</dd>
<dt id="term-value-parameter">value parameter</dt>
<dd>A <a class="reference internal" href="#term-parameter"><em class="xref std std-term ODSAterm">parameter</em></a> that has been
<a class="reference internal" href="#term-pass-by-value"><em class="xref std std-term ODSAterm">passed by value</em></a>.
Changing such a parameter inside the function or method will not
affect the value of the calling parameter.</dd>
<dt id="term-variable-length-coding">variable-length coding</dt>
<dd>Given a collection of objects, a variable-length coding scheme
assigns a code to each object in the collection using codes that
can be of different lengths.
Typically this is done in a way such that the objects that are
most likely to be used have the shortest codes, with the goal of
minimizing the total space needed to represent a sequence of
objects, such as when representing the characters in a document.
<a class="reference internal" href="#term-huffman-codes"><em class="xref std std-term ODSAterm">Huffman coding</em></a> is an example of a
variable-length coding scheme.
This is in contrast to <a class="reference internal" href="#term-fixed-length-coding"><em class="xref std std-term ODSAterm">fixed-length coding</em></a>.</dd>
<dt id="term-vector">vector</dt>
<dd>In set notation, another term for a <a class="reference internal" href="#term-sequence"><em class="xref std std-term ODSAterm">sequence</em></a>.
As a data structure, the term vector usually used as a snyonym
for a <a class="reference internal" href="#term-dynamic-array"><em class="xref std std-term ODSAterm">dynamic array</em></a>.</dd>
<dt id="term-vertex">vertex</dt>
<dd>Another name for a <a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">node</em></a> in a <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a>.</dd>
<dt id="term-virtual-memory">virtual memory</dt>
<dd>A memory management technique for making relatively fast but
small memory appear larger to the program.
The large &quot;virtual&quot; data space is actually stored on a
relatively slow but large <a class="reference internal" href="#term-backing-storage"><em class="xref std std-term ODSAterm">backing storage</em></a> device, and
portions of the data are copied into the smaller, faster memory
as needed by use of a <a class="reference internal" href="#term-buffer-pool"><em class="xref std std-term ODSAterm">buffer pool</em></a>.
A common example is to use <a class="reference internal" href="#term-ram"><em class="xref std std-term ODSAterm">RAM</em></a> to manage access to a
large virtual space that is actually stored on a
<a class="reference internal" href="#term-disk-drive"><em class="xref std std-term ODSAterm">disk drive</em></a>.
The programmer can implement a program as though the entire
data content were stored in RAM, even if that is larger than the
physical RAM available making it easier to implement.</dd>
<dt id="term-visit">visit</dt>
<dd>During the process of a <a class="reference internal" href="#term-traversal"><em class="xref std std-term ODSAterm">traversal</em></a> on a <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> or
<a class="reference internal" href="#term-577"><em class="xref std std-term ODSAterm">tree</em></a> the action that takes place on each <a class="reference internal" href="#term-node"><em class="xref std std-term ODSAterm">node</em></a>.</dd>
<dt id="term-visited">visited</dt>
<dd>In <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> algorithms, this refers to a node that has
previously been processed at the current point in the
algorithm.
This information is typically maintained by using a
<a class="reference internal" href="#term-mark-array"><em class="xref std std-term ODSAterm">mark array</em></a>.</dd>
<dt id="term-visitor">visitor</dt>
<dd>A <a class="reference internal" href="#term-design-pattern"><em class="xref std std-term ODSAterm">design pattern</em></a> where a <a class="reference internal" href="#term-traversal"><em class="xref std std-term ODSAterm">traversal</em></a> process is
given a function (known as the visitor) that is applied to every
object in the collection being traversed.
For example, a generic tree or graph traversal might be
designed such that it takes a function parameter,
where that function is applied to each node.</dd>
<dt id="term-volatile">volatile</dt>
<dd>In the context of computer memory, this refers to a memory that
loses all stored information when the power is turned off.</dd>
<dt id="term-weight">weight</dt>
<dd>A cost or distance most often associated with an <a class="reference internal" href="#term-edge"><em class="xref std std-term ODSAterm">edge</em></a> in
a <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a>.</dd>
<dt id="term-weighted-graph">weighted graph</dt>
<dd>A <a class="reference internal" href="#term-graph"><em class="xref std std-term ODSAterm">graph</em></a> whose <a class="reference internal" href="#term-edge"><em class="xref std std-term ODSAterm">edges</em></a> each have an
associated <a class="reference internal" href="#term-weight"><em class="xref std std-term ODSAterm">weight</em></a> or cost.</dd>
<dt id="term-weighted-path-length">weighted path length</dt>
<dd>Given a tree, and given a <a class="reference internal" href="#term-weight"><em class="xref std std-term ODSAterm">weight</em></a> for each leaf in the
tree, the weighted path length for a leaf is its weight
times its <a class="reference internal" href="#term-depth"><em class="xref std std-term ODSAterm">depth</em></a>.</dd>
<dt id="term-weighted-union-rule">weighted union rule</dt>
<dd>When merging two disjoint sets using the <a class="reference internal" href="#term-union-find"><em class="xref std std-term ODSAterm">UNION/FIND</em></a>
algorithm, the weighted union rule is used to determine which
subtree's root points to the other.
The root of the subtree with fewer nodes will be set to point to
the root of the subtree with more nodes.
In this way, the average depth of nodes in the resulting tree
will be less than if the assignment had been made in the other
direction.</dd>
<dt id="term-working-memory">working memory</dt>
<dd>The portion of <a class="reference internal" href="#term-main-memory"><em class="xref std std-term ODSAterm">main memory</em></a> available to an algorithm for
its use.
Typically refers to main memory made available to an algorithm
that is operating on large amounts of data stored in
<a class="reference internal" href="#term-peripheral-storage"><em class="xref std std-term ODSAterm">peripheral storage</em></a>, the working memory represents space
that can hold some subset of the total data being processed.</dd>
<dt id="term-worst-case">worst case</dt>
<dd>In algorithm analysis, the <a class="reference internal" href="#term-problem-instance"><em class="xref std std-term ODSAterm">problem instance</em></a> from among
all problem instances for a given input size <span class="math">\(n\)</span> that has
the greatest cost. Note that the worst case is <strong>not</strong> when
<span class="math">\(n\)</span> is big, since we are referring to the wost from a
class of inputs (i.e, those inputs of size <span class="math">\(n\)</span>).</dd>
<dt id="term-worst-fit">worst fit</dt>
<dd>In a <a class="reference internal" href="#term-memory-manager"><em class="xref std std-term ODSAterm">memory manager</em></a>, worst fit is a <a class="reference internal" href="#term-heuristic"><em class="xref std std-term ODSAterm">heuristic</em></a>
for deciding which <a class="reference internal" href="#term-free-block"><em class="xref std std-term ODSAterm">free block</em></a> to use when allocating
memory from a <a class="reference internal" href="#term-memory-pool"><em class="xref std std-term ODSAterm">memory pool</em></a>.
Worst fit will always allocate from the largest free block.
The rationale is that this will be the method least likely to
cause <a class="reference internal" href="#term-external-fragmentation"><em class="xref std std-term ODSAterm">external fragmentation</em></a> in the form of small,
unuseable memory blocks.
The disadvantage is that it tends to eliminate the availability
of large freeblocks needed for unusually large requests.</dd>
<dt id="term-zigzig">zigzig</dt>
<dd>A type of <a class="reference internal" href="#term-rebalancing-operation"><em class="xref std std-term ODSAterm">rebalancing operation</em></a> used by
<a class="reference internal" href="#term-splay-tree"><em class="xref std std-term ODSAterm">splay trees</em></a>.</dd>
<dt id="term-zipf-distribution">Zipf distribution</dt>
<dd>A data distribution that follows Zipf's law, an emprical
observation that many types of data studied in the physical and
social sciences follow a power law probability distribution.
That is, the frequency of any record in the data collection is
inversely proportional to its rank when the collection is sorted
by frequency.
Thus, the most frequently appearing record has a frequency much
higher than the next most frequently appearing record, which in
turn has a frequency much higher than the third (but with ratio
slightly lower than that for the first two records) and so on.
The <a class="reference internal" href="#term-rule"><em class="xref std std-term ODSAterm">80/20 rule</em></a> is a casual characterization of a Zipf
distribution.
Adherence to a Zipf distribution is important to the successful
operation of a <a class="reference internal" href="#term-caching"><em class="xref std std-term ODSAterm">cache</em></a> or
<a class="reference internal" href="#term-self-organizing-list"><em class="xref std std-term ODSAterm">self-organizing list</em></a>.</dd>
<dt id="term-zone">zone</dt>
<dd>In <a class="reference internal" href="#term-memory-manager"><em class="xref std std-term ODSAterm">memory management</em></a>, the concept that
different parts of the <a class="reference internal" href="#term-memory-pool"><em class="xref std std-term ODSAterm">memory pool</em></a> are handled in
different ways.
For example, some of the memory might be handled by a simple
<a class="reference internal" href="#term-freelist"><em class="xref std std-term ODSAterm">freelist</em></a>, while other portions of the memory pool might
be handled by a <a class="reference internal" href="#term-sequential-fit"><em class="xref std std-term ODSAterm">sequential fit</em></a> memory manager.
On a <a class="reference internal" href="#term-disk-drive"><em class="xref std std-term ODSAterm">disk drive</em></a> the concept of a zone relates to the
fact that there are limits to the maximum data density, combined
with the fact that the need for the same angular distance to be
used for a sector in each track means that tracks further from
the center of the disk will become progressively less dense.
A zone in this case is a series of adjacent tracks whose data
density is set by the maximum density of the innermost track of
that zone.
The next zone can then reset the data density for its innermost
track, thereby gaining more total storage space while preserving
angular distance for each sector.</dd>
</dl>
</div>


      </div>
      <div class="bottomnav">
      <p><span class="email_div" style="display:inline;"><a id="contact_us" class="contact" style="float:left;color:blue;" rel="nofollow" href="mailto:">Contact Us |</a><a style="float:left;color:blue;" rel="nofollow" href="../../../lib/Privacy.html" target="_blank">| Privacy |</a> <a style="float:left;color:blue;" rel="nofollow" href="../../../lib/license.html" target="_blank">| License</a></span>&#160;&#160;
      
        «&#160;&#160;<a id="prevmod1" href="HeapMem.html">1.1. Heap Memory</a>
        &#160;&#160;::&#160;&#160;
        <a  class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a  id="nextmod1" href="Bibliography.html">2.2. Bibliography</a>&#160;&#160;»

</p>
      </div>
      <img style="float:right;" src="_static/nsf1.gif" height="62" width="62" alt="nsf"/>


    <div class="footer">
      <p>
        <span class="email_div" style="display:inline;">
          <a id="contact_us" class="contact" style="float:left;color:blue;" rel="nofollow" href="mailto:">Contact Us |</a>
          <a id="bugreport-link" style="float:left;color:blue;" class="bugreport-link" href="#">| Report a bug</a>
        </span>
      </p>
        &copy; Copyright 2016 by OpenDSA Project Contributors and distributed under an MIT license.
      Last updated on Oct 25, 2017.
      Created using <a target="_blank" href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.
    </div>
    
<div id="bugreport-box" class="bugreport-popup ">
  <a href="#" class="close"><img src="_static/Images/close_pop.png" class="btn_close" title="Close Window" alt="Close Window" /></a>
  <form method="post" class="report" action="https://#">
    <fieldset class="textbox">
      <div id="bug_error" class="error"></div>
      <label>
        <span>Summary*:</span>
        <input type="text" id="b_title" placeholder="Summary" />
      </label>

      <label class="os">
        <span>Operating system*:</span>
        <select id="b_os">
          <option value="windows">Windows</option>
          <option value="macos">Mac OS</option>
          <option value="linux">Linux</option>
          <option value="ios">iOS</option>
          <option value="android">Android</option>
          <option value="other">Other</option>
        </select>
      </label>

      <label class="browser">
        <span>Browser*:</span>
        <select id="b_browser">
          <option value="chrome">Chrome</option>
          <option value="safari">Safari</option>
          <option value="internetexplorer">Internet Explorer</option>
          <option value="opera">Opera</option>
          <option value="other">Other</option>
        </select>
      </label>

      <label class="description">
        <span>Description*:</span><br>
        <textarea id="b_description" rows="5" cols="25" placeholder="***BUG** Please enter: (1) a consice description of the problem. (2) steps to reproduce bug. (3) the version of your browser and operating system."></textarea>
      </label>

      <label class="screenshot">
        <span>Attach a screenshot (optional):</span>
        <input type="file" id="b_screenshot" accept="image/*" placeholder="Attach a screenshot (optional)">
      </label>

      <p>
        <input type="submit" id="bug-submit-button" value="Submit &rarr;"/>
      </p>
    </fieldset>
  </form>
</div>

  </body>
</html>