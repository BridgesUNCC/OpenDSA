
<!DOCTYPE html>




<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>11.4. Buffer Pools &mdash; COMP232: Data Structures and Algorithms</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/normalize.css" type="text/css" />
    <link rel="stylesheet" href="../../../JSAV/css/JSAV.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/odsaMOD-min.css" type="text/css" />
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.11.4/themes/smoothness/jquery-ui.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/odsaStyle-min.css" type="text/css" />
    
  <script type="text/javascript">
    var DOCUMENTATION_OPTIONS = {
      URL_ROOT:    './',
      VERSION:     '0.4.1',
      COLLAPSE_INDEX: false,
      FILE_SUFFIX: '.html',
      HAS_SOURCE:  true
    };
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
      },
      "HTML-CSS": {
        scale: "80"
      }
    });
  </script>
    <link rel="index" title="COMP232: Data Structures and Algorithms" href="index.html" />
    <link rel="next" title="5. The Programmer&#39;s View of Files" href="FileProg.html" />
    <link rel="prev" title="3. Disk Drives" href="Diskdrive.html" />

  </head>

  <body>


      <div class="header">
        
  
      <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
      <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="https://code.jquery.com/ui/1.11.4/jquery-ui.min.js"></script>
    <script type="text/javascript" src="../../../JSAV/lib/jquery.transit.js"></script>
    <script type="text/javascript" src="../../../JSAV/lib/raphael.js"></script>
    <script type="text/javascript" src="../../../JSAV/build/JSAV-min.js"></script>
    <script type="text/javascript" src="_static/config.js"></script>
    <script type="text/javascript" src="../../../lib/odsaUtils-min.js"></script>
    <script type="text/javascript" src="../../../lib/odsaMOD-min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js"></script>
    <script type="text/javascript" src="../../../lib/dataStructures.js"></script>
    <script type="text/javascript" src="../../../lib/conceptMap.js"></script>

        
<a id="username-link" style="float:right;color:red;margin:10px 20px auto; display: none" class="username-link" href="Gradebook.html"></a>
<a id="login-link" style="float:right;color:red;margin:10px 20px auto" class="login-link" href="#"><Macro 'login'></a>
<div id="login-box" class="login-popup">
  <a href="#" class="close"><img src="_static/Images/close_pop.png" class="btn_close" title="Close Window" alt="Close" /></a>
  <form method="post" class="signin" action="https://#">
    <fieldset class="textbox">
      <label class="username">
        <span>Username</span>
        <input id="username" value="" type="text" autocomplete="on" placeholder="Username" tabindex="1">
      </label>
      <label class="password">
        <span>Password</span>
        <input id="password" value="" type="password" placeholder="Password" tabindex="2">
        <span><a id="forgot" href="#">Forgot your password?</a></span>
      </label>

      <p>
        <input type="submit" id="login-submit-button" value="Sign in" tabindex="3" />
      </p>
      <p>
        <input type="button" id="register-button" value="Register" tabindex="4" />
      </p>
    </fieldset>
  </form>
</div>

        
<a id="registration-link" style="float:right;color:red;margin:10px 20px auto" class="registration-link" href="#">Register</a>
<div id="registration-box" class="registration-popup ">
  <a href="#" class="close"><img src="_static/Images/close_pop.png" class="btn_close" title="Close Window" alt="Close Window" /></a>
  <form method="post" class="signin" action="https://#">
    <fieldset class="textbox">
      <div id="register_error" class="error"></div>
      <label class="username">
        <span>Username:</span>
        <input type="text" id="user" placeholder="Username" />
      </label>

      <label class="password">
        <span>Password</span>
        <input id="pass" type="password" placeholder="Password" />
      </label>

      <label class="password">
        <span>Confirm Password</span>
        <input id="rpass" type="password" placeholder="Confirm Password" />
      </label>

      <label class="email">
        <span>Email:</span>
        <input type="text" id="email" placeholder="Email">
      </label>

      <p>
        <input type="submit" id="register-submit-button" value="Register &rarr;"/>
      </p>
    </fieldset>
  </form>
</div>
<img class="leftlogo" src="_static/OpenDSALogoT64.png" alt="Logo"/><div class="title-wrapper">
          <div class="title-inbetween" style="display: table-cell; vertical-align: middle;">
            <div class="title-content">
              <h1 class="heading" ><a href="index.html">
                <span>COMP232: Data Structures and Algorithms</span></a></h1>
              <h2 class="heading" ><span>Chapter 11 File Processing</span></h2>
            </div>
          </div>
        </div>
      </div>
      <div class="topnav">
        <p>
            <a style="float:left;color:blue;" href="../source/BuffPool.rst"
              target="_blank" rel="nofollow">Show Source | </a>&#160;&#160;
            <a class="abt" style="float:left;color:blue;" href="#" rel="nofollow">| About</a>&#160;&#160;

          
        «&#160;&#160;<a id="prevmod" href="Diskdrive.html">11.3. Disk Drives</a>
        &#160;&#160;::&#160;&#160;
        <a  class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a  id="nextmod" href="FileProg.html">11.5. The Programmer's View of Files</a>&#160;&#160;»


        </p>
      </div>
       
      <div class="content">
        
  <script>ODSA.SETTINGS.DISP_MOD_COMP = true;ODSA.SETTINGS.MODULE_NAME = "BuffPool";ODSA.SETTINGS.MODULE_LONG_NAME = "Buffer Pools";ODSA.SETTINGS.MODULE_CHAPTER = "File Processing"; ODSA.SETTINGS.BUILD_DATE = "2017-11-27 23:03:58"; ODSA.SETTINGS.BUILD_CMAP = false;JSAV_OPTIONS['lang']='en';JSAV_EXERCISE_OPTIONS['code']='java_generic';</script><link href="../../../AV/Files/buffpoolCON.css" rel="stylesheet" type="text/css" />
<div class="section" id="buffer-pools">
<h1>11.4. Buffer Pools<a class="headerlink" href="#buffer-pools" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2>11.4.1. Buffer Pools<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>Given a disk drive
rotating at 5400 rpm, <a class="reference internal" href="Glossary.html#term-average-seek-time"><em class="xref std std-term ODSAterm">average seek time</em></a> of 9.5ms,
and <a class="reference internal" href="Glossary.html#term-track-to-track-seek-time"><em class="xref std std-term ODSAterm">track-to-track seek time</em></a> of 2.2ms,
we can calculate that it takes about
<span class="math">\(9.5 + 11.1 \times 1.5 = 26.2\)</span> ms
to read one <a class="reference internal" href="Glossary.html#term-track"><em class="xref std std-term ODSAterm">track</em></a> of data on average.
It takes about
<span class="math">\(9.5 + 11.1/2 + (1/256)\times11.1 = 15.1\)</span> ms on average
to read a single <a class="reference internal" href="Glossary.html#term-sector"><em class="xref std std-term ODSAterm">sector</em></a> of data.
This is a good savings (slightly over half the time), but
less than 1% of the data on the track are read.
If we want to read only a single byte, it would save us effectively no
time over that required to read an entire sector.
For this reason, nearly all disk drives automatically read or write
an entire sector's worth of information whenever the disk is
accessed, even when only one byte of information is requested.</p>
<p>Once a sector is read, its information is stored in main memory.
This is known as <a class="reference internal" href="Glossary.html#term-buffering"><em class="xref std std-term ODSAterm">buffering</em></a> or <a class="reference internal" href="Glossary.html#term-caching"><em class="xref std std-term ODSAterm">caching</em></a> the information.
If the next disk request is to that same sector, then
it is not necessary to read from disk again because the information is
already stored in main memory.
Buffering is an example of a standard method for minimizing disk
accesses:
Bring off additional information from disk to satisfy future
requests.
If information from files were accessed at random, then the
chance that two consecutive disk requests are to the same sector
would be low.
However, in practice most disk requests are close to the location
(in the logical file at least) of the previous request,
a concept referred to as <a class="reference internal" href="Glossary.html#term-locality-of-reference"><em class="xref std std-term ODSAterm">locality of reference</em></a>.
This means that the probability of the next request
&quot;hitting the cache&quot; is much higher than chance would indicate.</p>
<p>This principle explains one reason why average access times for new
<a class="reference internal" href="Glossary.html#term-disk-drive"><em class="xref std std-term ODSAterm">disk drives</em></a> are lower than in the past.
Not only is the hardware faster, but information is also now stored
using better algorithms and larger caches that minimize the number
of times information needs to be fetched from disk.
This same concept is also used to store parts of programs in faster
memory within the CPU, using the CPU cache that is
prevalent in modern microprocessors.</p>
<p>Sector-level buffering is normally provided by the operating system
and is often built directly into the disk drive controller hardware.
Most operating systems maintain at least two buffers,
one for input and one for output.
Consider what would happen if there were only one buffer during a
byte-by-byte copy operation.
The sector containing the first byte would be read into the I/O
buffer.
The output operation would need to destroy the contents of the single
I/O buffer to write this byte.
Then the buffer would need to be filled again from disk for the
second byte, only to be destroyed during output.
The simple solution to this problem is to keep one buffer for input,
and a second for output.</p>
<p>Most disk drive controllers operate independently
from the CPU once an I/O request is received.
This is useful because the CPU can typically execute millions of
instructions during the time required for a single I/O operation.
A technique that takes maximum advantage of this micro-parallelism is
<a class="reference internal" href="Glossary.html#term-double-buffering"><em class="xref std std-term ODSAterm">double buffering</em></a>.
Imagine that a file is being processed sequentially.
While the first sector is being read, the CPU cannot process that
information and so must wait or find something else to do in the
meantime.
Once the first sector is read, the CPU can start processing
while the disk drive (in parallel) begins reading
the second sector.
If the time required for the CPU to process a sector is approximately
the same as the time required by the disk controller to read a sector,
it might be possible to keep the CPU continuously fed with data from
the file.
The same concept can also be applied to output, writing one sector to
disk while the CPU is writing to a second output buffer in memory.
Thus, in an operationg system that support double buffering, it pays
to have at least two input buffers and two output buffers available.</p>
<p>Caching information in memory is such a good idea that
it is usually extended to multiple buffers.
The operating system
or an application program might store many buffers of information
taken from some <a class="reference internal" href="Glossary.html#term-backing-storage"><em class="xref std std-term ODSAterm">backing storage</em></a> such as a disk file.
This process of using buffers as an intermediary between a user and a
disk file is called <a class="reference internal" href="Glossary.html#term-buffering"><em class="xref std std-term ODSAterm">buffering</em></a> the file.
The information stored in a buffer is often called a <a class="reference internal" href="Glossary.html#term-page"><em class="xref std std-term ODSAterm">page</em></a>, and
the collection of buffers is called a <a class="reference internal" href="Glossary.html#term-buffer-pool"><em class="xref std std-term ODSAterm">buffer pool</em></a>.
The goal of the buffer pool is to increase the amount of information
stored in memory in hopes of increasing the likelihood that new
information requests can be satisfied from the buffer pool rather
than requiring new information to be read from disk.</p>
<div id="buffintroCON" class="ssAV" data-points="0.0" data-threshold="1.0" data-type="ss" data-required="True" data-long-name="Buffer Pool Introduction Slideshow">
 <span class="jsavcounter"></span>
 <a class="jsavsettings" href="#">Settings</a>
 <div class="jsavcontrols"></div>
 <p class="jsavoutput jsavline"></p>
 <div class="jsavcanvas"></div>
 <div class="prof_indicators">
  <img id="buffintroCON_check_mark" class="prof_check_mark" src="_static/Images/green_check.png" alt="Proficient" />
  <span id="buffintroCON_cm_saving_msg" class="cm_saving_msg">Saving...</span>
  <span id="buffintroCON_cm_error_msg" class="cm_error_msg">
   <img id="buffintroCON_cm_warning_icon" class="cm_warning_icon" src="_static/Images/warning.png" alt="Error Saving" /><br />
   Server Error<br />
   <a href="#" class="resubmit_link">Resubmit</a>
  </span>
 </div>
</div>
<p></p>
<div class="section" id="replacement-strategies">
<h3>11.4.1.1. Replacement Strategies<a class="headerlink" href="#replacement-strategies" title="Permalink to this headline">¶</a></h3>
<p>As long as there is an unused buffer available in the buffer pool,
new information can be read in from disk on demand.
When an application continues to read new information from
disk, eventually all of the buffers in the buffer pool will become
full.
Once this happens, some decision must be made about what information
in the buffer pool will be sacrificed to make room for newly
requested information.</p>
<p>When replacing information contained in the buffer pool,
the goal is to select a buffer that has &quot;unnecessary&quot;
information, that is, the information least likely to be requested
again.
Because the buffer pool cannot know for certain what the pattern of
future requests will look like, a decision based on some
<a class="reference internal" href="Glossary.html#term-heuristic"><em class="xref std std-term ODSAterm">heuristic</em></a>, or best guess, must be used.
There are several approaches to making this decision.</p>
<p>One heuristic is <a class="reference internal" href="Glossary.html#term-fifo"><em class="xref std std-term ODSAterm">first-in, first-out</em></a>.
This scheme simply orders the buffers in a queue.
The buffer at the front of the queue is used next to store new
information and then placed at the end of the queue.
In this way, the buffer to be replaced is the one that has held its
information the longest, in hopes that this information is no longer
needed.
This is a reasonable assumption when processing moves along the file
at some steady pace in roughly sequential order.
However, many programs work with certain key pieces of
information over and over again, and the importance of information has
little to do with how long ago the information was first accessed.
Typically it is more important to know how many times the information
has been accessed, or how recently the information was last accessed.</p>
<p>Another approach is called <a class="reference internal" href="Glossary.html#term-least-frequently-used"><em class="xref std std-term ODSAterm">least frequently used</em></a> (<a class="reference internal" href="Glossary.html#term-lfu"><em class="xref std std-term ODSAterm">LFU</em></a>).
LFU tracks the number of accesses to each buffer in the
buffer pool.
When a buffer must be reused, the buffer that
has been accessed the fewest number of times is considered to contain
the &quot;least important&quot; information, and so it is used next.
LFU, while it seems intuitively reasonable, has many drawbacks.
First, it is necessary to store and update access counts for each buffer.
Second, what was referenced many times in the past might now be
irrelevant.
Thus, some time mechanism where counts &quot;expire&quot; is often desirable.
This also avoids the problem of buffers that slowly build up big
counts because they get used just often enough to avoid being
replaced.
An alternative is to maintain counts for all sectors ever read, not
just the sectors currently in the buffer pool.
This avoids immediately replacing the buffer just read, which has not
yet had time to build a high access count.</p>
<p>The third approach is called <a class="reference internal" href="Glossary.html#term-least-recently-used"><em class="xref std std-term ODSAterm">least recently used</em></a>
(<a class="reference internal" href="Glossary.html#term-lru"><em class="xref std std-term ODSAterm">LRU</em></a>).
LRU simply keeps the buffers in a list.
Whenever information in a buffer is accessed, this buffer is brought
to the front of the list.
When new information must be read, the buffer at the back of the
list (the one least recently used) is taken and its &quot;old&quot;
information is either discarded or written to disk, as appropriate.
This is an easily implemented approximation to LFU and is often the
method of choice for managing buffer pools unless
special knowledge about information access patterns for an application
suggests a special-purpose buffer management scheme.</p>
<div id="LRUCON" class="ssAV" data-points="0.0" data-threshold="1.0" data-type="ss" data-required="True" data-long-name="LRU Replacement Slideshow">
 <span class="jsavcounter"></span>
 <a class="jsavsettings" href="#">Settings</a>
 <div class="jsavcontrols"></div>
 <p class="jsavoutput jsavline"></p>
 <div class="jsavcanvas"></div>
 <div class="prof_indicators">
  <img id="LRUCON_check_mark" class="prof_check_mark" src="_static/Images/green_check.png" alt="Proficient" />
  <span id="LRUCON_cm_saving_msg" class="cm_saving_msg">Saving...</span>
  <span id="LRUCON_cm_error_msg" class="cm_error_msg">
   <img id="LRUCON_cm_warning_icon" class="cm_warning_icon" src="_static/Images/warning.png" alt="Error Saving" /><br />
   Server Error<br />
   <a href="#" class="resubmit_link">Resubmit</a>
  </span>
 </div>
</div>
<p></p>
</div>
<div class="section" id="the-dirty-bit">
<h3>11.4.1.2. The Dirty Bit<a class="headerlink" href="#the-dirty-bit" title="Permalink to this headline">¶</a></h3>
<p>The main purpose of a buffer pool is to minimize disk I/O.
When the contents of a block are modified, we could write the updated
information to disk immediately.
But what if the block is changed again?
If we write the block's contents after every change, that might be a
lot of disk write operations that can be avoided.
It is more efficient to wait until either the file is to be closed,
or the contents of the buffer containing that block is to be flushed
from the buffer pool.</p>
<p>When a buffer's contents are to be replaced in the buffer pool,
we only want to write the contents to disk if it is necessary.
That would be necessary only if the contents have changed since the
block was read in originally from the file.
The way to insure that the block is written when necessary, but only
when necessary, is to maintain a Boolean variable with the buffer
(often referred to as the <a class="reference internal" href="Glossary.html#term-dirty-bit"><em class="xref std std-term ODSAterm">dirty bit</em></a>) that is turned on when
the buffer's contents are modified by the client.
At the time when the block is flushed from the buffer pool, it is
written to disk if and only if the dirty bit has been turned on.</p>
<div id="LRUwriteCON" class="ssAV" data-points="0.0" data-threshold="1.0" data-type="ss" data-required="True" data-long-name="LRU Replacement with write Slideshow">
 <span class="jsavcounter"></span>
 <a class="jsavsettings" href="#">Settings</a>
 <div class="jsavcontrols"></div>
 <p class="jsavoutput jsavline"></p>
 <div class="jsavcanvas"></div>
 <div class="prof_indicators">
  <img id="LRUwriteCON_check_mark" class="prof_check_mark" src="_static/Images/green_check.png" alt="Proficient" />
  <span id="LRUwriteCON_cm_saving_msg" class="cm_saving_msg">Saving...</span>
  <span id="LRUwriteCON_cm_error_msg" class="cm_error_msg">
   <img id="LRUwriteCON_cm_warning_icon" class="cm_warning_icon" src="_static/Images/warning.png" alt="Error Saving" /><br />
   Server Error<br />
   <a href="#" class="resubmit_link">Resubmit</a>
  </span>
 </div>
</div>
<p></p>
<p>Modern operating systems support <a class="reference internal" href="Glossary.html#term-virtual-memory"><em class="xref std std-term ODSAterm">virtual memory</em></a>.
Virtual memory is a technique that allows the programmer to write
programs as though there is more of the faster main memory (such as
RAM) than actually exists.
Virtual memory makes use of a buffer pool to store data read from
blocks on slower, secondary memory (such as on the disk drive).
The disk stores the complete contents of the virtual memory.
Blocks are read into main memory as demanded by memory accesses.
Naturally, programs using virtual memory techniques are slower than
programs whose data are stored completely in main memory.
The advantage is reduced programmer effort because a good virtual memory
system provides the appearance of larger main memory without
modifying the program.</p>
<p>Here is a visualization to let you experiment with the various buffer
pool replacement strategies.</p>
<div
    id="BufferPoolAV"
    class="embedContainer"
    data-exer-name="BufferPoolAV"
    data-long-name="Buffer Pool Visualization"
    data-frame-src="../../../AV/Files/BufferPoolAV.html?selfLoggingEnabled=false&amp;localMode=true&amp;module=BuffPool&amp;JOP-lang=en&amp;JXOP-code=java_generic"
    data-frame-width="950"
    data-frame-height="650"
    data-external="false"
    data-points="0"
    data-required="False"
    data-showhide="none"
    data-threshold="1.0"
    data-type="ss">
  
  <div class="center">
    <div id="BufferPoolAV_iframe"></div>
  </div>
</div>
</div>
<div class="section" id="implementing-buffer-pools">
<h3>11.4.1.3. Implementing Buffer Pools<a class="headerlink" href="#implementing-buffer-pools" title="Permalink to this headline">¶</a></h3>
<p>When implementing buffer pools, there are two basic approaches that can
be taken regarding the transfer of information between the user of the
buffer pool and the buffer pool class itself.
The first approach is to pass &quot;messages&quot; between the two.
This approach is illustrated by the following abstract class:</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="c1">// ADT for buffer pools using the message-passing style</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">BufferPoolADT</span> <span class="o">{</span>
  <span class="c1">// Copy &quot;sz&quot; bytes from &quot;space&quot; to position &quot;pos&quot; in the buffered storage</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">space</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sz</span><span class="o">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="o">);</span>

  <span class="c1">// Copy &quot;sz&quot; bytes from position &quot;pos&quot; of the buffered storage to &quot;space&quot;</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">getbytes</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">space</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sz</span><span class="o">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>
</div>
<p>This simple class provides an interface with two member functions,
<code class="docutils literal"><span class="pre">insert</span></code> and <code class="docutils literal"><span class="pre">getbytes</span></code>.
The information is passed between the buffer pool user and the
buffer pool through the <code class="docutils literal"><span class="pre">space</span></code> parameter.
This is storage space, provided by the bufferpool client and at least
<code class="docutils literal"><span class="pre">sz</span></code> bytes long, which the
buffer pool can take information from (the <code class="docutils literal"><span class="pre">insert</span></code> function) or
put information into (the <code class="docutils literal"><span class="pre">getbytes</span></code> function).
Parameter <code class="docutils literal"><span class="pre">pos</span></code> indicates where the information will be placed
in the buffer pool's logical storage space.
Physically, it will actually be copied to the appropriate byte
position in some buffer in the buffer pool.
This ADT is similar to the <code class="docutils literal"><span class="pre">read</span></code> and <code class="docutils literal"><span class="pre">write</span></code> methods of the
<a class="reference internal" href="FileProg.html#fileprog"><em>RandomAccessFile</em></a> class of Java.</p>
<div class="topic" id="examplebuffer">
<p class="topic-title first">Example 11.4.1 </p>
<p>Assume each sector of the disk file (and thus each block in the
buffer pool) stores 1024 bytes.
If the next request is to copy 40 bytes beginning at position 6000 of
the file, these bytes should be placed into Sector 5 (whose bytes go
from position 5120 to position 6143).</p>
</div>
<p>An alternative interface is to have the buffer pool provide to the
user a direct pointer to a buffer that contains the requested
information.
Such an interface might look as follows:</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="c1">// ADT for buffer pools using the buffer-passing style</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">BufferPoolADT</span> <span class="o">{</span>
  <span class="c1">// Return pointer to the requested block</span>
  <span class="kd">public</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">getblock</span><span class="o">(</span><span class="kt">int</span> <span class="n">block</span><span class="o">);</span>

  <span class="c1">// Set the dirty bit for the buffer holding &quot;block&quot;</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">dirtyblock</span><span class="o">(</span><span class="kt">int</span> <span class="n">block</span><span class="o">);</span>

  <span class="c1">// Tell the size of a buffer</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">blocksize</span><span class="o">();</span>
<span class="o">};</span>
</pre></div>
</div>
<p>In this approach, the buffer pool user is made aware that the
storage space is divided into blocks of a given size, where each block
is the size of a buffer.
The user requests specific blocks from the buffer pool, with a pointer
to the buffer holding the requested block being returned to the user.
The user might then read from or write to this space.
If the user writes to the space, the buffer pool must be informed of
this fact.
The reason is that, when a given block is to be removed from the
buffer pool, the contents of that block must be written to the backing
storage if it has been modified.
If the block has not been modified, then it is unnecessary to write it
out.</p>
<div class="topic">
<p class="topic-title first">Example 11.4.2 </p>
<p>We wish to write 40 bytes beginning at logical position 6000 in
the file.
Using the second ADT, the client would need to know that blocks
(buffers) are of size 1024, and therefore would request access to
Sector 5.
A pointer to the buffer containing Sector 5 would be returned by
the call to <code class="docutils literal"><span class="pre">getblock</span></code>.
The client would then copy 40 bytes to positions 880-919 of the
buffer, and call <code class="docutils literal"><span class="pre">dirtyblock</span></code> to warn the buffer pool that the
contents of this block have been modified.</p>
</div>
<p>A variation on this approach is to have the <code class="docutils literal"><span class="pre">getblock</span></code> function
take another parameter to indicate the &quot;mode&quot; of use for the
information.
If the mode is READ then the buffer pool assumes that no changes will
be made to the buffer's contents (and so no write operation need be
done when the buffer is reused to store another block).
If the mode is WRITE then the buffer pool assumes that the client will
not look at the contents of the buffer and so no read from the file is
necessary.
If the mode is READ AND WRITE then the buffer pool would read the
existing contents of the block in from disk, and write the contents of
the buffer to disk when the buffer is to be reused.
Using the &quot;mode&quot; approach, the <code class="docutils literal"><span class="pre">dirtyblock</span></code> method is avoided.</p>
<p>One problem with the buffer-passing ADT is the risk of
<a class="reference internal" href="Glossary.html#term-stale-pointer"><em class="xref std std-term ODSAterm">stale pointers</em></a>.
When the buffer pool user is given a pointer to some buffer
space at time <strong>T1</strong>, that pointer does indeed refer to the desired
data at that time.
As further requests are made to the buffer pool, it is possible that
the data in any given buffer will be removed and replaced with new
data.
If the buffer pool user at a later time <strong>T2</strong> then refers to the
data referred to by the pointer given at time <strong>T1</strong>, it is possible
that the data are no longer valid because the buffer contents have
been replaced in the meantime.
Thus the pointer into the buffer pool's memory has become &quot;stale&quot;.
To guarantee that a pointer is not stale, it should not be used if
intervening requests to the buffer pool have taken place.</p>
<p>We can solve this problem by introducing the concept of a user (or
possibly multiple users) gaining access to a buffer, and then
releasing the buffer when done.
We will add method <code class="docutils literal"><span class="pre">acquireBuffer</span></code> and <code class="docutils literal"><span class="pre">releaseBuffer</span></code> for
this purpose.
Method <code class="docutils literal"><span class="pre">acquireBuffer</span></code> takes a block ID as input and returns a
pointer to the buffer that will be used to store this block.
The buffer pool will keep a count of the number of requests currently
active for this block.
Method <code class="docutils literal"><span class="pre">releaseBuffer</span></code> will reduce the count of active users for
the associated block.
Buffers associated with active blocks will not be eligible for
flushing from the buffer pool.
This will lead to a problem if the client neglects to release active
blocks when they are no longer needed.
There would also be a problem if there were more total active blocks
than buffers in the buffer pool.
So, the buffer pool should be initialized to include more
buffers than will ever need to be active at one time.</p>
<p>An additional problem with both ADTs presented so far comes when the
user intends to completely overwrite the contents of a block, and does
not need to read in the old contents already on disk.
However, the buffer pool cannot in general know whether the user
wishes to use the old contents or not.
This is especially true with the message-passing approach where a
given message might overwrite only part of the block.
In this case, the block will be read into memory even when not needed,
and then its contents will be overwritten.</p>
<p>This inefficiency can be avoided (at least in the buffer-passing
version) by separating the assignment of
blocks to buffers from actually reading in data for the block.
In particular, the following revised buffer-passing ADT does not
actually read data in the <code class="docutils literal"><span class="pre">acquireBuffer</span></code> method.
Users who wish to see the old contents must then issue a
<code class="docutils literal"><span class="pre">readBlock</span></code> request to read the data from disk into the buffer.</p>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="c1">// Improved ADT for buffer pools using the buffer-passing style.</span>
<span class="c1">// Most user functionality is in the buffer class, not the buffer pool itself.</span>

<span class="c1">// A single buffer in the buffer pool</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">BufferADT</span> <span class="o">{</span>
  <span class="c1">// Read the associated block from disk (if necessary) and return a</span>
  <span class="c1">// pointer to the data</span>
  <span class="kd">public</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">readBlock</span><span class="o">();</span>

  <span class="c1">// Return a pointer to the buffer&#39;s data array (without reading from disk)</span>
  <span class="kd">public</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">getDataPointer</span><span class="o">();</span>

  <span class="c1">// Flag buffer&#39;s contents as having changed, so that flushing the</span>
  <span class="c1">// block will write it back to disk</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">markDirty</span><span class="o">();</span>

  <span class="c1">// Release the block&#39;s access to this buffer. Further accesses to</span>
  <span class="c1">// this buffer are illegal</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">releaseBuffer</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="highlight-java"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">BufferPoolADT</span> <span class="o">{</span>

  <span class="c1">// Relate a block to a buffer, returning a pointer to a buffer object</span>
  <span class="n">Buffer</span> <span class="nf">acquireBuffer</span><span class="o">(</span><span class="kt">int</span> <span class="n">block</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Again, a mode parameter could be added to the <code class="docutils literal"><span class="pre">acquireBuffer</span></code>
method, eliminating the need for the <code class="docutils literal"><span class="pre">readBlock</span></code> and
<code class="docutils literal"><span class="pre">markDirty</span></code> methods.</p>
<p>Clearly, the buffer-passing approach places more obligations on the
user of the buffer pool.
These obligations include knowing the size of a block, not corrupting
the buffer pool's storage space, and informing the buffer pool both
when a block has been modified and when it is no longer needed.
So many obligations make this approach prone to error.
An advantage is that there is no need to do an extra copy step when
getting information from the user to the buffer.
If the size of the records stored is small, this is not an important
consideration.
If the size of the records is large (especially if the record size and
the buffer size are the same, as typically is the case when
implementing <a class="reference internal" href="BTree.html#btree"><em>B-trees</em></a>, then this efficiency
issue might become important.
Note however that the in-memory copy time will always be far less than
the time required to write the contents of a buffer to disk.
For applications where disk I/O is the bottleneck for the program,
even the time to copy lots of information between the buffer pool user
and the buffer might be inconsequential.
Another advantage to buffer passing is the reduction in unnecessary
read operations for data that will be overwritten anyway.</p>
<p>Note that using Java generics would not be appropriate for use in the
buffer pool implementation.
In our ADTs, the <code class="docutils literal"><span class="pre">space</span></code> parameter and the buffer pointer are declared
to be <code class="docutils literal"><span class="pre">byte[]</span></code>
When a class uses a Java generic, that means that the record type is
arbitrary, but that the class knows what the record type is.
In contrast, using <code class="docutils literal"><span class="pre">byte[]</span></code> for the space means that not
only is the record type arbitrary, but also the buffer pool does not
even know what the user's record type is.
In fact, a given buffer pool might have many users who store many types
of records.</p>
<p>In a buffer pool, the user decides where a given record will be stored
but has no control over the precise mechanism by which data are
transferred to the backing storage.
This is in contrast to the <a class="reference internal" href="MemmanIntro.html#memmanintro"><em>memory manager</em></a>, in
which the user passes a record to the manager and has no control at
all over where the record is stored.</p>
<script type="text/javascript" src="../../../AV/Files/buffintroCON.js"></script>
<script type="text/javascript" src="../../../AV/Files/LRUCON.js"></script>
<script type="text/javascript" src="../../../AV/Files/LRUwriteCON.js"></script>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      <p><span class="email_div" style="display:inline;"><a id="contact_us" class="contact" style="float:left;color:blue;" rel="nofollow" href="mailto:">Contact Us |</a><a style="float:left;color:blue;" rel="nofollow" href="../../../lib/Privacy.html" target="_blank">| Privacy |</a> <a style="float:left;color:blue;" rel="nofollow" href="../../../lib/license.html" target="_blank">| License</a></span>&#160;&#160;
      
        «&#160;&#160;<a id="prevmod1" href="Diskdrive.html">11.3. Disk Drives</a>
        &#160;&#160;::&#160;&#160;
        <a  class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a  id="nextmod1" href="FileProg.html">11.5. The Programmer's View of Files</a>&#160;&#160;»

</p>
      </div>
      <img style="float:right;" src="_static/nsf1.gif" height="62" width="62" alt="nsf"/>


    <div class="footer">
      <p>
        <span class="email_div" style="display:inline;">
          <a id="contact_us" class="contact" style="float:left;color:blue;" rel="nofollow" href="mailto:">Contact Us |</a>
          <a id="bugreport-link" style="float:left;color:blue;" class="bugreport-link" href="#">| Report a bug</a>
        </span>
      </p>
        &copy; Copyright 2016 by OpenDSA Project Contributors and distributed under an MIT license.
      Last updated on Nov 27, 2017.
      Created using <a target="_blank" href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.
    </div>
    
<div id="bugreport-box" class="bugreport-popup ">
  <a href="#" class="close"><img src="_static/Images/close_pop.png" class="btn_close" title="Close Window" alt="Close Window" /></a>
  <form method="post" class="report" action="https://#">
    <fieldset class="textbox">
      <div id="bug_error" class="error"></div>
      <label>
        <span>Summary*:</span>
        <input type="text" id="b_title" placeholder="Summary" />
      </label>

      <label class="os">
        <span>Operating system*:</span>
        <select id="b_os">
          <option value="windows">Windows</option>
          <option value="macos">Mac OS</option>
          <option value="linux">Linux</option>
          <option value="ios">iOS</option>
          <option value="android">Android</option>
          <option value="other">Other</option>
        </select>
      </label>

      <label class="browser">
        <span>Browser*:</span>
        <select id="b_browser">
          <option value="chrome">Chrome</option>
          <option value="safari">Safari</option>
          <option value="internetexplorer">Internet Explorer</option>
          <option value="opera">Opera</option>
          <option value="other">Other</option>
        </select>
      </label>

      <label class="description">
        <span>Description*:</span><br>
        <textarea id="b_description" rows="5" cols="25" placeholder="***BUG** Please enter: (1) a consice description of the problem. (2) steps to reproduce bug. (3) the version of your browser and operating system."></textarea>
      </label>

      <label class="screenshot">
        <span>Attach a screenshot (optional):</span>
        <input type="file" id="b_screenshot" accept="image/*" placeholder="Attach a screenshot (optional)">
      </label>

      <p>
        <input type="submit" id="bug-submit-button" value="Submit &rarr;"/>
      </p>
    </fieldset>
  </form>
</div>

  </body>
</html>