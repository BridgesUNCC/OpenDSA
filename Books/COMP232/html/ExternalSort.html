
<!DOCTYPE html>




<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>11.6. External Sorting &mdash; COMP232: Data Structures and Algorithms</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/normalize.css" type="text/css" />
    <link rel="stylesheet" href="../../../JSAV/css/JSAV.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/odsaMOD-min.css" type="text/css" />
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.11.4/themes/smoothness/jquery-ui.css" type="text/css" />
    <link rel="stylesheet" href="../../../lib/odsaStyle-min.css" type="text/css" />
    
  <script type="text/javascript">
    var DOCUMENTATION_OPTIONS = {
      URL_ROOT:    './',
      VERSION:     '0.4.1',
      COLLAPSE_INDEX: false,
      FILE_SUFFIX: '.html',
      HAS_SOURCE:  true
    };
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
      },
      "HTML-CSS": {
        scale: "80"
      }
    });
  </script>
    <link rel="index" title="COMP232: Data Structures and Algorithms" href="index.html" />
    <link rel="next" title="1. Introduction" href="HashIntro.html" />
    <link rel="prev" title="5. The Programmer&#39;s View of Files" href="FileProg.html" />

  </head>

  <body>


      <div class="header">
        
  
      <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
      <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="https://code.jquery.com/ui/1.11.4/jquery-ui.min.js"></script>
    <script type="text/javascript" src="../../../JSAV/lib/jquery.transit.js"></script>
    <script type="text/javascript" src="../../../JSAV/lib/raphael.js"></script>
    <script type="text/javascript" src="../../../JSAV/build/JSAV-min.js"></script>
    <script type="text/javascript" src="_static/config.js"></script>
    <script type="text/javascript" src="../../../lib/odsaUtils-min.js"></script>
    <script type="text/javascript" src="../../../lib/odsaMOD-min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js"></script>
    <script type="text/javascript" src="../../../lib/dataStructures.js"></script>
    <script type="text/javascript" src="../../../lib/conceptMap.js"></script>

        
<a id="username-link" style="float:right;color:red;margin:10px 20px auto; display: none" class="username-link" href="Gradebook.html"></a>
<a id="login-link" style="float:right;color:red;margin:10px 20px auto" class="login-link" href="#"><Macro 'login'></a>
<div id="login-box" class="login-popup">
  <a href="#" class="close"><img src="_static/Images/close_pop.png" class="btn_close" title="Close Window" alt="Close" /></a>
  <form method="post" class="signin" action="https://#">
    <fieldset class="textbox">
      <label class="username">
        <span>Username</span>
        <input id="username" value="" type="text" autocomplete="on" placeholder="Username" tabindex="1">
      </label>
      <label class="password">
        <span>Password</span>
        <input id="password" value="" type="password" placeholder="Password" tabindex="2">
        <span><a id="forgot" href="#">Forgot your password?</a></span>
      </label>

      <p>
        <input type="submit" id="login-submit-button" value="Sign in" tabindex="3" />
      </p>
      <p>
        <input type="button" id="register-button" value="Register" tabindex="4" />
      </p>
    </fieldset>
  </form>
</div>

        
<a id="registration-link" style="float:right;color:red;margin:10px 20px auto" class="registration-link" href="#">Register</a>
<div id="registration-box" class="registration-popup ">
  <a href="#" class="close"><img src="_static/Images/close_pop.png" class="btn_close" title="Close Window" alt="Close Window" /></a>
  <form method="post" class="signin" action="https://#">
    <fieldset class="textbox">
      <div id="register_error" class="error"></div>
      <label class="username">
        <span>Username:</span>
        <input type="text" id="user" placeholder="Username" />
      </label>

      <label class="password">
        <span>Password</span>
        <input id="pass" type="password" placeholder="Password" />
      </label>

      <label class="password">
        <span>Confirm Password</span>
        <input id="rpass" type="password" placeholder="Confirm Password" />
      </label>

      <label class="email">
        <span>Email:</span>
        <input type="text" id="email" placeholder="Email">
      </label>

      <p>
        <input type="submit" id="register-submit-button" value="Register &rarr;"/>
      </p>
    </fieldset>
  </form>
</div>
<img class="leftlogo" src="_static/OpenDSALogoT64.png" alt="Logo"/><div class="title-wrapper">
          <div class="title-inbetween" style="display: table-cell; vertical-align: middle;">
            <div class="title-content">
              <h1 class="heading" ><a href="index.html">
                <span>COMP232: Data Structures and Algorithms</span></a></h1>
              <h2 class="heading" ><span>Chapter 11 File Processing</span></h2>
            </div>
          </div>
        </div>
      </div>
      <div class="topnav">
        <p>
            <a style="float:left;color:blue;" href="../source/ExternalSort.rst"
              target="_blank" rel="nofollow">Show Source | </a>&#160;&#160;
            <a class="abt" style="float:left;color:blue;" href="#" rel="nofollow">| About</a>&#160;&#160;

          
        «&#160;&#160;<a id="prevmod" href="FileProg.html">11.5. The Programmer's View of Files</a>
        &#160;&#160;::&#160;&#160;
        <a  class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a  id="nextmod" href="HashIntro.html">12.1. Introduction</a>&#160;&#160;»


        </p>
      </div>
       
      <div class="content">
        
  <script>ODSA.SETTINGS.DISP_MOD_COMP = true;ODSA.SETTINGS.MODULE_NAME = "ExternalSort";ODSA.SETTINGS.MODULE_LONG_NAME = "ExternalSort";ODSA.SETTINGS.MODULE_CHAPTER = "File Processing"; ODSA.SETTINGS.BUILD_DATE = "2017-11-27 23:03:58"; ODSA.SETTINGS.BUILD_CMAP = false;JSAV_OPTIONS['lang']='en';JSAV_EXERCISE_OPTIONS['code']='java_generic';</script><link href="../../../AV/Files/extsortCON.css" rel="stylesheet" type="text/css" />
<div class="section" id="external-sorting">
<h1>11.6. External Sorting<a class="headerlink" href="#external-sorting" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2>11.6.1. External Sorting<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>We now consider the problem of sorting collections of
records too large to fit in main memory.
Because the records must reside in peripheral or external memory,
such sorting methods are called
<a class="reference internal" href="Glossary.html#term-external-sort"><em class="xref std std-term ODSAterm">external sorts</em></a>.
This is in contrast to <a class="reference internal" href="InSort.html#insort"><em>internal sorts</em></a>,
which assume that the records to be sorted are stored in main memory.
Sorting large collections of records is central to many applications,
such as processing payrolls and other large business databases.
As a consequence, many external sorting algorithms have been devised.
Years ago, sorting algorithm designers sought to optimize
the use of specific hardware configurations, such as multiple
tape or <a class="reference internal" href="Glossary.html#term-disk-drive"><em class="xref std std-term ODSAterm">disk drives</em></a>.
Most computing today is done on personal computers and low-end
workstations with relatively powerful CPUs, but only one or at most
two disk drives.
The techniques presented here are geared toward
optimized processing on a single disk drive.
This approach allows us to cover the most important issues in
external sorting while skipping many less important machine-dependent
details.</p>
<p>When a collection of records is too large to fit in
<a class="reference internal" href="Glossary.html#term-main-memory"><em class="xref std std-term ODSAterm">main memory</em></a>,
the only practical way to sort it is to read some records from disk,
do some rearranging, then write them back to disk.
This process is repeated until the file is sorted, with each record
read perhaps many times.
Given the high cost of <a class="reference internal" href="Glossary.html#term-disk-i-o"><em class="xref std std-term ODSAterm">disk I/O</em></a>, it should come as no surprise
that the primary goal of an external sorting algorithm is to minimize
the number of times information must be read from or written to disk.
A certain amount of additional CPU processing can profitably be traded
for reduced disk access.</p>
<p>Before discussing external sorting techniques, consider again the
basic model for accessing information from disk.
The file to be sorted is viewed by the programmer as a sequential
series of fixed-size <a class="reference internal" href="Glossary.html#term-block"><em class="xref std std-term ODSAterm">blocks</em></a>.
Assume (for simplicity) that each block contains the same
number of fixed-size data records.
Depending on the application, a record might be only a few bytes—composed of little or nothing more than the key—or might be
hundreds of bytes with a relatively small key field.
Records are assumed not to cross block boundaries.
These assumptions can be relaxed for special-purpose sorting
applications, but ignoring such complications makes the principles
clearer.</p>
<p>Recall that a <a class="reference internal" href="Diskdrive.html#diskdrive"><em>sector</em></a> is the basic unit
of I/O.
In other words, all disk reads and writes are for one or more complete
sectors.
Sector sizes are typically a power of two, in the range 512 to 16K
bytes, depending on the operating system and the size and speed of
the disk drive.
The block size used for external sorting algorithms should be equal to
or a multiple of the sector size.</p>
<p>Under this model, a sorting algorithm reads a block of data into a
buffer in main memory, performs some processing on it, and at some
future time writes it back to disk.
<a class="reference internal" href="Secondary.html#secondary"><em>Recall that</em></a> reading or writing a block from disk
takes on the order of one million times longer than a memory access.
Based on this fact, we can reasonably expect that the records
contained in a single block can be sorted by an internal
sorting algorithm such as <a class="reference internal" href="Quicksort.html#quicksort"><em>Quicksort Quicksort</em></a>
in less time than is required to read or write the block.</p>
<p>Under good conditions, reading from a file in sequential
order is more efficient than reading blocks in random order.
Given the significant impact of seek time on disk access, it
might seem obvious that sequential processing is faster.
However, it is important to understand precisely under what
circumstances sequential file processing is actually faster than
random access, because it affects our approach to designing an external
sorting algorithm.</p>
<p>Efficient sequential access relies on seek time being kept to a minimum.
The first requirement is that the blocks making up a file are in
fact stored on disk in sequential order and close together,
preferably filling a small number of contiguous tracks.
At the very least, the number of extents making up the file should be
small.
Users typically do not have much control over the layout of their file
on disk, but writing a file all at once in sequential order to a disk
drive with a high percentage of free space increases the likelihood of
such an arrangement.</p>
<p>The second requirement is that the disk drive's I/O head remain
positioned over the file throughout sequential processing.
This will not happen if there is competition of any kind for the I/O
head.
For example, on a multi-user time-shared computer the sorting process
might compete for the I/O head with the processes of other users.
Even when the sorting process has sole control of the I/O head, it is
still likely that sequential processing will not be efficient.
Imagine the situation where all processing is done on a single disk
drive, with the typical arrangement of a single bank of read/write
heads that move together over a stack of platters.
If the sorting process involves reading from an input file,
alternated with writing to an output file, then the I/O head will
continuously seek between the input file and the output file.
Similarly, if two input files are being processed simultaneously
(such as during a merge process), then the I/O head will
continuously seek between these two files.</p>
<p>The moral is that, with a single disk drive, there often is
no such thing as efficient sequential processing of a data file.
Thus, a sorting algorithm might be more efficient if it performs a
smaller number of non-sequential disk operations rather than a larger
number of logically sequential disk operations that require a large
number of seeks in practice.</p>
<p>As mentioned previously, the record size might be quite large compared
to the size of the key.
For example, payroll entries for a large business might each store
hundreds of bytes of information including the name, ID, address, and
job title for each employee.
The sort key might be the ID number, requiring only a few bytes.
The simplest sorting algorithm might be to process such records as a
whole, reading the entire record whenever it is processed.
However, this will greatly increase the amount of I/O required,
because only a relatively few records will fit into a single disk
block.
Another alternative is to do a <a class="reference internal" href="Glossary.html#term-key-sort"><em class="xref std std-term ODSAterm">key sort</em></a>.
Under this method, the keys are all read and stored together in an
<a class="reference internal" href="Glossary.html#term-index-file"><em class="xref std std-term ODSAterm">index file</em></a>, where each key is stored along
with a pointer indicating the position of the corresponding record in
the original data file.
The key and pointer combination should be substantially smaller than
the size of the original record; thus, the index file will be much
smaller than the complete data file.
The index file will then be sorted, requiring much less I/O because
the index records are smaller than the complete records.</p>
<p>Once the index file is sorted, it is possible to reorder the records
in the original database file.
This is typically not done for two reasons.
First, reading the records in sorted order from the record file
requires a random access for each record.
This can take a substantial amount of time and is only of value if
the complete collection of records needs to be viewed or processed in
sorted order (as opposed to a search for selected records).
Second, database systems typically allow searches to be
done on multiple keys.
For example, today's processing might be done in order of ID numbers.
Tomorrow, the boss might want information sorted by salary.
Thus, there might be no single &quot;sorted&quot; order for the full record.
Instead, multiple index files are often maintained, one for each sort
key.
These ideas are explored further in Chapter <a href="IndexIntro.html">Indexing</a>.</p>
<div class="section" id="simple-approaches-to-external-sorting">
<h3>11.6.1.1. Simple Approaches to External Sorting<a class="headerlink" href="#simple-approaches-to-external-sorting" title="Permalink to this headline">¶</a></h3>
<p>If your operating system
supports virtual memory, the simplest
&quot;external&quot; sort is to read the entire file into
virtual memory and run an internal sorting
method such as Quicksort.
This approach allows the virtual memory manager to use its normal
buffer pool mechanism to control disk accesses.
Unfortunately, this might not always be a viable option.
One potential drawback is that the size of virtual memory is
usually limited to something much smaller than the disk space
available.
Thus, your input file might not fit into virtual memory.
Limited virtual memory can be overcome by adapting an internal sorting
method to make use of your own buffer pool.</p>
<p>A more general problem with adapting an internal sorting algorithm
to external sorting is that it is not likely to be as efficient as
designing a new algorithm with the specific goal of minimizing
disk I/O.
Consider the simple adaptation of Quicksort to use a buffer pool.
Quicksort begins by processing the entire array of records, with the
first partition step moving indices inward from the two ends.
This can be implemented efficiently using a buffer pool.
However, the next step is to process each of the subarrays,
followed by processing of sub-subarrays, and so on.
As the subarrays get smaller, processing quickly approaches
random access to the disk drive.
Even with maximum use of the buffer pool, Quicksort still must read
and write each record <span class="math">\(\log n\)</span> times on average.
We can do much better.
Finally, even if the virtual memory manager can give good performance
using a standard Quicksort, this will come at the cost of using a lot
of the system's working memory, which will mean that the system cannot
use this space for other work.
Better methods can save time while also using less memory.</p>
<p>Our approach to external sorting is derived from the
Mergesort algorithm.
The simplest form of external Mergesort performs a series
of sequential passes over the records, merging larger and larger
sublists on each pass.
The first pass merges sublists of size 1 into sublists of
size 2; the second pass merges the sublists of size 2 into
sublists of size 4; and so on.
A sorted sublist is called a <a class="reference internal" href="Glossary.html#term-run"><em class="xref std std-term ODSAterm">run</em></a>.
Thus, each pass is merging pairs of runs to form longer runs.
Each pass copies the contents of the file to
another file.
Here is a sketch of the algorithm.</p>
<div id="extMergeSortCON" class="ssAV" data-points="0.0" data-threshold="1.0" data-type="ss" data-required="True" data-long-name="External Merge Sort Slideshow">
 <span class="jsavcounter"></span>
 <a class="jsavsettings" href="#">Settings</a>
 <div class="jsavcontrols"></div>
 <p class="jsavoutput jsavline"></p>
 <div class="jsavcanvas"></div>
 <div class="prof_indicators">
  <img id="extMergeSortCON_check_mark" class="prof_check_mark" src="_static/Images/green_check.png" alt="Proficient" />
  <span id="extMergeSortCON_cm_saving_msg" class="cm_saving_msg">Saving...</span>
  <span id="extMergeSortCON_cm_error_msg" class="cm_error_msg">
   <img id="extMergeSortCON_cm_warning_icon" class="cm_warning_icon" src="_static/Images/warning.png" alt="Error Saving" /><br />
   Server Error<br />
   <a href="#" class="resubmit_link">Resubmit</a>
  </span>
 </div>
</div>
<p></p>
<ol class="arabic simple">
<li>Split the original file into two equal-sized
<a class="reference internal" href="Glossary.html#term-run-file"><em class="xref std std-term ODSAterm">run files</em></a>.</li>
<li>Read one block from each run file into input buffers.</li>
<li>Take the first record from each input buffer, and write a run of
length two to an output buffer in sorted order.</li>
<li>Take the next record from each input buffer, and write a run of
length two to a second output buffer in sorted order.</li>
<li>Repeat until finished, alternating output between the two output
run buffers.
Whenever the end of an input block is reached, read the next block
from the appropriate input file.
When an output buffer is full, write it to the appropriate output
file.</li>
<li>Repeat steps 2 through 5, using the original output files as
input files.
On the second pass, the first two records of each input run file
are already in sorted order.
Thus, these two runs may be merged and output as a single run of
four elements.</li>
<li>Each pass through the run files provides larger and larger runs
until only one run remains.</li>
</ol>
<p>This algorithm can easily take advantage of
double buffering .
Note that the various passes read the input run files
sequentially and write the output run files sequentially.
For sequential processing and double buffering to be effective,
however, it is necessary that there be a separate I/O head available
for each file.
This typically means that each of the input and output files must be
on separate disk drives, requiring a total of four disk drives for
maximum efficiency.</p>
</div>
<div class="section" id="improving-performance">
<h3>11.6.1.2. Improving Performance<a class="headerlink" href="#improving-performance" title="Permalink to this headline">¶</a></h3>
<p>The external Mergesort algorithm just described requires that
<span class="math">\(\log n\)</span> passes be made to sort a file of <span class="math">\(n\)</span> records.
Thus, each record must be read from disk and written to disk
<span class="math">\(\log n\)</span> times.
The number of passes can be significantly reduced by observing that
it is not necessary to use Mergesort on small runs.
A simple modification is to read in a block of data, sort it in
memory (perhaps using Quicksort), and then output it as a single
sorted run.</p>
<div id="extMergeSortExampCON" class="ssAV" data-points="0.0" data-threshold="1.0" data-type="ss" data-required="True" data-long-name="External Merge Sort Example Slideshow">
 <span class="jsavcounter"></span>
 <a class="jsavsettings" href="#">Settings</a>
 <div class="jsavcontrols"></div>
 <p class="jsavoutput jsavline"></p>
 <div class="jsavcanvas"></div>
 <div class="prof_indicators">
  <img id="extMergeSortExampCON_check_mark" class="prof_check_mark" src="_static/Images/green_check.png" alt="Proficient" />
  <span id="extMergeSortExampCON_cm_saving_msg" class="cm_saving_msg">Saving...</span>
  <span id="extMergeSortExampCON_cm_error_msg" class="cm_error_msg">
   <img id="extMergeSortExampCON_cm_warning_icon" class="cm_warning_icon" src="_static/Images/warning.png" alt="Error Saving" /><br />
   Server Error<br />
   <a href="#" class="resubmit_link">Resubmit</a>
  </span>
 </div>
</div>
<p></p>
<p>We can extend this concept to improve performance even
further.
Available main memory is usually much more than one block in size.
If we process larger initial runs, then the number of passes
required by Mergesort is further reduced.
For example, most modern computers can provide tens or even hundreds
of megabytes of RAM to the sorting program.
If all of this memory (excepting a small amount for buffers
and local variables) is devoted to building initial runs as large as
possible, then quite large files can be processed in few passes.
The next section presents a technique for producing large runs,
typically twice as large as could fit directly into main memory.</p>
<p>Another way to reduce the number of passes required is to increase
the number of runs that are merged together during each pass.
While the standard Mergesort algorithm merges two runs at a time,
there is no reason why merging needs to be limited in this way.
Below we will discuss the technique of multiway merging.</p>
<p>Over the years, many variants on external sorting have been
presented, but all are based on the following two steps:</p>
<ol class="arabic simple">
<li>Break the file into large initial runs.</li>
<li>Merge the runs together to form a single sorted file.</li>
</ol>
</div>
<div class="section" id="replacement-selection">
<h3>11.6.1.3. Replacement Selection<a class="headerlink" href="#replacement-selection" title="Permalink to this headline">¶</a></h3>
<p>This section treats the problem of creating initial runs as large as
possible from a disk file, assuming a fixed amount of RAM is available
for processing.
As mentioned previously, a simple approach is to
allocate as much RAM as possible to a large array, fill this array
from disk, and sort the array using
Quicksort.
Thus, if the size of memory available for the array is <span class="math">\(M\)</span>
records,
then the input file can be broken into initial runs of length <cite>M</cite>.
A better approach is to use an algorithm called
<a class="reference internal" href="Glossary.html#term-replacement-selection"><em class="xref std std-term ODSAterm">replacement selection</em></a> that, on average, creates runs of
<span class="math">\(2M\)</span> records in length.
Replacement selection is actually a slight variation on the Heapsort
algorithm.
The fact that Heapsort is slower than Quicksort is
irrelevant in this context because I/O time will dominate the total
running time of any reasonable external sorting algorithm.
Building longer initial runs will reduce the total I/O time required.</p>
<p>Replacement selection views RAM as consisting of an array of
size <span class="math">\(M\)</span> in addition to an input buffer and an output buffer.
(Additional I/O buffers might be desirable if the
operating system supports double buffering,
because replacement selection does sequential
processing on both its input and its output.)
Imagine that the input and output files are streams of records.
Replacement selection takes the next record in sequential order from
the input stream when needed, and outputs runs one record at a
time to the output stream.
Buffering is used so that disk I/O is performed one block at a time.
A block of records is initially read and held in the input buffer.
Replacement selection removes records from the input buffer one at a
time until the buffer is empty.
At this point the next block of records is read in.
Output to a buffer is similar:
Once the buffer fills up it is written to disk as a unit.
This process is illustrated by Figure <a href="ExternalSort.html#rsover">11.6.1</a>.</p>
<div class="divdgm" id="rsover">
<div id="extSortOverCON">
</div>
<p class="caption" style="text-align: justify"> Figure 11.6.1: Overview of replacement selection.
Input records are processed sequentially.
Initially RAM is filled with <span class="math">\(M\)</span> records.
As records are processed, they are written to an output buffer.
When this buffer becomes full, it is written to disk.
Meanwhile, as replacement selection needs records, it reads them
from the input buffer.
Whenever this buffer becomes empty, the next block of records is
read from disk.</p>
</div>
<p>Replacement selection works as follows.
Assume that the main processing is done in an array of size <span class="math">\(M\)</span>
records.</p>
<ol class="arabic simple">
<li>Fill the array from disk.  Set <code class="docutils literal"><span class="pre">LAST</span> <span class="pre">=</span> <span class="pre">M-1</span></code>.</li>
<li>Build a min-heap.
(Recall that a min-heap is defined such that the
record at each node has a key value <em>less</em> than the key values of
its children.)</li>
<li>Repeat until the array is empty:<ol class="loweralpha">
<li>Send the record with the minimum key value (the root) to the
output buffer.</li>
<li>Let <span class="math">\(R\)</span> be the next record in the input buffer.
If <span class="math">\(R\)</span> 's key value is greater than the key value just output ...<ol class="lowerroman">
<li>Then place <span class="math">\(R\)</span> at the root.</li>
<li>Else replace the root with the record in array position
<code class="docutils literal"><span class="pre">LAST</span></code>, and place <span class="math">\(R\)</span> at position <code class="docutils literal"><span class="pre">LAST</span></code>.
Set <code class="docutils literal"><span class="pre">LAST</span> <span class="pre">=</span> <span class="pre">LAST</span> <span class="pre">-</span> <span class="pre">1</span></code>.</li>
</ol>
</li>
<li>Sift down the root to reorder the heap.</li>
</ol>
</li>
</ol>
<p>When the test at step 3(b) is successful, a new record is added
to the heap, eventually to be output as part of the run.
As long as records coming from the input file have key values
greater than the last key value output to the run, they can be safely
added to the heap.
Records with smaller key values cannot be output as
part of the current run because they would not be in sorted order.
Such values must be stored somewhere for future processing as part of
another run.
However, because the heap will shrink by one element in this case,
there is now a free space where the last element of the heap used to
be!
Thus, replacement selection will slowly shrink the heap and at the
same time use the discarded heap space to store records for the next
run.
Once the first run is complete (i.e., the heap becomes empty), the
array will be filled with records ready to be processed for the second
run.
Here is a visualization to show a run being created
by replacement selection.</p>
<div id="extRSCON" class="ssAV" data-points="0.0" data-threshold="1.0" data-type="ss" data-required="True" data-long-name="External Replacement Selection Slideshow">
 <span class="jsavcounter"></span>
 <a class="jsavsettings" href="#">Settings</a>
 <div class="jsavcontrols"></div>
 <p class="jsavoutput jsavline"></p>
 <div class="jsavcanvas"></div>
 <div class="prof_indicators">
  <img id="extRSCON_check_mark" class="prof_check_mark" src="_static/Images/green_check.png" alt="Proficient" />
  <span id="extRSCON_cm_saving_msg" class="cm_saving_msg">Saving...</span>
  <span id="extRSCON_cm_error_msg" class="cm_error_msg">
   <img id="extRSCON_cm_warning_icon" class="cm_warning_icon" src="_static/Images/warning.png" alt="Error Saving" /><br />
   Server Error<br />
   <a href="#" class="resubmit_link">Resubmit</a>
  </span>
 </div>
</div>
<p></p>
<p>It should be clear that the minimum length of a run will be <span class="math">\(M\)</span>
records if the size of the heap is <span class="math">\(M\)</span>, because at least those
records originally in the heap will be part of the run.
Under good conditions (e.g., if the input is sorted), then an
arbitrarily long run is possible.
In fact, the entire file could be processed as one run.
If conditions are bad (e.g., if the input is reverse sorted),
then runs of only size <span class="math">\(M\)</span> result.</p>
<p>What is the expected length of a run generated by replacement
selection?
It can be deduced from an analogy called the
<a class="reference internal" href="Glossary.html#term-snowplow-argument"><em class="xref std std-term ODSAterm">snowplow argument</em></a>.
Imagine that a snowplow is going around a circular track during a
heavy, but steady, snowstorm.
After the plow has been around at least once, snow on
the track must be as follows.
Immediately behind the plow, the track is empty because it was just
plowed.
The greatest level of snow on the track is immediately in front of the
plow, because this is the place least recently plowed.
At any instant, there is a certain amount of snow <span class="math">\(S\)</span> on the
track.
Snow is constantly falling throughout the track at a steady rate,
with some snow falling &quot;in front&quot; of the plow and some &quot;behind&quot;
the plow.
(On a circular track, everything is actually &quot;in front&quot; of
the plow, but Figure~ref{SnowPlow} illustrates the idea.)
During the next revolution of the plow, all snow <span class="math">\(S\)</span> on the
track is removed, plus half of what falls.
Because everything is assumed to be in steady state, after one
revolution <span class="math">\(S\)</span> snow is still on the track, so <span class="math">\(2S\)</span> snow
must fall during a revolution, and <span class="math">\(2S\)</span> snow is removed during a
revolution (leaving <span class="math">\(S\)</span> snow behind).</p>
<div class="divdgm" id="snowplow">
<div id="extSortSnowCON">
</div>
<p class="caption" style="text-align: justify"> Figure 11.6.2: The snowplow analogy showing the action during one
revolution of the snowplow.
A circular track is laid out straight for purposes of illustration,
and is shown in cross section.
At any time <span class="math">\(T\)</span>, the most snow is directly in front of the
snowplow.
As the plow moves around the track, the same amount of snow is
always in front of the plow.
As the plow moves forward, less of this is snow that was in
the track at time <span class="math">\(T\)</span>; more is snow that has fallen since.</p>
</div>
<p>At the beginning of replacement selection, nearly all values coming
from the input file are greater (i.e., &quot;in front of the plow&quot;)
than the latest key value output for
this run, because the run's initial key values should be small.
As the run progresses, the latest key value output becomes greater and
so new key values coming from the input file are more likely to be too
small (i.e., &quot;after the plow&quot;); such records go to the bottom of
the array.
The total length of the run is expected to be twice the size of the
array.
Of course, this assumes that incoming key values are evenly distributed
within the key range (in terms of the snowplow analogy, we assume that
snow falls evenly throughout the track).
Sorted and reverse sorted inputs do not meet this expectation and so
change the length of the run.</p>
<div
    id="extRSPRO"
    class="embedContainer"
    data-exer-name="extRSPRO"
    data-long-name="Replacement Selection Proficiency Exercise"
    data-frame-src="../../../AV/Files/extRSPRO.html?selfLoggingEnabled=false&amp;localMode=true&amp;module=ExternalSort&amp;JOP-lang=en&amp;JXOP-code=java_generic"
    data-frame-width="950"
    data-frame-height="650"
    data-external="false"
    data-points="1.0"
    data-required="True"
    data-showhide="none"
    data-threshold="1.0"
    data-type="pe">
  
  <div class="center">
    <div id="extRSPRO_iframe"></div>
  </div>
</div>
</div>
</div>
<div class="section" id="multiway-merging">
<h2>11.6.2. Multiway Merging<a class="headerlink" href="#multiway-merging" title="Permalink to this headline">¶</a></h2>
<p>The second stage of a typical external sorting algorithm merges the
runs created by the first stage.
Assume that we have <span class="math">\(R\)</span> runs to merge.
If a simple two-way merge is used, then <span class="math">\(R\)</span> runs
(regardless of their sizes) will require <span class="math">\(\log R\)</span> passes through
the file.
While <span class="math">\(R\)</span> should be much less than the total number of records
(because the initial runs should each contain many records),
we would like to reduce still further the number of passes required
to merge the runs together.
Note that two-way merging does not make good use of available memory.
Because merging is a sequential process on the two runs, only one block
of records per run need be in memory at a time.
Keeping more than one block of a run in memory at any time will
not reduce the disk I/O required by the merge process
(though if several blocks are read from a file at once time,
at least they take advantage of sequential access).
Thus, most of the space just used by the heap for replacement
selection (typically many blocks in length) is not being used by the
merge process.</p>
<p>We can make better use of this space and at the same time greatly
reduce the number of passes needed to merge the runs if we merge
several runs at a time.
Multiway merging is similar to two-way merging.
If we have <span class="math">\(B\)</span> runs to merge, with a block from each run
available in memory, then the <span class="math">\(B\)</span>-way merge algorithm simply
looks at <span class="math">\(B\)</span> values (the front-most value for each input run)
and selects the smallest one to output.
This value is removed from its run, and the process is repeated.
When the current block for any run is exhausted, the next block from
that run is read from disk.
The following slideshow illustrates a multiway merge.</p>
<div id="extMultiMergeCON" class="ssAV" data-points="0.0" data-threshold="1.0" data-type="ss" data-required="True" data-long-name="Multiway Merge Example Slideshow">
 <span class="jsavcounter"></span>
 <a class="jsavsettings" href="#">Settings</a>
 <div class="jsavcontrols"></div>
 <p class="jsavoutput jsavline"></p>
 <div class="jsavcanvas"></div>
 <div class="prof_indicators">
  <img id="extMultiMergeCON_check_mark" class="prof_check_mark" src="_static/Images/green_check.png" alt="Proficient" />
  <span id="extMultiMergeCON_cm_saving_msg" class="cm_saving_msg">Saving...</span>
  <span id="extMultiMergeCON_cm_error_msg" class="cm_error_msg">
   <img id="extMultiMergeCON_cm_warning_icon" class="cm_warning_icon" src="_static/Images/warning.png" alt="Error Saving" /><br />
   Server Error<br />
   <a href="#" class="resubmit_link">Resubmit</a>
  </span>
 </div>
</div>
<p></p>
<p>Conceptually, multiway merge assumes that each run is stored in a
separate file.
However, this is not necessary in practice.
We only need to know the position of each run within a single file,
and use <code class="docutils literal"><span class="pre">seek</span></code> to move to the appropriate
block whenever we need new data from a particular run.
Naturally, this approach destroys the ability to do sequential
processing on the input file.
However, if all runs were stored on a single disk drive,
then processing would not be truly sequential anyway because the
I/O head would be alternating between the runs.
Thus, multiway merging replaces several (potentially) sequential
passes with a single random access pass.
If the processing would not be sequential anyway (such as when all
processing is on a single disk drive), no time is lost by doing so.</p>
<div
    id="extMultiMergePRO"
    class="embedContainer"
    data-exer-name="extMultiMergePRO"
    data-long-name="Multi-way Merge Proficiency Exercise"
    data-frame-src="../../../AV/Files/extMultiMergePRO.html?selfLoggingEnabled=false&amp;localMode=true&amp;module=ExternalSort&amp;JOP-lang=en&amp;JXOP-code=java_generic"
    data-frame-width="950"
    data-frame-height="650"
    data-external="false"
    data-points="1.0"
    data-required="True"
    data-showhide="none"
    data-threshold="0.9"
    data-type="pe">
  
  <div class="center">
    <div id="extMultiMergePRO_iframe"></div>
  </div>
</div>
<p>Multiway merging can greatly reduce the number of passes required.
If there is room in memory to store one block for each run, then all
runs can be merged in a single pass.
Thus, replacement selection can build
initial runs in one pass, and multiway merging can merge all runs in
one pass, yielding a total cost of two passes.
However, for truly large files, there might be too many runs for each
to get a block in memory.
If there is room to allocate <span class="math">\(B\)</span> blocks for a <span class="math">\(B\)</span>-way
merge, and the number of runs <span class="math">\(R\)</span> is greater than <span class="math">\(B\)</span>,
then it will be necessary to do multiple merge passes.
In other words, the first <span class="math">\(B\)</span> runs are merged, then the next
<span class="math">\(B\)</span>, and so on.
These super-runs are then merged by subsequent passes,
<span class="math">\(B\)</span> super-runs at a time.</p>
<p>How big a file can be merged in one pass?
Assuming <span class="math">\(B\)</span> blocks were allocated to the heap for
replacement selection (resulting in runs of average length <span class="math">\(2B\)</span>
blocks), followed by a <span class="math">\(B\)</span>-way merge, we can process
on average a file of size (2B^2) blocks in a single multiway merge.
<span class="math">\(2B^{k+1}\)</span> blocks on average can be processed in <span class="math">\(k\)</span>
<span class="math">\(B\)</span>-way merges.
To gain some appreciation for how quickly this grows, assume that we
have available 0.5MB of working memory, and that a block is
4KB, yielding 128 blocks in working memory.
The average run size is 1MB (twice the working memory size).
In one pass, 128 runs can be merged.
Thus, a file of size 128MB can, on average, be processed in two
passes (one to build the runs, one to do the merge) with only
0.5MB of working memory.
As another example, assume blocks are 1KB long and working memory
is 1MB <span class="math">\(=\)</span> 1024 blocks.
Then 1024 runs of average length 2MB (which is about 2GB) can be
combined in a single merge pass.
A larger block size would reduce the size of the file that can be
processed in one merge pass for a fixed-size working memory; a smaller
block size or larger working memory would increase the file size that
can be processed in one merge pass.
Two merge passes allow much bigger files to be processed.
With 0.5MB of working memory and 4KB blocks,
a file of size 16~gigabytes could be processed in two merge passes,
which is big enough for most applications.
Thus, this is a very effective algorithm for single disk drive
external sorting.</p>
<div class="section" id="empirical-results">
<h3>11.6.2.1. Empirical Results<a class="headerlink" href="#empirical-results" title="Permalink to this headline">¶</a></h3>
<p>Table <a href="ExternalSort.html#exsorttimes">11.6.1</a> shows a comparison of the running time to
sort various-sized files for the following implementations:
(1) standard Mergesort with two input runs and two output runs,
(2) two-way Mergesort with large initial runs (limited by the size of
available memory),
and (3) <span class="math">\(R\)</span>-way Mergesort performed after generating large
initial runs.
In each case, the file was composed of a series of four-byte records
(a two-byte key and a two-byte data value),
or 256K records per megabyte of file size.
We can see from this table that using even a modest memory size (two
blocks) to create initial runs results in a tremendous savings in
time.
Doing 4-way merges of the runs provides another considerable speedup,
however large-scale multi-way merges for <span class="math">\(R\)</span> beyond about 4 or 8
runs does not help much because a lot of time is spent determining
which is the next smallest element among the <span class="math">\(R\)</span> runs.</p>
<div class="topic" id="exsorttimes">
<p class="topic-title first">Table 11.6.1  </p>
<p>A comparison of three external sorts on a collection of small
records for files of various sizes.
Each entry in the table shows time in seconds and total number of
blocks read and written by the program.
File sizes are in Megabytes.
For the third sorting algorithm, on a file size of 4MB, the time
and blocks shown in the last column are for a 32-way merge
(marked with an asterisk).
32 is used instead of 16 because 32 is a root of the number of
blocks in the file (while 16 is not), thus allowing the same number
of runs to be merged at every pass.</p>
<div class="math">
\[\begin{split}\begin{array}{|r|c|cccc|ccc|}
\hline
\textbf{File}&amp;
\textbf{Sort 1}&amp;
\textbf{Sort 2}&amp;&amp;&amp;&amp;
\textbf{Sort 3}\\
\textbf{Size}&amp;&amp;
\textbf{Memory size (in blocks)}&amp;&amp;&amp;&amp;
\textbf{Memory size (in blocks)}\\
(Mb)&amp;&amp;\textbf{2} &amp;
\textbf{4} &amp;
\textbf{16} &amp;
\textbf{256} &amp;
\textbf{2} &amp;
\textbf{4} &amp;
\textbf{16}\\
\hline
  1&amp;   0.61 &amp;   0.27 &amp;   0.24 &amp;   0.19 &amp;   0.10 &amp;   0.21 &amp;   0.15 &amp;   0.13\\
   &amp;  4,864 &amp;  2,048 &amp;  1,792 &amp;  1,280 &amp;    256 &amp;  2,048 &amp;  1,024 &amp;    512\\
\hline
  4&amp;   2.56 &amp;   1.30 &amp;   1.19 &amp;   0.96 &amp;   0.61 &amp;   1.15 &amp;   0.68 &amp;   0.66*\\
   &amp; 21,504 &amp; 10,240 &amp;  9,216 &amp;  7,168 &amp;  3,072 &amp; 10,240 &amp;  5,120 &amp;  2,048\\
\hline
 16&amp;  11.28 &amp;   6.12 &amp;   5.63 &amp;   4.78 &amp;   3.36 &amp;   5.42 &amp;   3.19 &amp;   3.10\\
   &amp; 94,208 &amp; 49,152 &amp; 45,056 &amp; 36,864 &amp; 20,480 &amp; 49,152 &amp; 24,516 &amp; 12,288\\
\hline
256&amp; 220.39 &amp; 132.47 &amp; 123.68 &amp; 110.01 &amp;  86.66 &amp; 115.73 &amp;  69.31 &amp;  68.71\\
   &amp;  1,769K&amp;  1,048K&amp;    983K&amp;    852K&amp;    589K&amp;  1,049K&amp;    524K&amp;   262K\\
\hline
\end{array}\end{split}\]</div>
</div>
<p>We see from this experiment that building large initial runs reduces
the running time to slightly more than one third that of standard
Mergesort, depending on file and memory sizes.
Using a multi-way merge further cuts the time nearly in half.</p>
</div>
<div class="section" id="summary">
<h3>11.6.2.2. Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h3>
<p>In summary, a good external sorting algorithm will seek to do the
following:</p>
<ul class="simple">
<li>Make the initial runs as long as possible.</li>
<li>At all stages, overlap input, processing, and output as much as
possible.</li>
<li>Use as much working memory as possible.
Applying more memory usually speeds processing.
In fact, more memory will have a greater effect than a faster disk.
A faster CPU is unlikely to yield much improvement in running time
for external sorting, because disk I/O speed is the limiting factor.</li>
<li>If possible, use additional disk drives for more overlapping of
processing with I/O, and to allow for sequential file
processing.</li>
</ul>
<script type="text/javascript" src="../../../DataStructures/binaryheap.js"></script>
<script type="text/javascript" src="../../../AV/Files/extMergeSortCON.js"></script>
<script type="text/javascript" src="../../../AV/Files/extMergeSortExampCON.js"></script>
<script type="text/javascript" src="../../../AV/Files/extSortOverCON.js"></script>
<script type="text/javascript" src="../../../AV/Files/extRSCON.js"></script>
<script type="text/javascript" src="../../../AV/Files/extSortSnowCON.js"></script>
<script type="text/javascript" src="../../../AV/Files/extMultiMergeCON.js"></script>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      <p><span class="email_div" style="display:inline;"><a id="contact_us" class="contact" style="float:left;color:blue;" rel="nofollow" href="mailto:">Contact Us |</a><a style="float:left;color:blue;" rel="nofollow" href="../../../lib/Privacy.html" target="_blank">| Privacy |</a> <a style="float:left;color:blue;" rel="nofollow" href="../../../lib/license.html" target="_blank">| License</a></span>&#160;&#160;
      
        «&#160;&#160;<a id="prevmod1" href="FileProg.html">11.5. The Programmer's View of Files</a>
        &#160;&#160;::&#160;&#160;
        <a  class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a  id="nextmod1" href="HashIntro.html">12.1. Introduction</a>&#160;&#160;»

</p>
      </div>
      <img style="float:right;" src="_static/nsf1.gif" height="62" width="62" alt="nsf"/>


    <div class="footer">
      <p>
        <span class="email_div" style="display:inline;">
          <a id="contact_us" class="contact" style="float:left;color:blue;" rel="nofollow" href="mailto:">Contact Us |</a>
          <a id="bugreport-link" style="float:left;color:blue;" class="bugreport-link" href="#">| Report a bug</a>
        </span>
      </p>
        &copy; Copyright 2016 by OpenDSA Project Contributors and distributed under an MIT license.
      Last updated on Nov 27, 2017.
      Created using <a target="_blank" href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.
    </div>
    
<div id="bugreport-box" class="bugreport-popup ">
  <a href="#" class="close"><img src="_static/Images/close_pop.png" class="btn_close" title="Close Window" alt="Close Window" /></a>
  <form method="post" class="report" action="https://#">
    <fieldset class="textbox">
      <div id="bug_error" class="error"></div>
      <label>
        <span>Summary*:</span>
        <input type="text" id="b_title" placeholder="Summary" />
      </label>

      <label class="os">
        <span>Operating system*:</span>
        <select id="b_os">
          <option value="windows">Windows</option>
          <option value="macos">Mac OS</option>
          <option value="linux">Linux</option>
          <option value="ios">iOS</option>
          <option value="android">Android</option>
          <option value="other">Other</option>
        </select>
      </label>

      <label class="browser">
        <span>Browser*:</span>
        <select id="b_browser">
          <option value="chrome">Chrome</option>
          <option value="safari">Safari</option>
          <option value="internetexplorer">Internet Explorer</option>
          <option value="opera">Opera</option>
          <option value="other">Other</option>
        </select>
      </label>

      <label class="description">
        <span>Description*:</span><br>
        <textarea id="b_description" rows="5" cols="25" placeholder="***BUG** Please enter: (1) a consice description of the problem. (2) steps to reproduce bug. (3) the version of your browser and operating system."></textarea>
      </label>

      <label class="screenshot">
        <span>Attach a screenshot (optional):</span>
        <input type="file" id="b_screenshot" accept="image/*" placeholder="Attach a screenshot (optional)">
      </label>

      <p>
        <input type="submit" id="bug-submit-button" value="Submit &rarr;"/>
      </p>
    </fieldset>
  </form>
</div>

  </body>
</html>